["<!---\nCopyright 2021 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n<p align=\"center\">\n    <br>\n    <img src=\"https://raw.githubusercontent.com/huggingface/accelerate/main/docs/source/imgs/accelerate_logo.png\" width=\"400\"/>\n    <br>\n<p>\n\n<p align=\"center\">\n    <!-- Uncomment when CircleCI is set up\n    <a href=\"https://circleci.com/gh/huggingface/accelerate\">\n        <img alt=\"Build\" src=\"https://img.shields.io/circleci/build/github/huggingface/transformers/master\">\n    </a>\n    -->\n    <a href=\"https://github.com/huggingface/accelerate/blob/main/LICENSE\">\n        <img alt=\"License\" src=\"https://img.shields.io/github/license/huggingface/accelerate.svg?color=blue\">\n    </a>\n    <a href=\"https://huggingface.co/docs/accelerate/index.html\">\n        <img alt=\"Documentation\" src=\"https://img.shields.io/website/http/huggingface.co/docs/accelerate/index.html.svg?down_color=red&down_message=offline&up_message=online\">\n    </a>\n    <a href=\"https://github.com/huggingface/accelerate/releases\">\n        <img alt=\"GitHub release\" src=\"https://img.shields.io/github/release/huggingface/accelerate.svg\">\n    </a>\n    <a href=\"https://github.com/huggingface/accelerate/blob/main/CODE_OF_CONDUCT.md\">\n        <img alt=\"Contributor Covenant\" src=\"https://img.shields.io/badge/Contributor%20Covenant-v2.0%20adopted-ff69b4.svg\">\n    </a>\n</p>\n\n<h3 align=\"center\">\n<p>Run your *raw* PyTorch training script on any kind of device\n</h3>\n\n<h3 align=\"center\">\n    <a href=\"https://hf.co/course\"><img src=\"https://raw.githubusercontent.com/huggingface/accelerate/main/docs/source/imgs/course_banner.png\"></a>\n</h3>\n\n## Easy to integrate\n\n\ud83e\udd17 Accelerate was created for PyTorch users who like to write the training loop of PyTorch models but are reluctant to write and maintain the boilerplate code needed to use multi-GPUs/TPU/fp16.\n\n\ud83e\udd17 Accelerate abstracts exactly and only the boilerplate code related to multi-GPUs/TPU/fp16 and leaves the rest of your code unchanged.\n\nHere is an example:\n\n```diff\n  import torch\n  import torch.nn.functional as F\n  from datasets import load_dataset\n+ from accelerate import Accelerator\n\n+ accelerator = Accelerator()\n- device = 'cpu'\n+ device = accelerator.device\n\n  model = torch.nn.Transformer().to(device)\n  optimizer = torch.optim.Adam(model.parameters())\n\n  dataset = load_dataset('my_dataset')\n  data = torch.utils.data.DataLoader(dataset, shuffle=True)\n\n+ model, optimizer, data = accelerator.prepare(model, optimizer, data)\n\n  model.train()\n  for epoch in range(10):\n      for source, targets in data:\n          source = source.to(device)\n          targets = targets.to(device)\n\n          optimizer.zero_grad()\n\n          output = model(source)\n          loss = F.cross_entropy(output, targets)\n\n-         loss.backward()\n+         accelerator.backward(loss)\n\n          optimizer.step()\n```\n\nAs you can see in this example, by adding 5-lines to any standard PyTorch training script you can now run on any kind of single or distributed node setting (single CPU, single GPU, multi-GPUs and TPUs) as well as with or without mixed precision (fp8, fp16, bf16).\n\nIn particular, the same code can then be run without modification on your local machine for debugging or your training environment.\n\n\ud83e\udd17 Accelerate even handles the device placement for you (which requires a few more changes to your code, but is safer in general), so you can even simplify your training loop further:\n\n```diff\n  import torch\n  import torch.nn.functional as F\n  from datasets import load_dataset\n+ from accelerate import Accelerator\n\n- device = 'cpu'\n+ accelerator = Accelerator()\n\n- model = torch.nn.Transformer().to(device)\n+ model = torch.nn.Transformer()\n  optimizer = torch.optim.Adam(model.parameters())\n\n  dataset = load_dataset('my_dataset')\n  data = torch.utils.data.DataLoader(dataset, shuffle=True)\n\n+ model, optimizer, data = accelerator.prepare(model, optimizer, data)\n\n  model.train()\n  for epoch in range(10):\n      for source, targets in data:\n-         source = source.to(device)\n-         targets = targets.to(device)\n\n          optimizer.zero_grad()\n\n          output = model(source)\n          loss = F.cross_entropy(output, targets)\n\n-         loss.backward()\n+         accelerator.backward(loss)\n\n          optimizer.step()\n```\n\nWant to learn more? Check out the [documentation](https://huggingface.co/docs/accelerate) or have a look at our [examples](https://github.com/huggingface/accelerate/tree/main/examples).\n\n## Launching script\n\n\ud83e\udd17 Accelerate also provides an optional CLI tool that allows you to quickly configure and test your training environment before launching the scripts. No need to remember how to use `torch.distributed.run` or to write a specific launcher for TPU training!\nOn your machine(s) just run:\n\n```bash\naccelerate config\n```\n\nand answer the questions asked. This will generate a config file that will be used automatically to properly set the default options when doing\n\n```bash\naccelerate launch my_script.py --args_to_my_script\n``` \n\nFor instance, here is how you would run the GLUE example on the MRPC task (from the root of the repo):\n\n```bash\naccelerate launch examples/nlp_example.py\n```\n\nThis CLI tool is **optional**, and you can still use `python my_script.py` or `python -m torchrun my_script.py` at your convenience.\n\nYou can also directly pass in the arguments you would to `torchrun` as arguments to `accelerate launch` if you wish to not run` accelerate config`.\n\nFor example, here is how to launch on two GPUs:\n\n```bash\naccelerate launch --multi_gpu --num_processes 2 examples/nlp_example.py\n```\n\nTo learn more, check the CLI documentation available [here](https://huggingface.co/docs/accelerate/package_reference/cli).\n\n## Launching multi-CPU run using MPI\n\n\ud83e\udd17 Here is another way to launch multi-CPU run using MPI. You can learn how to install Open MPI on [this page](https://www.open-mpi.org/faq/?category=building#easy-build). You can use Intel MPI or MVAPICH as well.\nOnce you have MPI setup on your cluster, just run:\n\n```bash\nmpirun -np 2 python examples/nlp_example.py\n```\n\n## Launching training using DeepSpeed\n\n\ud83e\udd17 Accelerate supports training on single/multiple GPUs using DeepSpeed. To use it, you don't need to change anything in your training code; you can set everything using just `accelerate config`. However, if you desire to tweak your DeepSpeed related args from your Python script, we provide you the `DeepSpeedPlugin`.\n\n```python\nfrom accelerate import Accelerator, DeepSpeedPlugin\n\n# deepspeed needs to know your gradient accumulation steps beforehand, so don't forget to pass it\n# Remember you still need to do gradient accumulation by yourself, just like you would have done without deepspeed\ndeepspeed_plugin = DeepSpeedPlugin(zero_stage=2, gradient_accumulation_steps=2)\naccelerator = Accelerator(mixed_precision='fp16', deepspeed_plugin=deepspeed_plugin)\n\n# How to save your \ud83e\udd17 Transformer?\naccelerator.wait_for_everyone()\nunwrapped_model = accelerator.unwrap_model(model)\nunwrapped_model.save_pretrained(save_dir, save_function=accelerator.save, state_dict=accelerator.get_state_dict(model))\n```\n\nNote: DeepSpeed support is experimental for now. In case you get into some problem, please open an issue.\n\n## Launching your training from a notebook\n\n\ud83e\udd17 Accelerate also provides a `notebook_launcher` function you can use in a notebook to launch a distributed training. This is especially useful for Colab or Kaggle notebooks with a TPU backend. Just define your training loop in a `training_function` then in your last cell, add:\n\n```python\nfrom accelerate import notebook_launcher\n\nnotebook_launcher(training_function)\n```\n\nAn example can be found in [this notebook](https://github.com/huggingface/notebooks/blob/main/examples/accelerate_examples/simple_nlp_example.ipynb). [![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/accelerate_examples/simple_nlp_example.ipynb)\n\n## Why should I use \ud83e\udd17 Accelerate?\n\nYou should use \ud83e\udd17 Accelerate when you want to easily run your training scripts in a distributed environment without having to renounce full control over your training loop. This is not a high-level framework above PyTorch, just a thin wrapper so you don't have to learn a new library. In fact, the whole API of \ud83e\udd17 Accelerate is in one class, the `Accelerator` object.\n\n## Why shouldn't I use \ud83e\udd17 Accelerate?\n\nYou shouldn't use \ud83e\udd17 Accelerate if you don't want to write a training loop yourself. There are plenty of high-level libraries above PyTorch that will offer you that, \ud83e\udd17 Accelerate is not one of them.\n\n## Frameworks using \ud83e\udd17 Accelerate\n\nIf you like the simplicity of \ud83e\udd17 Accelerate but would prefer a higher-level abstraction around its capabilities, some frameworks and libraries that are built on top of \ud83e\udd17 Accelerate are listed below:\n\n* [Animus](https://github.com/Scitator/animus) is a minimalistic framework to run machine learning experiments. Animus highlights common \"breakpoints\" in ML experiments and provides a unified interface for them within [IExperiment](https://github.com/Scitator/animus/blob/main/animus/core.py#L76).\n* [Catalyst](https://github.com/catalyst-team/catalyst#getting-started) is a PyTorch framework for Deep Learning Research and Development. It focuses on reproducibility, rapid experimentation, and codebase reuse so you can create something new rather than write yet another train loop. Catalyst provides a [Runner](https://catalyst-team.github.io/catalyst/api/core.html#runner) to connect all parts of the experiment: hardware backend, data transformations, model training, and inference logic.\n* [fastai](https://github.com/fastai/fastai#installing) is a PyTorch framework for Deep Learning that simplifies training fast and accurate neural nets using modern best practices. fastai provides a [Learner](https://docs.fast.ai/learner.html#Learner) to handle the training, fine-tuning, and inference of deep learning algorithms.\n* [Finetuner](https://github.com/jina-ai/finetuner) is a service that enables models to create higher-quality embeddings for semantic search, visual similarity search, cross-modal text<->image search, recommendation systems, clustering, duplication detection, anomaly detection, or other uses.\n* [InvokeAI](https://github.com/invoke-ai/InvokeAI) is a creative engine for Stable Diffusion models, offering industry-leading WebUI, terminal usage support, and serves as the foundation for many commercial products.\n* [Kornia](https://kornia.readthedocs.io/en/latest/get-started/introduction.html) is a differentiable library that allows classical computer vision to be integrated into deep learning models. Kornia provides a [Trainer](https://kornia.readthedocs.io/en/latest/x.html#kornia.x.Trainer) with the specific purpose to train and fine-tune the supported deep learning algorithms within the library.\n* [Open Assistant](https://projects.laion.ai/Open-Assistant/) is a chat-based assistant that understands tasks, can interact with their party systems, and retrieve information dynamically to do so. \n* [pytorch-accelerated](https://github.com/Chris-hughes10/pytorch-accelerated) is a lightweight training library, with a streamlined feature set centered around a general-purpose [Trainer](https://pytorch-accelerated.readthedocs.io/en/latest/trainer.html), that places a huge emphasis on simplicity and transparency; enabling users to understand exactly what is going on under the hood, but without having to write and maintain the boilerplate themselves!\n* [Stable Diffusion web UI](https://github.com/AUTOMATIC1111/stable-diffusion-webui) is an open-source browser-based easy-to-use interface based on the Gradio library for Stable Diffusion.\n* [torchkeras](https://github.com/lyhue1991/torchkeras) is a simple tool for training pytorch model just in a keras style, a dynamic and beautiful plot is provided in notebook to monitor your loss or metric.\n* [transformers](https://github.com/huggingface/transformers) as a tool for helping train state-of-the-art machine learning models in PyTorch, Tensorflow, and JAX. (Accelerate is the backend for the PyTorch side).\n\n\n## Installation\n\nThis repository is tested on Python 3.8+ and PyTorch 1.10.0+\n\nYou should install \ud83e\udd17 Accelerate in a [virtual environment](https://docs.python.org/3/library/venv.html). If you're unfamiliar with Python virtual environments, check out the [user guide](https://packaging.python.org/guides/installing-using-pip-and-virtual-environments/).\n\nFirst, create a virtual environment with the version of Python you're going to use and activate it.\n\nThen, you will need to install PyTorch: refer to the [official installation page](https://pytorch.org/get-started/locally/#start-locally) regarding the specific install command for your platform. Then \ud83e\udd17 Accelerate can be installed using pip as follows:\n\n```bash\npip install accelerate\n```\n\n## Supported integrations\n\n- CPU only\n- multi-CPU on one node (machine)\n- multi-CPU on several nodes (machines)\n- single GPU\n- multi-GPU on one node (machine)\n- multi-GPU on several nodes (machines)\n- TPU\n- FP16/BFloat16 mixed precision\n- FP8 mixed precision with [Transformer Engine](https://github.com/NVIDIA/TransformerEngine)\n- DeepSpeed support (Experimental)\n- PyTorch Fully Sharded Data Parallel (FSDP) support (Experimental)\n- Megatron-LM support (Experimental)\n\n## Citing \ud83e\udd17 Accelerate\n\nIf you use \ud83e\udd17 Accelerate in your publication, please cite it by using the following BibTeX entry.\n\n```bibtex\n@Misc{accelerate,\n  title =        {Accelerate: Training and inference at scale made simple, efficient and adaptable.},\n  author =       {Sylvain Gugger, Lysandre Debut, Thomas Wolf, Philipp Schmid, Zachary Mueller, Sourab Mangrulkar},\n  howpublished = {\\url{https://github.com/huggingface/accelerate}},\n  year =         {2022}\n}\n```\n", "                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"[]\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright [yyyy] [name of copyright owner]\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n", "# Copyright 2021 The HuggingFace Team. All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom setuptools import setup\nfrom setuptools import find_packages\n\nextras = {}\nextras[\"quality\"] = [\"black ~= 23.1\", \"ruff >= 0.0.241\", \"hf-doc-builder >= 0.3.0\", \"urllib3 < 2.0.0\"]\nextras[\"docs\"] = []\nextras[\"test_prod\"] = [\"pytest\", \"pytest-xdist\", \"pytest-subtests\", \"parameterized\"]\nextras[\"test_dev\"] = [\"datasets\", \"evaluate\", \"transformers\", \"scipy\", \"scikit-learn\", \"deepspeed\", \"tqdm\"]\nextras[\"testing\"] = extras[\"test_prod\"] + extras[\"test_dev\"]\nextras[\"rich\"] = [\"rich\"]\n\nextras[\"test_trackers\"] = [\"wandb\", \"comet-ml\", \"tensorboard\"]\nextras[\"dev\"] = extras[\"quality\"] + extras[\"testing\"] + extras[\"rich\"]\n\nextras[\"sagemaker\"] = [\n    \"sagemaker\",  # boto3 is a required package in sagemaker\n]\n\nsetup(\n    name=\"accelerate\",\n    version=\"0.22.0.dev0\",\n    description=\"Accelerate\",\n    long_description=open(\"README.md\", \"r\", encoding=\"utf-8\").read(),\n    long_description_content_type=\"text/markdown\",\n    keywords=\"deep learning\",\n    license=\"Apache\",\n    author=\"The HuggingFace team\",\n    author_email=\"sylvain@huggingface.co\",\n    url=\"https://github.com/huggingface/accelerate\",\n    package_dir={\"\": \"src\"},\n    packages=find_packages(\"src\"),\n    entry_points={\n        \"console_scripts\": [\n            \"accelerate=accelerate.commands.accelerate_cli:main\",\n            \"accelerate-config=accelerate.commands.config:main\",\n            \"accelerate-launch=accelerate.commands.launch:main\",\n        ]\n    },\n    python_requires=\">=3.8.0\",\n    install_requires=[\"numpy>=1.17\", \"packaging>=20.0\", \"psutil\", \"pyyaml\", \"torch>=1.10.0\"],\n    extras_require=extras,\n    classifiers=[\n        \"Development Status :: 5 - Production/Stable\",\n        \"Intended Audience :: Developers\",\n        \"Intended Audience :: Education\",\n        \"Intended Audience :: Science/Research\",\n        \"License :: OSI Approved :: Apache Software License\",\n        \"Operating System :: OS Independent\",\n        \"Programming Language :: Python :: 3\",\n        \"Programming Language :: Python :: 3.8\",\n        \"Topic :: Scientific/Engineering :: Artificial Intelligence\",\n    ],\n)\n\n# Release checklist\n# 1. Change the version in __init__.py and setup.py.\n# 2. Commit these changes with the message: \"Release: VERSION\"\n# 3. Add a tag in git to mark the release: \"git tag VERSION -m 'Adds tag VERSION for pypi' \"\n#    Push the tag to git: git push --tags origin main\n# 4. Run the following commands in the top-level directory:\n#      python setup.py bdist_wheel\n#      python setup.py sdist\n# 5. Upload the package to the pypi test server first:\n#      twine upload dist/* -r pypitest\n#      twine upload dist/* -r pypitest --repository-url=https://test.pypi.org/legacy/\n# 6. Check that you can install it in a virtualenv by running:\n#      pip install -i https://testpypi.python.org/pypi accelerate\n#      accelerate env\n#      accelerate test\n# 7. Upload the final version to actual pypi:\n#      twine upload dist/* -r pypi\n# 8. Add release notes to the tag in github once everything is looking hunky-dory.\n# 9. Update the version in __init__.py, setup.py to the new version \"-dev\" and push to master\n", "[tool.black]\nline-length = 119\ntarget-version = ['py37']\n\n[tool.ruff]\n# Never enforce `E501` (line length violations).\nignore = [\"E501\", \"E741\", \"W605\"]\nselect = [\"E\", \"F\", \"I\", \"W\"]\nline-length = 119\n\n# Ignore import violations in all `__init__.py` files.\n[tool.ruff.per-file-ignores]\n\"__init__.py\" = [\"E402\", \"F401\", \"F403\", \"F811\"]\n\n[tool.ruff.isort]\nlines-after-imports = 2\nknown-first-party = [\"accelerate\"]\n", "[isort]\ndefault_section = FIRSTPARTY\nensure_newline_before_comments = True\nforce_grid_wrap = 0\ninclude_trailing_comma = True\nknown_first_party = accelerate\nline_length = 119\nlines_after_imports = 2\nmulti_line_output = 3\nuse_parentheses = True\n\n[flake8]\nignore = E203, E722, E501, E741, W503, W605\nmax-line-length = 119\n", "\n# Contributor Covenant Code of Conduct\n\n## Our Pledge\n\nWe as members, contributors, and leaders pledge to make participation in our\ncommunity a harassment-free experience for everyone, regardless of age, body\nsize, visible or invisible disability, ethnicity, sex characteristics, gender\nidentity and expression, level of experience, education, socio-economic status,\nnationality, personal appearance, race, religion, or sexual identity\nand orientation.\n\nWe pledge to act and interact in ways that contribute to an open, welcoming,\ndiverse, inclusive, and healthy community.\n\n## Our Standards\n\nExamples of behavior that contributes to a positive environment for our\ncommunity include:\n\n* Demonstrating empathy and kindness toward other people\n* Being respectful of differing opinions, viewpoints, and experiences\n* Giving and gracefully accepting constructive feedback\n* Accepting responsibility and apologizing to those affected by our mistakes,\n  and learning from the experience\n* Focusing on what is best not just for us as individuals, but for the\n  overall community\n\nExamples of unacceptable behavior include:\n\n* The use of sexualized language or imagery, and sexual attention or\n  advances of any kind\n* Trolling, insulting or derogatory comments, and personal or political attacks\n* Public or private harassment\n* Publishing others' private information, such as a physical or email\n  address, without their explicit permission\n* Other conduct which could reasonably be considered inappropriate in a\n  professional setting\n\n## Enforcement Responsibilities\n\nCommunity leaders are responsible for clarifying and enforcing our standards of\nacceptable behavior and will take appropriate and fair corrective action in\nresponse to any behavior that they deem inappropriate, threatening, offensive,\nor harmful.\n\nCommunity leaders have the right and responsibility to remove, edit, or reject\ncomments, commits, code, wiki edits, issues, and other contributions that are\nnot aligned to this Code of Conduct, and will communicate reasons for moderation\ndecisions when appropriate.\n\n## Scope\n\nThis Code of Conduct applies within all community spaces, and also applies when\nan individual is officially representing the community in public spaces.\nExamples of representing our community include using an official e-mail address,\nposting via an official social media account, or acting as an appointed\nrepresentative at an online or offline event.\n\n## Enforcement\n\nInstances of abusive, harassing, or otherwise unacceptable behavior may be\nreported to the community leaders responsible for enforcement at\nfeedback@huggingface.co.\nAll complaints will be reviewed and investigated promptly and fairly.\n\nAll community leaders are obligated to respect the privacy and security of the\nreporter of any incident.\n\n## Enforcement Guidelines\n\nCommunity leaders will follow these Community Impact Guidelines in determining\nthe consequences for any action they deem in violation of this Code of Conduct:\n\n### 1. Correction\n\n**Community Impact**: Use of inappropriate language or other behavior deemed\nunprofessional or unwelcome in the community.\n\n**Consequence**: A private, written warning from community leaders, providing\nclarity around the nature of the violation and an explanation of why the\nbehavior was inappropriate. A public apology may be requested.\n\n### 2. Warning\n\n**Community Impact**: A violation through a single incident or series\nof actions.\n\n**Consequence**: A warning with consequences for continued behavior. No\ninteraction with the people involved, including unsolicited interaction with\nthose enforcing the Code of Conduct, for a specified period of time. This\nincludes avoiding interactions in community spaces as well as external channels\nlike social media. Violating these terms may lead to a temporary or\npermanent ban.\n\n### 3. Temporary Ban\n\n**Community Impact**: A serious violation of community standards, including\nsustained inappropriate behavior.\n\n**Consequence**: A temporary ban from any sort of interaction or public\ncommunication with the community for a specified period of time. No public or\nprivate interaction with the people involved, including unsolicited interaction\nwith those enforcing the Code of Conduct, is allowed during this period.\nViolating these terms may lead to a permanent ban.\n\n### 4. Permanent Ban\n\n**Community Impact**: Demonstrating a pattern of violation of community\nstandards, including sustained inappropriate behavior,  harassment of an\nindividual, or aggression toward or disparagement of classes of individuals.\n\n**Consequence**: A permanent ban from any sort of public interaction within\nthe community.\n\n## Attribution\n\nThis Code of Conduct is adapted from the [Contributor Covenant][homepage],\nversion 2.0, available at\nhttps://www.contributor-covenant.org/version/2/0/code_of_conduct.html.\n\nCommunity Impact Guidelines were inspired by [Mozilla's code of conduct\nenforcement ladder](https://github.com/mozilla/diversity).\n\n[homepage]: https://www.contributor-covenant.org\n\nFor answers to common questions about this code of conduct, see the FAQ at\nhttps://www.contributor-covenant.org/faq. Translations are available at\nhttps://www.contributor-covenant.org/translations.\n", "<!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# How to contribute to \ud83e\udd17 Accelerate?\n\nEveryone is welcome to contribute, and we value everybody's contribution. Code\nis thus not the only way to help the community. Answering questions, helping\nothers, reaching out and improving the documentations are immensely valuable to\nthe community.\n\nIt also helps us if you spread the word: reference the library from blog posts\non the awesome projects it made possible, shout out on Twitter every time it has\nhelped you, or simply star the repo to say \"thank you\".\n\nWhichever way you choose to contribute, please be mindful to respect our\n[code of conduct](https://github.com/huggingface/accelerate/blob/main/CODE_OF_CONDUCT.md).\n\n## You can contribute in so many ways!\n\nSome of the ways you can contribute to Accelerate:\n* Fixing outstanding issues with the existing code;\n* Contributing to the examples or to the documentation;\n* Submitting issues related to bugs or desired new features.\n\n## Submitting a new issue or feature request\n\nDo your best to follow these guidelines when submitting an issue or a feature\nrequest. It will make it easier for us to come back to you quickly and with good\nfeedback.\n\n### Did you find a bug?\n\nThe \ud83e\udd17 Accelerate library is robust and reliable thanks to the users who notify us of\nthe problems they encounter. So thank you for reporting an issue.\n\nFirst, we would really appreciate it if you could **make sure the bug was not\nalready reported** (use the search bar on Github under Issues).\n\nDid not find it? :( So we can act quickly on it, please follow these steps:\n\n* Include your **OS type and version**, the versions of **Python** and **PyTorch**.\n* A short, self-contained, code snippet that allows us to reproduce the bug in\n  less than 30s;\n* Provide the with your Accelerate configuration (located by default in `~/.cache/huggingface/accelerate/default_config.yaml`)\n\n### Do you want a new feature?\n\nA good feature request addresses the following points:\n\n1. Motivation first:\n* Is it related to a problem/frustration with the library? If so, please explain\n  why. Providing a code snippet that demonstrates the problem is best.\n* Is it related to something you would need for a project? We'd love to hear\n  about it!\n* Is it something you worked on and think could benefit the community?\n  Awesome! Tell us what problem it solved for you.\n2. Write a *full paragraph* describing the feature;\n3. Provide a **code snippet** that demonstrates its future use;\n4. In case this is related to a paper, please attach a link;\n5. Attach any additional information (drawings, screenshots, etc.) you think may help.\n\nIf your issue is well written we're already 80% of the way there by the time you\npost it.\n\n## Submitting a pull request (PR)\n\nBefore writing code, we strongly advise you to search through the existing PRs or\nissues to make sure that nobody is already working on the same thing. If you are\nunsure, it is always a good idea to open an issue to get some feedback.\n\nYou will need basic `git` proficiency to be able to contribute to\n\ud83e\udd17 Accelerate. `git` is not the easiest tool to use but it has the greatest\nmanual. Type `git --help` in a shell and enjoy. If you prefer books, [Pro\nGit](https://git-scm.com/book/en/v2) is a very good reference.\n\nFollow these steps to start contributing:\n\n1. Fork the [repository](https://github.com/huggingface/accelerate) by\n   clicking on the 'Fork' button on the repository's page. This creates a copy of the code\n   under your GitHub user account.\n\n2. Clone your fork to your local disk, and add the base repository as a remote. The following command\n   assumes you have your public SSH key uploaded to GitHub. See the following guide for more\n   [information](https://docs.github.com/en/repositories/creating-and-managing-repositories/cloning-a-repository).\n\n   ```bash\n   $ git clone git@github.com:<your Github handle>/accelerate.git\n   $ cd accelerate\n   $ git remote add upstream https://github.com/huggingface/accelerate.git\n   ```\n\n3. Create a new branch to hold your development changes, and do this for every new PR you work on.\n\n   Start by synchronizing your `main` branch with the `upstream/main` branch (ore details in the [GitHub Docs](https://docs.github.com/en/github/collaborating-with-issues-and-pull-requests/syncing-a-fork)):\n\n   ```bash\n   $ git checkout main\n   $ git fetch upstream\n   $ git merge upstream/main\n   ```\n\n   Once your `main` branch is synchronized, create a new branch from it:\n\n   ```bash\n   $ git checkout -b a-descriptive-name-for-my-changes\n   ```\n\n   **Do not** work on the `main` branch.\n\n4. Set up a development environment by running the following command in a conda or a virtual environment you've created for working on this library:\n\n   ```bash\n   $ pip install -e \".[quality]\"\n   ```\n\n   (If accelerate was already installed in the virtual environment, remove\n   it with `pip uninstall accelerate` before reinstalling it in editable\n   mode with the `-e` flag.)\n\n   Alternatively, if you are using [Visual Studio Code](https://code.visualstudio.com/Download), the fastest way to get set up is by using\n   the provided Dev Container. Documentation on how to get started with dev containers is available [here](https://code.visualstudio.com/docs/remote/containers).\n\n5. Develop the features on your branch.\n\n   As you work on the features, you should make sure that the test suite\n   passes. You should run the tests impacted by your changes like this (see \n   below an explanation regarding the environment variable):\n\n   ```bash\n   $ pytest tests/<TEST_TO_RUN>.py\n   ```\n   \n   > For the following commands leveraging the `make` utility, we recommend using the WSL system when running on\n   > Windows. More information [here](https://docs.microsoft.com/en-us/windows/wsl/about).\n\n   You can also run the full suite with the following command.\n\n   ```bash\n   $ make test\n   ```\n\n   `accelerate` relies on `black` and `ruff` to format its source code\n   consistently. After you make changes, apply automatic style corrections and code verifications\n   that can't be automated in one go with:\n\n   This target is also optimized to only work with files modified by the PR you're working on.\n\n   If you prefer to run the checks one after the other, the following command apply the\n   style corrections:\n\n   ```bash\n   $ make style\n   ```\n\n   `accelerate` also uses a few custom scripts to check for coding mistakes. Quality\n   control runs in CI, however you can also run the same checks with:\n\n   ```bash\n   $ make quality\n   ```\n\n   Once you're happy with your changes, add changed files using `git add` and\n   make a commit with `git commit` to record your changes locally:\n\n   ```bash\n   $ git add modified_file.py\n   $ git commit\n   ```\n\n   Please write [good commit messages](https://chris.beams.io/posts/git-commit/).\n\n   It is a good idea to sync your copy of the code with the original\n   repository regularly. This way you can quickly account for changes:\n\n   ```bash\n   $ git fetch upstream\n   $ git rebase upstream/main\n   ```\n\n   Push the changes to your account using:\n\n   ```bash\n   $ git push -u origin a-descriptive-name-for-my-changes\n   ```\n\n6. Once you are satisfied (**and the checklist below is happy too**), go to the\n   webpage of your fork on GitHub. Click on 'Pull request' to send your changes\n   to the project maintainers for review.\n\n7. It's ok if maintainers ask you for changes. It happens to core contributors\n   too! So everyone can see the changes in the Pull request, work in your local\n   branch and push the changes to your fork. They will automatically appear in\n   the pull request.\n\n\n### Checklist\n\n1. The title of your pull request should be a summary of its contribution;\n2. If your pull request addresses an issue, please mention the issue number in\n   the pull request description to make sure they are linked (and people\n   consulting the issue know you are working on it);\n3. To indicate a work in progress please prefix the title with `[WIP]`, or mark\n   the PR as a draft PR. These are useful to avoid duplicated work, and to differentiate\n   it from PRs ready to be merged;\n4. Make sure existing tests pass;\n5. Add high-coverage tests. No quality testing = no merge.\n\nSee an example of a good PR here: https://github.com/huggingface/accelerate/pull/255\n\n### Tests\n\nAn extensive test suite is included to test the library behavior and several examples. Library tests can be found in\nthe [tests folder](https://github.com/huggingface/accelerate/tree/main/tests).\n\nWe use `pytest` in order to run the tests. From the root of the\nrepository, here's how to run tests with `pytest` for the library:\n\n```bash\n$ python -m pytest -sv ./tests\n```\n\nIn fact, that's how `make test` is implemented (sans the `pip install` line)!\n\nYou can specify a smaller set of tests in order to test only the feature\nyou're working on.", ".PHONY: quality style test docs utils\n\ncheck_dirs := tests src examples benchmarks utils\n\n# Check that source code meets quality standards\n\nextra_quality_checks:\n\tpython utils/check_copies.py\n\tpython utils/check_dummies.py\n\tpython utils/check_repo.py\n\tdoc-builder style src/accelerate docs/source --max_len 119\n\n# this target runs checks on all files\nquality:\n\tblack --required-version 23 --check $(check_dirs)\n\truff $(check_dirs)\n\tdoc-builder style src/accelerate docs/source --max_len 119 --check_only\n\n# Format source code automatically and check is there are any problems left that need manual fixing\nstyle:\n\tblack --required-version 23 $(check_dirs)\n\truff $(check_dirs) --fix\n\tdoc-builder style src/accelerate docs/source --max_len 119\n\t\n# Run tests for the library\ntest:\n\tpython -m pytest -s -v ./tests/ --ignore=./tests/test_examples.py $(if $(IS_GITHUB_CI),--report-log \"$(PYTORCH_VERSION)_all.log\",)\n\ntest_big_modeling:\n\tpython -m pytest -s -v ./tests/test_big_modeling.py ./tests/test_modeling_utils.py $(if $(IS_GITHUB_CI),--report-log \"$(PYTORCH_VERSION)_big_modeling.log\",)\n\ntest_core:\n\tpython -m pytest -s -v ./tests/ --ignore=./tests/test_examples.py --ignore=./tests/deepspeed --ignore=./tests/test_big_modeling.py \\\n\t--ignore=./tests/fsdp --ignore=./tests/test_cli.py $(if $(IS_GITHUB_CI),--report-log \"$(PYTORCH_VERSION)_core.log\",)\n\ntest_cli:\n\tpython -m pytest -s -v ./tests/test_cli.py $(if $(IS_GITHUB_CI),--report-log \"$(PYTORCH_VERSION)_cli.log\",)\n\ntest_deepspeed:\n\tpython -m pytest -s -v ./tests/deepspeed $(if $(IS_GITHUB_CI),--report-log \"$(PYTORCH_VERSION)_deepspeed.log\",)\n\ntest_fsdp:\n\tpython -m pytest -s -v ./tests/fsdp $(if $(IS_GITHUB_CI),--report-log \"$(PYTORCH_VERSION)_fsdp.log\",)\n\ntest_examples:\n\tpython -m pytest -s -v ./tests/test_examples.py $(if $(IS_GITHUB_CI),--report-log \"$(PYTORCH_VERSION)_examples.log\",)\n\n# Broken down example tests for the CI runners\ntest_integrations:\n\tpython -m pytest -s -v ./tests/deepspeed ./tests/fsdp $(if $(IS_GITHUB_CI),--report-log \"$(PYTORCH_VERSION)_integrations.log\",)\n\ntest_example_differences:\n\tpython -m pytest -s -v ./tests/test_examples.py::ExampleDifferenceTests $(if $(IS_GITHUB_CI),--report-log \"$(PYTORCH_VERSION)_example_diff.log\",)\n\ntest_checkpoint_epoch:\n\tpython -m pytest -s -v ./tests/test_examples.py::FeatureExamplesTests -k \"by_epoch\" $(if $(IS_GITHUB_CI),--report-log \"$(PYTORCH_VERSION)_checkpoint_epoch.log\",)\n\ntest_checkpoint_step:\n\tpython -m pytest -s -v ./tests/test_examples.py::FeatureExamplesTests -k \"by_step\" $(if $(IS_GITHUB_CI),--report-log \"$(PYTORCH_VERSION)_checkpoint_step.log\",)\n\n# Same as test but used to install only the base dependencies\ntest_prod:\n\t$(MAKE) test_core\n\ntest_rest:\n\tpython -m pytest -s -v ./tests/test_examples.py::FeatureExamplesTests -k \"not by_step and not by_epoch\" $(if $(IS_GITHUB_CI),--report-log \"$(PYTORCH_VERSION)_rest.log\",)\n", "accelerate # used to be installed in Amazon SageMaker environment\nevaluate\ndatasets==2.3.2", "<!---\nCopyright 2021 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n<p align=\"center\">\n    <br>\n    <img src=\"https://raw.githubusercontent.com/huggingface/accelerate/main/docs/source/imgs/accelerate_logo.png\" width=\"400\"/>\n    <br>\n<p>\n\n<p align=\"center\">\n    <!-- Uncomment when CircleCI is set up\n    <a href=\"https://circleci.com/gh/huggingface/accelerate\">\n        <img alt=\"Build\" src=\"https://img.shields.io/circleci/build/github/huggingface/transformers/master\">\n    </a>\n    -->\n    <a href=\"https://github.com/huggingface/accelerate/blob/main/LICENSE\">\n        <img alt=\"License\" src=\"https://img.shields.io/github/license/huggingface/accelerate.svg?color=blue\">\n    </a>\n    <a href=\"https://huggingface.co/docs/accelerate/index.html\">\n        <img alt=\"Documentation\" src=\"https://img.shields.io/website/http/huggingface.co/docs/accelerate/index.html.svg?down_color=red&down_message=offline&up_message=online\">\n    </a>\n    <a href=\"https://github.com/huggingface/accelerate/releases\">\n        <img alt=\"GitHub release\" src=\"https://img.shields.io/github/release/huggingface/accelerate.svg\">\n    </a>\n    <a href=\"https://github.com/huggingface/accelerate/blob/main/CODE_OF_CONDUCT.md\">\n        <img alt=\"Contributor Covenant\" src=\"https://img.shields.io/badge/Contributor%20Covenant-v2.0%20adopted-ff69b4.svg\">\n    </a>\n</p>\n\n<h3 align=\"center\">\n<p>Run your *raw* PyTorch training script on any kind of device\n</h3>\n\n<h3 align=\"center\">\n    <a href=\"https://hf.co/course\"><img src=\"https://raw.githubusercontent.com/huggingface/accelerate/main/docs/source/imgs/course_banner.png\"></a>\n</h3>\n\n## Easy to integrate\n\n\ud83e\udd17 Accelerate was created for PyTorch users who like to write the training loop of PyTorch models but are reluctant to write and maintain the boilerplate code needed to use multi-GPUs/TPU/fp16.\n\n\ud83e\udd17 Accelerate abstracts exactly and only the boilerplate code related to multi-GPUs/TPU/fp16 and leaves the rest of your code unchanged.\n\nHere is an example:\n\n```diff\n  import torch\n  import torch.nn.functional as F\n  from datasets import load_dataset\n+ from accelerate import Accelerator\n\n+ accelerator = Accelerator()\n- device = 'cpu'\n+ device = accelerator.device\n\n  model = torch.nn.Transformer().to(device)\n  optimizer = torch.optim.Adam(model.parameters())\n\n  dataset = load_dataset('my_dataset')\n  data = torch.utils.data.DataLoader(dataset, shuffle=True)\n\n+ model, optimizer, data = accelerator.prepare(model, optimizer, data)\n\n  model.train()\n  for epoch in range(10):\n      for source, targets in data:\n          source = source.to(device)\n          targets = targets.to(device)\n\n          optimizer.zero_grad()\n\n          output = model(source)\n          loss = F.cross_entropy(output, targets)\n\n-         loss.backward()\n+         accelerator.backward(loss)\n\n          optimizer.step()\n```\n\nAs you can see in this example, by adding 5-lines to any standard PyTorch training script you can now run on any kind of single or distributed node setting (single CPU, single GPU, multi-GPUs and TPUs) as well as with or without mixed precision (fp8, fp16, bf16).\n\nIn particular, the same code can then be run without modification on your local machine for debugging or your training environment.\n\n\ud83e\udd17 Accelerate even handles the device placement for you (which requires a few more changes to your code, but is safer in general), so you can even simplify your training loop further:\n\n```diff\n  import torch\n  import torch.nn.functional as F\n  from datasets import load_dataset\n+ from accelerate import Accelerator\n\n- device = 'cpu'\n+ accelerator = Accelerator()\n\n- model = torch.nn.Transformer().to(device)\n+ model = torch.nn.Transformer()\n  optimizer = torch.optim.Adam(model.parameters())\n\n  dataset = load_dataset('my_dataset')\n  data = torch.utils.data.DataLoader(dataset, shuffle=True)\n\n+ model, optimizer, data = accelerator.prepare(model, optimizer, data)\n\n  model.train()\n  for epoch in range(10):\n      for source, targets in data:\n-         source = source.to(device)\n-         targets = targets.to(device)\n\n          optimizer.zero_grad()\n\n          output = model(source)\n          loss = F.cross_entropy(output, targets)\n\n-         loss.backward()\n+         accelerator.backward(loss)\n\n          optimizer.step()\n```\n\nWant to learn more? Check out the [documentation](https://huggingface.co/docs/accelerate) or have a look at our [examples](https://github.com/huggingface/accelerate/tree/main/examples).\n\n## Launching script\n\n\ud83e\udd17 Accelerate also provides an optional CLI tool that allows you to quickly configure and test your training environment before launching the scripts. No need to remember how to use `torch.distributed.run` or to write a specific launcher for TPU training!\nOn your machine(s) just run:\n\n```bash\naccelerate config\n```\n\nand answer the questions asked. This will generate a config file that will be used automatically to properly set the default options when doing\n\n```bash\naccelerate launch my_script.py --args_to_my_script\n``` \n\nFor instance, here is how you would run the GLUE example on the MRPC task (from the root of the repo):\n\n```bash\naccelerate launch examples/nlp_example.py\n```\n\nThis CLI tool is **optional**, and you can still use `python my_script.py` or `python -m torchrun my_script.py` at your convenience.\n\nYou can also directly pass in the arguments you would to `torchrun` as arguments to `accelerate launch` if you wish to not run` accelerate config`.\n\nFor example, here is how to launch on two GPUs:\n\n```bash\naccelerate launch --multi_gpu --num_processes 2 examples/nlp_example.py\n```\n\nTo learn more, check the CLI documentation available [here](https://huggingface.co/docs/accelerate/package_reference/cli).\n\n## Launching multi-CPU run using MPI\n\n\ud83e\udd17 Here is another way to launch multi-CPU run using MPI. You can learn how to install Open MPI on [this page](https://www.open-mpi.org/faq/?category=building#easy-build). You can use Intel MPI or MVAPICH as well.\nOnce you have MPI setup on your cluster, just run:\n\n```bash\nmpirun -np 2 python examples/nlp_example.py\n```\n\n## Launching training using DeepSpeed\n\n\ud83e\udd17 Accelerate supports training on single/multiple GPUs using DeepSpeed. To use it, you don't need to change anything in your training code; you can set everything using just `accelerate config`. However, if you desire to tweak your DeepSpeed related args from your Python script, we provide you the `DeepSpeedPlugin`.\n\n```python\nfrom accelerate import Accelerator, DeepSpeedPlugin\n\n# deepspeed needs to know your gradient accumulation steps beforehand, so don't forget to pass it\n# Remember you still need to do gradient accumulation by yourself, just like you would have done without deepspeed\ndeepspeed_plugin = DeepSpeedPlugin(zero_stage=2, gradient_accumulation_steps=2)\naccelerator = Accelerator(mixed_precision='fp16', deepspeed_plugin=deepspeed_plugin)\n\n# How to save your \ud83e\udd17 Transformer?\naccelerator.wait_for_everyone()\nunwrapped_model = accelerator.unwrap_model(model)\nunwrapped_model.save_pretrained(save_dir, save_function=accelerator.save, state_dict=accelerator.get_state_dict(model))\n```\n\nNote: DeepSpeed support is experimental for now. In case you get into some problem, please open an issue.\n\n## Launching your training from a notebook\n\n\ud83e\udd17 Accelerate also provides a `notebook_launcher` function you can use in a notebook to launch a distributed training. This is especially useful for Colab or Kaggle notebooks with a TPU backend. Just define your training loop in a `training_function` then in your last cell, add:\n\n```python\nfrom accelerate import notebook_launcher\n\nnotebook_launcher(training_function)\n```\n\nAn example can be found in [this notebook](https://github.com/huggingface/notebooks/blob/main/examples/accelerate_examples/simple_nlp_example.ipynb). [![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/huggingface/notebooks/blob/main/examples/accelerate_examples/simple_nlp_example.ipynb)\n\n## Why should I use \ud83e\udd17 Accelerate?\n\nYou should use \ud83e\udd17 Accelerate when you want to easily run your training scripts in a distributed environment without having to renounce full control over your training loop. This is not a high-level framework above PyTorch, just a thin wrapper so you don't have to learn a new library. In fact, the whole API of \ud83e\udd17 Accelerate is in one class, the `Accelerator` object.\n\n## Why shouldn't I use \ud83e\udd17 Accelerate?\n\nYou shouldn't use \ud83e\udd17 Accelerate if you don't want to write a training loop yourself. There are plenty of high-level libraries above PyTorch that will offer you that, \ud83e\udd17 Accelerate is not one of them.\n\n## Frameworks using \ud83e\udd17 Accelerate\n\nIf you like the simplicity of \ud83e\udd17 Accelerate but would prefer a higher-level abstraction around its capabilities, some frameworks and libraries that are built on top of \ud83e\udd17 Accelerate are listed below:\n\n* [Animus](https://github.com/Scitator/animus) is a minimalistic framework to run machine learning experiments. Animus highlights common \"breakpoints\" in ML experiments and provides a unified interface for them within [IExperiment](https://github.com/Scitator/animus/blob/main/animus/core.py#L76).\n* [Catalyst](https://github.com/catalyst-team/catalyst#getting-started) is a PyTorch framework for Deep Learning Research and Development. It focuses on reproducibility, rapid experimentation, and codebase reuse so you can create something new rather than write yet another train loop. Catalyst provides a [Runner](https://catalyst-team.github.io/catalyst/api/core.html#runner) to connect all parts of the experiment: hardware backend, data transformations, model training, and inference logic.\n* [fastai](https://github.com/fastai/fastai#installing) is a PyTorch framework for Deep Learning that simplifies training fast and accurate neural nets using modern best practices. fastai provides a [Learner](https://docs.fast.ai/learner.html#Learner) to handle the training, fine-tuning, and inference of deep learning algorithms.\n* [Finetuner](https://github.com/jina-ai/finetuner) is a service that enables models to create higher-quality embeddings for semantic search, visual similarity search, cross-modal text<->image search, recommendation systems, clustering, duplication detection, anomaly detection, or other uses.\n* [InvokeAI](https://github.com/invoke-ai/InvokeAI) is a creative engine for Stable Diffusion models, offering industry-leading WebUI, terminal usage support, and serves as the foundation for many commercial products.\n* [Kornia](https://kornia.readthedocs.io/en/latest/get-started/introduction.html) is a differentiable library that allows classical computer vision to be integrated into deep learning models. Kornia provides a [Trainer](https://kornia.readthedocs.io/en/latest/x.html#kornia.x.Trainer) with the specific purpose to train and fine-tune the supported deep learning algorithms within the library.\n* [Open Assistant](https://projects.laion.ai/Open-Assistant/) is a chat-based assistant that understands tasks, can interact with their party systems, and retrieve information dynamically to do so. \n* [pytorch-accelerated](https://github.com/Chris-hughes10/pytorch-accelerated) is a lightweight training library, with a streamlined feature set centered around a general-purpose [Trainer](https://pytorch-accelerated.readthedocs.io/en/latest/trainer.html), that places a huge emphasis on simplicity and transparency; enabling users to understand exactly what is going on under the hood, but without having to write and maintain the boilerplate themselves!\n* [Stable Diffusion web UI](https://github.com/AUTOMATIC1111/stable-diffusion-webui) is an open-source browser-based easy-to-use interface based on the Gradio library for Stable Diffusion.\n* [torchkeras](https://github.com/lyhue1991/torchkeras) is a simple tool for training pytorch model just in a keras style, a dynamic and beautiful plot is provided in notebook to monitor your loss or metric.\n* [transformers](https://github.com/huggingface/transformers) as a tool for helping train state-of-the-art machine learning models in PyTorch, Tensorflow, and JAX. (Accelerate is the backend for the PyTorch side).\n\n\n## Installation\n\nThis repository is tested on Python 3.8+ and PyTorch 1.10.0+\n\nYou should install \ud83e\udd17 Accelerate in a [virtual environment](https://docs.python.org/3/library/venv.html). If you're unfamiliar with Python virtual environments, check out the [user guide](https://packaging.python.org/guides/installing-using-pip-and-virtual-environments/).\n\nFirst, create a virtual environment with the version of Python you're going to use and activate it.\n\nThen, you will need to install PyTorch: refer to the [official installation page](https://pytorch.org/get-started/locally/#start-locally) regarding the specific install command for your platform. Then \ud83e\udd17 Accelerate can be installed using pip as follows:\n\n```bash\npip install accelerate\n```\n\n## Supported integrations\n\n- CPU only\n- multi-CPU on one node (machine)\n- multi-CPU on several nodes (machines)\n- single GPU\n- multi-GPU on one node (machine)\n- multi-GPU on several nodes (machines)\n- TPU\n- FP16/BFloat16 mixed precision\n- FP8 mixed precision with [Transformer Engine](https://github.com/NVIDIA/TransformerEngine)\n- DeepSpeed support (Experimental)\n- PyTorch Fully Sharded Data Parallel (FSDP) support (Experimental)\n- Megatron-LM support (Experimental)\n\n## Citing \ud83e\udd17 Accelerate\n\nIf you use \ud83e\udd17 Accelerate in your publication, please cite it by using the following BibTeX entry.\n\n```bibtex\n@Misc{accelerate,\n  title =        {Accelerate: Training and inference at scale made simple, efficient and adaptable.},\n  author =       {Sylvain Gugger, Lysandre Debut, Thomas Wolf, Philipp Schmid, Zachary Mueller, Sourab Mangrulkar},\n  howpublished = {\\url{https://github.com/huggingface/accelerate}},\n  year =         {2022}\n}\n```\n", "                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"[]\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright [yyyy] [name of copyright owner]\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n", "# Copyright 2021 The HuggingFace Team. All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nfrom setuptools import setup\nfrom setuptools import find_packages\n\nextras = {}\nextras[\"quality\"] = [\"black ~= 23.1\", \"ruff >= 0.0.241\", \"hf-doc-builder >= 0.3.0\", \"urllib3 < 2.0.0\"]\nextras[\"docs\"] = []\nextras[\"test_prod\"] = [\"pytest\", \"pytest-xdist\", \"pytest-subtests\", \"parameterized\"]\nextras[\"test_dev\"] = [\"datasets\", \"evaluate\", \"transformers\", \"scipy\", \"scikit-learn\", \"deepspeed\", \"tqdm\"]\nextras[\"testing\"] = extras[\"test_prod\"] + extras[\"test_dev\"]\nextras[\"rich\"] = [\"rich\"]\n\nextras[\"test_trackers\"] = [\"wandb\", \"comet-ml\", \"tensorboard\"]\nextras[\"dev\"] = extras[\"quality\"] + extras[\"testing\"] + extras[\"rich\"]\n\nextras[\"sagemaker\"] = [\n    \"sagemaker\",  # boto3 is a required package in sagemaker\n]\n\nsetup(\n    name=\"accelerate\",\n    version=\"0.22.0.dev0\",\n    description=\"Accelerate\",\n    long_description=open(\"README.md\", \"r\", encoding=\"utf-8\").read(),\n    long_description_content_type=\"text/markdown\",\n    keywords=\"deep learning\",\n    license=\"Apache\",\n    author=\"The HuggingFace team\",\n    author_email=\"sylvain@huggingface.co\",\n    url=\"https://github.com/huggingface/accelerate\",\n    package_dir={\"\": \"src\"},\n    packages=find_packages(\"src\"),\n    entry_points={\n        \"console_scripts\": [\n            \"accelerate=accelerate.commands.accelerate_cli:main\",\n            \"accelerate-config=accelerate.commands.config:main\",\n            \"accelerate-launch=accelerate.commands.launch:main\",\n        ]\n    },\n    python_requires=\">=3.8.0\",\n    install_requires=[\"numpy>=1.17\", \"packaging>=20.0\", \"psutil\", \"pyyaml\", \"torch>=1.10.0\"],\n    extras_require=extras,\n    classifiers=[\n        \"Development Status :: 5 - Production/Stable\",\n        \"Intended Audience :: Developers\",\n        \"Intended Audience :: Education\",\n        \"Intended Audience :: Science/Research\",\n        \"License :: OSI Approved :: Apache Software License\",\n        \"Operating System :: OS Independent\",\n        \"Programming Language :: Python :: 3\",\n        \"Programming Language :: Python :: 3.8\",\n        \"Topic :: Scientific/Engineering :: Artificial Intelligence\",\n    ],\n)\n\n# Release checklist\n# 1. Change the version in __init__.py and setup.py.\n# 2. Commit these changes with the message: \"Release: VERSION\"\n# 3. Add a tag in git to mark the release: \"git tag VERSION -m 'Adds tag VERSION for pypi' \"\n#    Push the tag to git: git push --tags origin main\n# 4. Run the following commands in the top-level directory:\n#      python setup.py bdist_wheel\n#      python setup.py sdist\n# 5. Upload the package to the pypi test server first:\n#      twine upload dist/* -r pypitest\n#      twine upload dist/* -r pypitest --repository-url=https://test.pypi.org/legacy/\n# 6. Check that you can install it in a virtualenv by running:\n#      pip install -i https://testpypi.python.org/pypi accelerate\n#      accelerate env\n#      accelerate test\n# 7. Upload the final version to actual pypi:\n#      twine upload dist/* -r pypi\n# 8. Add release notes to the tag in github once everything is looking hunky-dory.\n# 9. Update the version in __init__.py, setup.py to the new version \"-dev\" and push to master\n", "[tool.black]\nline-length = 119\ntarget-version = ['py37']\n\n[tool.ruff]\n# Never enforce `E501` (line length violations).\nignore = [\"E501\", \"E741\", \"W605\"]\nselect = [\"E\", \"F\", \"I\", \"W\"]\nline-length = 119\n\n# Ignore import violations in all `__init__.py` files.\n[tool.ruff.per-file-ignores]\n\"__init__.py\" = [\"E402\", \"F401\", \"F403\", \"F811\"]\n\n[tool.ruff.isort]\nlines-after-imports = 2\nknown-first-party = [\"accelerate\"]\n", "[isort]\ndefault_section = FIRSTPARTY\nensure_newline_before_comments = True\nforce_grid_wrap = 0\ninclude_trailing_comma = True\nknown_first_party = accelerate\nline_length = 119\nlines_after_imports = 2\nmulti_line_output = 3\nuse_parentheses = True\n\n[flake8]\nignore = E203, E722, E501, E741, W503, W605\nmax-line-length = 119\n", "\n# Contributor Covenant Code of Conduct\n\n## Our Pledge\n\nWe as members, contributors, and leaders pledge to make participation in our\ncommunity a harassment-free experience for everyone, regardless of age, body\nsize, visible or invisible disability, ethnicity, sex characteristics, gender\nidentity and expression, level of experience, education, socio-economic status,\nnationality, personal appearance, race, religion, or sexual identity\nand orientation.\n\nWe pledge to act and interact in ways that contribute to an open, welcoming,\ndiverse, inclusive, and healthy community.\n\n## Our Standards\n\nExamples of behavior that contributes to a positive environment for our\ncommunity include:\n\n* Demonstrating empathy and kindness toward other people\n* Being respectful of differing opinions, viewpoints, and experiences\n* Giving and gracefully accepting constructive feedback\n* Accepting responsibility and apologizing to those affected by our mistakes,\n  and learning from the experience\n* Focusing on what is best not just for us as individuals, but for the\n  overall community\n\nExamples of unacceptable behavior include:\n\n* The use of sexualized language or imagery, and sexual attention or\n  advances of any kind\n* Trolling, insulting or derogatory comments, and personal or political attacks\n* Public or private harassment\n* Publishing others' private information, such as a physical or email\n  address, without their explicit permission\n* Other conduct which could reasonably be considered inappropriate in a\n  professional setting\n\n## Enforcement Responsibilities\n\nCommunity leaders are responsible for clarifying and enforcing our standards of\nacceptable behavior and will take appropriate and fair corrective action in\nresponse to any behavior that they deem inappropriate, threatening, offensive,\nor harmful.\n\nCommunity leaders have the right and responsibility to remove, edit, or reject\ncomments, commits, code, wiki edits, issues, and other contributions that are\nnot aligned to this Code of Conduct, and will communicate reasons for moderation\ndecisions when appropriate.\n\n## Scope\n\nThis Code of Conduct applies within all community spaces, and also applies when\nan individual is officially representing the community in public spaces.\nExamples of representing our community include using an official e-mail address,\nposting via an official social media account, or acting as an appointed\nrepresentative at an online or offline event.\n\n## Enforcement\n\nInstances of abusive, harassing, or otherwise unacceptable behavior may be\nreported to the community leaders responsible for enforcement at\nfeedback@huggingface.co.\nAll complaints will be reviewed and investigated promptly and fairly.\n\nAll community leaders are obligated to respect the privacy and security of the\nreporter of any incident.\n\n## Enforcement Guidelines\n\nCommunity leaders will follow these Community Impact Guidelines in determining\nthe consequences for any action they deem in violation of this Code of Conduct:\n\n### 1. Correction\n\n**Community Impact**: Use of inappropriate language or other behavior deemed\nunprofessional or unwelcome in the community.\n\n**Consequence**: A private, written warning from community leaders, providing\nclarity around the nature of the violation and an explanation of why the\nbehavior was inappropriate. A public apology may be requested.\n\n### 2. Warning\n\n**Community Impact**: A violation through a single incident or series\nof actions.\n\n**Consequence**: A warning with consequences for continued behavior. No\ninteraction with the people involved, including unsolicited interaction with\nthose enforcing the Code of Conduct, for a specified period of time. This\nincludes avoiding interactions in community spaces as well as external channels\nlike social media. Violating these terms may lead to a temporary or\npermanent ban.\n\n### 3. Temporary Ban\n\n**Community Impact**: A serious violation of community standards, including\nsustained inappropriate behavior.\n\n**Consequence**: A temporary ban from any sort of interaction or public\ncommunication with the community for a specified period of time. No public or\nprivate interaction with the people involved, including unsolicited interaction\nwith those enforcing the Code of Conduct, is allowed during this period.\nViolating these terms may lead to a permanent ban.\n\n### 4. Permanent Ban\n\n**Community Impact**: Demonstrating a pattern of violation of community\nstandards, including sustained inappropriate behavior,  harassment of an\nindividual, or aggression toward or disparagement of classes of individuals.\n\n**Consequence**: A permanent ban from any sort of public interaction within\nthe community.\n\n## Attribution\n\nThis Code of Conduct is adapted from the [Contributor Covenant][homepage],\nversion 2.0, available at\nhttps://www.contributor-covenant.org/version/2/0/code_of_conduct.html.\n\nCommunity Impact Guidelines were inspired by [Mozilla's code of conduct\nenforcement ladder](https://github.com/mozilla/diversity).\n\n[homepage]: https://www.contributor-covenant.org\n\nFor answers to common questions about this code of conduct, see the FAQ at\nhttps://www.contributor-covenant.org/faq. Translations are available at\nhttps://www.contributor-covenant.org/translations.\n", "<!---\nCopyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# How to contribute to \ud83e\udd17 Accelerate?\n\nEveryone is welcome to contribute, and we value everybody's contribution. Code\nis thus not the only way to help the community. Answering questions, helping\nothers, reaching out and improving the documentations are immensely valuable to\nthe community.\n\nIt also helps us if you spread the word: reference the library from blog posts\non the awesome projects it made possible, shout out on Twitter every time it has\nhelped you, or simply star the repo to say \"thank you\".\n\nWhichever way you choose to contribute, please be mindful to respect our\n[code of conduct](https://github.com/huggingface/accelerate/blob/main/CODE_OF_CONDUCT.md).\n\n## You can contribute in so many ways!\n\nSome of the ways you can contribute to Accelerate:\n* Fixing outstanding issues with the existing code;\n* Contributing to the examples or to the documentation;\n* Submitting issues related to bugs or desired new features.\n\n## Submitting a new issue or feature request\n\nDo your best to follow these guidelines when submitting an issue or a feature\nrequest. It will make it easier for us to come back to you quickly and with good\nfeedback.\n\n### Did you find a bug?\n\nThe \ud83e\udd17 Accelerate library is robust and reliable thanks to the users who notify us of\nthe problems they encounter. So thank you for reporting an issue.\n\nFirst, we would really appreciate it if you could **make sure the bug was not\nalready reported** (use the search bar on Github under Issues).\n\nDid not find it? :( So we can act quickly on it, please follow these steps:\n\n* Include your **OS type and version**, the versions of **Python** and **PyTorch**.\n* A short, self-contained, code snippet that allows us to reproduce the bug in\n  less than 30s;\n* Provide the with your Accelerate configuration (located by default in `~/.cache/huggingface/accelerate/default_config.yaml`)\n\n### Do you want a new feature?\n\nA good feature request addresses the following points:\n\n1. Motivation first:\n* Is it related to a problem/frustration with the library? If so, please explain\n  why. Providing a code snippet that demonstrates the problem is best.\n* Is it related to something you would need for a project? We'd love to hear\n  about it!\n* Is it something you worked on and think could benefit the community?\n  Awesome! Tell us what problem it solved for you.\n2. Write a *full paragraph* describing the feature;\n3. Provide a **code snippet** that demonstrates its future use;\n4. In case this is related to a paper, please attach a link;\n5. Attach any additional information (drawings, screenshots, etc.) you think may help.\n\nIf your issue is well written we're already 80% of the way there by the time you\npost it.\n\n## Submitting a pull request (PR)\n\nBefore writing code, we strongly advise you to search through the existing PRs or\nissues to make sure that nobody is already working on the same thing. If you are\nunsure, it is always a good idea to open an issue to get some feedback.\n\nYou will need basic `git` proficiency to be able to contribute to\n\ud83e\udd17 Accelerate. `git` is not the easiest tool to use but it has the greatest\nmanual. Type `git --help` in a shell and enjoy. If you prefer books, [Pro\nGit](https://git-scm.com/book/en/v2) is a very good reference.\n\nFollow these steps to start contributing:\n\n1. Fork the [repository](https://github.com/huggingface/accelerate) by\n   clicking on the 'Fork' button on the repository's page. This creates a copy of the code\n   under your GitHub user account.\n\n2. Clone your fork to your local disk, and add the base repository as a remote. The following command\n   assumes you have your public SSH key uploaded to GitHub. See the following guide for more\n   [information](https://docs.github.com/en/repositories/creating-and-managing-repositories/cloning-a-repository).\n\n   ```bash\n   $ git clone git@github.com:<your Github handle>/accelerate.git\n   $ cd accelerate\n   $ git remote add upstream https://github.com/huggingface/accelerate.git\n   ```\n\n3. Create a new branch to hold your development changes, and do this for every new PR you work on.\n\n   Start by synchronizing your `main` branch with the `upstream/main` branch (ore details in the [GitHub Docs](https://docs.github.com/en/github/collaborating-with-issues-and-pull-requests/syncing-a-fork)):\n\n   ```bash\n   $ git checkout main\n   $ git fetch upstream\n   $ git merge upstream/main\n   ```\n\n   Once your `main` branch is synchronized, create a new branch from it:\n\n   ```bash\n   $ git checkout -b a-descriptive-name-for-my-changes\n   ```\n\n   **Do not** work on the `main` branch.\n\n4. Set up a development environment by running the following command in a conda or a virtual environment you've created for working on this library:\n\n   ```bash\n   $ pip install -e \".[quality]\"\n   ```\n\n   (If accelerate was already installed in the virtual environment, remove\n   it with `pip uninstall accelerate` before reinstalling it in editable\n   mode with the `-e` flag.)\n\n   Alternatively, if you are using [Visual Studio Code](https://code.visualstudio.com/Download), the fastest way to get set up is by using\n   the provided Dev Container. Documentation on how to get started with dev containers is available [here](https://code.visualstudio.com/docs/remote/containers).\n\n5. Develop the features on your branch.\n\n   As you work on the features, you should make sure that the test suite\n   passes. You should run the tests impacted by your changes like this (see \n   below an explanation regarding the environment variable):\n\n   ```bash\n   $ pytest tests/<TEST_TO_RUN>.py\n   ```\n   \n   > For the following commands leveraging the `make` utility, we recommend using the WSL system when running on\n   > Windows. More information [here](https://docs.microsoft.com/en-us/windows/wsl/about).\n\n   You can also run the full suite with the following command.\n\n   ```bash\n   $ make test\n   ```\n\n   `accelerate` relies on `black` and `ruff` to format its source code\n   consistently. After you make changes, apply automatic style corrections and code verifications\n   that can't be automated in one go with:\n\n   This target is also optimized to only work with files modified by the PR you're working on.\n\n   If you prefer to run the checks one after the other, the following command apply the\n   style corrections:\n\n   ```bash\n   $ make style\n   ```\n\n   `accelerate` also uses a few custom scripts to check for coding mistakes. Quality\n   control runs in CI, however you can also run the same checks with:\n\n   ```bash\n   $ make quality\n   ```\n\n   Once you're happy with your changes, add changed files using `git add` and\n   make a commit with `git commit` to record your changes locally:\n\n   ```bash\n   $ git add modified_file.py\n   $ git commit\n   ```\n\n   Please write [good commit messages](https://chris.beams.io/posts/git-commit/).\n\n   It is a good idea to sync your copy of the code with the original\n   repository regularly. This way you can quickly account for changes:\n\n   ```bash\n   $ git fetch upstream\n   $ git rebase upstream/main\n   ```\n\n   Push the changes to your account using:\n\n   ```bash\n   $ git push -u origin a-descriptive-name-for-my-changes\n   ```\n\n6. Once you are satisfied (**and the checklist below is happy too**), go to the\n   webpage of your fork on GitHub. Click on 'Pull request' to send your changes\n   to the project maintainers for review.\n\n7. It's ok if maintainers ask you for changes. It happens to core contributors\n   too! So everyone can see the changes in the Pull request, work in your local\n   branch and push the changes to your fork. They will automatically appear in\n   the pull request.\n\n\n### Checklist\n\n1. The title of your pull request should be a summary of its contribution;\n2. If your pull request addresses an issue, please mention the issue number in\n   the pull request description to make sure they are linked (and people\n   consulting the issue know you are working on it);\n3. To indicate a work in progress please prefix the title with `[WIP]`, or mark\n   the PR as a draft PR. These are useful to avoid duplicated work, and to differentiate\n   it from PRs ready to be merged;\n4. Make sure existing tests pass;\n5. Add high-coverage tests. No quality testing = no merge.\n\nSee an example of a good PR here: https://github.com/huggingface/accelerate/pull/255\n\n### Tests\n\nAn extensive test suite is included to test the library behavior and several examples. Library tests can be found in\nthe [tests folder](https://github.com/huggingface/accelerate/tree/main/tests).\n\nWe use `pytest` in order to run the tests. From the root of the\nrepository, here's how to run tests with `pytest` for the library:\n\n```bash\n$ python -m pytest -sv ./tests\n```\n\nIn fact, that's how `make test` is implemented (sans the `pip install` line)!\n\nYou can specify a smaller set of tests in order to test only the feature\nyou're working on.", ".PHONY: quality style test docs utils\n\ncheck_dirs := tests src examples benchmarks utils\n\n# Check that source code meets quality standards\n\nextra_quality_checks:\n\tpython utils/check_copies.py\n\tpython utils/check_dummies.py\n\tpython utils/check_repo.py\n\tdoc-builder style src/accelerate docs/source --max_len 119\n\n# this target runs checks on all files\nquality:\n\tblack --required-version 23 --check $(check_dirs)\n\truff $(check_dirs)\n\tdoc-builder style src/accelerate docs/source --max_len 119 --check_only\n\n# Format source code automatically and check is there are any problems left that need manual fixing\nstyle:\n\tblack --required-version 23 $(check_dirs)\n\truff $(check_dirs) --fix\n\tdoc-builder style src/accelerate docs/source --max_len 119\n\t\n# Run tests for the library\ntest:\n\tpython -m pytest -s -v ./tests/ --ignore=./tests/test_examples.py $(if $(IS_GITHUB_CI),--report-log \"$(PYTORCH_VERSION)_all.log\",)\n\ntest_big_modeling:\n\tpython -m pytest -s -v ./tests/test_big_modeling.py ./tests/test_modeling_utils.py $(if $(IS_GITHUB_CI),--report-log \"$(PYTORCH_VERSION)_big_modeling.log\",)\n\ntest_core:\n\tpython -m pytest -s -v ./tests/ --ignore=./tests/test_examples.py --ignore=./tests/deepspeed --ignore=./tests/test_big_modeling.py \\\n\t--ignore=./tests/fsdp --ignore=./tests/test_cli.py $(if $(IS_GITHUB_CI),--report-log \"$(PYTORCH_VERSION)_core.log\",)\n\ntest_cli:\n\tpython -m pytest -s -v ./tests/test_cli.py $(if $(IS_GITHUB_CI),--report-log \"$(PYTORCH_VERSION)_cli.log\",)\n\ntest_deepspeed:\n\tpython -m pytest -s -v ./tests/deepspeed $(if $(IS_GITHUB_CI),--report-log \"$(PYTORCH_VERSION)_deepspeed.log\",)\n\ntest_fsdp:\n\tpython -m pytest -s -v ./tests/fsdp $(if $(IS_GITHUB_CI),--report-log \"$(PYTORCH_VERSION)_fsdp.log\",)\n\ntest_examples:\n\tpython -m pytest -s -v ./tests/test_examples.py $(if $(IS_GITHUB_CI),--report-log \"$(PYTORCH_VERSION)_examples.log\",)\n\n# Broken down example tests for the CI runners\ntest_integrations:\n\tpython -m pytest -s -v ./tests/deepspeed ./tests/fsdp $(if $(IS_GITHUB_CI),--report-log \"$(PYTORCH_VERSION)_integrations.log\",)\n\ntest_example_differences:\n\tpython -m pytest -s -v ./tests/test_examples.py::ExampleDifferenceTests $(if $(IS_GITHUB_CI),--report-log \"$(PYTORCH_VERSION)_example_diff.log\",)\n\ntest_checkpoint_epoch:\n\tpython -m pytest -s -v ./tests/test_examples.py::FeatureExamplesTests -k \"by_epoch\" $(if $(IS_GITHUB_CI),--report-log \"$(PYTORCH_VERSION)_checkpoint_epoch.log\",)\n\ntest_checkpoint_step:\n\tpython -m pytest -s -v ./tests/test_examples.py::FeatureExamplesTests -k \"by_step\" $(if $(IS_GITHUB_CI),--report-log \"$(PYTORCH_VERSION)_checkpoint_step.log\",)\n\n# Same as test but used to install only the base dependencies\ntest_prod:\n\t$(MAKE) test_core\n\ntest_rest:\n\tpython -m pytest -s -v ./tests/test_examples.py::FeatureExamplesTests -k \"not by_step and not by_epoch\" $(if $(IS_GITHUB_CI),--report-log \"$(PYTORCH_VERSION)_rest.log\",)\n", "accelerate # used to be installed in Amazon SageMaker environment\nevaluate\ndatasets==2.3.2", "<!---\nCopyright 2021 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# In this folder we showcase various full examples using \ud83e\udd17 Accelerate\n\n## Simple NLP example\n\nThe [nlp_example.py](./nlp_example.py) script is a simple example to train a Bert model on a classification task ([GLUE's MRPC](https://www.microsoft.com/en-us/download/details.aspx?id=52398)).\n\nPrior to running it you should install \ud83e\udd17 Dataset and \ud83e\udd17 Transformers:\n\n```bash\npip install datasets evaluate transformers\n```\n\nThe same script can be run in any of the following configurations:\n- single CPU or single GPU\n- multi GPUs (using PyTorch distributed mode)\n- (multi) TPUs\n- fp16 (mixed-precision) or fp32 (normal precision)\n\nTo run it in each of these various modes, use the following commands:\n- single CPU:\n    * from a server without GPU\n        ```bash\n        python ./nlp_example.py\n        ```\n    * from any server by passing `cpu=True` to the `Accelerator`.\n        ```bash\n        python ./nlp_example.py --cpu\n        ```\n    * from any server with Accelerate launcher\n        ```bash\n        accelerate launch --cpu ./nlp_example.py\n        ```\n- single GPU:\n    ```bash\n    python ./nlp_example.py  # from a server with a GPU\n    ```\n- with fp16 (mixed-precision)\n    * from any server by passing `mixed_precison=fp16` to the `Accelerator`.\n        ```bash\n        python ./nlp_example.py --mixed_precision fp16\n        ```\n    * from any server with Accelerate launcher\n        ```bash\n        accelerate launch --mixed_precision fp16 ./nlp_example.py\n- multi GPUs (using PyTorch distributed mode)\n    * With Accelerate config and launcher\n        ```bash\n        accelerate config  # This will create a config file on your server\n        accelerate launch ./nlp_example.py  # This will run the script on your server\n        ```\n    * With traditional PyTorch launcher (`torch.distributed.launch` can be used with older versions of PyTorch)\n        ```bash\n        python -m torchrun --nproc_per_node 2 --use_env ./nlp_example.py\n        ```\n- multi GPUs, multi node (several machines, using PyTorch distributed mode)\n    * With Accelerate config and launcher, on each machine:\n        ```bash\n        accelerate config  # This will create a config file on each server\n        accelerate launch ./nlp_example.py  # This will run the script on each server\n        ```\n    * With PyTorch launcher only (`torch.distributed.launch` can be used in older versions of PyTorch)\n        ```bash\n        python -m torchrun --nproc_per_node 2 \\\n            --use_env \\\n            --node_rank 0 \\\n            --master_addr master_node_ip_address \\\n            ./nlp_example.py  # On the first server\n        python -m torchrun --nproc_per_node 2 \\\n            --use_env \\\n            --node_rank 1 \\\n            --master_addr master_node_ip_address \\\n            ./nlp_example.py  # On the second server\n        ```\n- (multi) TPUs\n    * With Accelerate config and launcher\n        ```bash\n        accelerate config  # This will create a config file on your TPU server\n        accelerate launch ./nlp_example.py  # This will run the script on each server\n        ```\n    * In PyTorch:\n        Add an `xmp.spawn` line in your script as you usually do.\n\n\n## Simple vision example\n\nThe [cv_example.py](./cv_example.py) script is a simple example to fine-tune a ResNet-50 on a classification task ([Ofxord-IIT Pet Dataset](https://www.robots.ox.ac.uk/~vgg/data/pets/)).\n\nThe same script can be run in any of the following configurations:\n- single CPU or single GPU\n- multi GPUs (using PyTorch distributed mode)\n- (multi) TPUs\n- fp16 (mixed-precision) or fp32 (normal precision)\n\nPrior to running it you should install timm and torchvision:\n\n```bash\npip install timm torchvision\n```\n\nand you should download the data with the following commands:\n\n```bash\nwget https://www.robots.ox.ac.uk/~vgg/data/pets/data/images.tar.gz\ntar -xzf images.tar.gz\n```\n\nTo run it in each of these various modes, use the following commands:\n- single CPU:\n    * from a server without GPU\n        ```bash\n        python ./cv_example.py --data_dir path_to_data\n        ```\n    * from any server by passing `cpu=True` to the `Accelerator`.\n        ```bash\n        python ./cv_example.py --data_dir path_to_data --cpu\n        ```\n    * from any server with Accelerate launcher\n        ```bash\n        accelerate launch --cpu ./cv_example.py --data_dir path_to_data\n        ```\n- single GPU:\n    ```bash\n    python ./cv_example.py  # from a server with a GPU\n    ```\n- with fp16 (mixed-precision)\n    * from any server by passing `mixed_precison=fp16` to the `Accelerator`.\n        ```bash\n        python ./cv_example.py --data_dir path_to_data --mixed_precison fp16\n        ```\n    * from any server with Accelerate launcher\n        ```bash\n        accelerate launch --mixed_precison fp16 ./cv_example.py --data_dir path_to_data\n- multi GPUs (using PyTorch distributed mode)\n    * With Accelerate config and launcher\n        ```bash\n        accelerate config  # This will create a config file on your server\n        accelerate launch ./cv_example.py --data_dir path_to_data  # This will run the script on your server\n        ```\n    * With traditional PyTorch launcher (`torch.distributed.launch` can be used with older versions of PyTorch)\n        ```bash\n        python -m torchrun --nproc_per_node 2 --use_env ./cv_example.py --data_dir path_to_data\n        ```\n- multi GPUs, multi node (several machines, using PyTorch distributed mode)\n    * With Accelerate config and launcher, on each machine:\n        ```bash\n        accelerate config  # This will create a config file on each server\n        accelerate launch ./cv_example.py --data_dir path_to_data  # This will run the script on each server\n        ```\n    * With PyTorch launcher only (`torch.distributed.launch` can be used with older versions of PyTorch)\n        ```bash\n        python -m torchrun --nproc_per_node 2 \\\n            --use_env \\\n            --node_rank 0 \\\n            --master_addr master_node_ip_address \\\n            ./cv_example.py --data_dir path_to_data  # On the first server\n        python -m torchrun --nproc_per_node 2 \\\n            --use_env \\\n            --node_rank 1 \\\n            --master_addr master_node_ip_address \\\n            ./cv_example.py --data_dir path_to_data  # On the second server\n        ```\n- (multi) TPUs\n    * With Accelerate config and launcher\n        ```bash\n        accelerate config  # This will create a config file on your TPU server\n        accelerate launch ./cv_example.py --data_dir path_to_data  # This will run the script on each server\n        ```\n    * In PyTorch:\n        Add an `xmp.spawn` line in your script as you usually do.\n\n### Simple vision example (GANs)\n\n- [huggan project](https://github.com/huggingface/community-events/tree/main/huggan)\n\n### Using AWS SageMaker integration\n- [Examples showcasing AWS SageMaker integration of \ud83e\udd17 Accelerate.](https://github.com/pacman100/accelerate-aws-sagemaker)\n\n\n## Simple Multi-GPU Hardware Launcher\n\n[multigpu_remote_launcher.py](./multigpu_remote_launcher.py) is a minimal script that demonstrates launching accelerate\non multiple remote GPUs, and with automatic hardware environment and dependency setup for reproducibility. You can\neasily customize the training function used, training arguments, hyperparameters, and type of compute hardware, and then\nrun the script to automatically launch multi GPU training on remote hardware.\n\nThis script uses [Runhouse](https://github.com/run-house/runhouse) to launch on self-hosted hardware (e.g. in your own\ncloud account or on-premise cluster) but there are other options for running remotely as well. Runhouse can be installed\nwith `pip install runhouse`, and you can refer to\n[hardware setup](https://runhouse-docs.readthedocs-hosted.com/en/latest/api/python/cluster.html#hardware-setup)\nfor hardware setup instructions, or this\n[Colab tutorial](https://colab.research.google.com/drive/1qVwYyLTCPYPSdz9ZX7BZl9Qm0A3j7RJe) for a more in-depth walkthrough.\n\n## Finer Examples\n\nWhile the first two scripts are extremely barebones when it comes to what you can do with accelerate, more advanced features are documented in two other locations.\n\n### `by_feature` examples\n\nThese scripts are *individual* examples highlighting one particular feature or use-case within Accelerate. They all stem from the [nlp_example.py](./nlp_example.py) script, and any changes or modifications is denoted with a `# New Code #` comment.\n\nRead the README.md file located in the `by_feature` folder for more information.\n\n### `complete_*` examples\n\nThese two scripts contain *every* single feature currently available in Accelerate in one place, as one giant script.\n\nNew arguments that can be passed include:\n\n- `checkpointing_steps`, whether the various states should be saved at the end of every `n` steps, or `\"epoch\"` for each epoch. States are then saved to folders named `step_{n}` or `epoch_{n}`\n- `resume_from_checkpoint`, should be used if you want to resume training off of a previous call to the script and passed a `checkpointing_steps` to it.\n- `with_tracking`, should be used if you want to log the training run using all available experiment trackers in your environment. Currently supported trackers include TensorBoard, Weights and Biases, and CometML.\n", "# coding=utf-8\n# Copyright 2021 The HuggingFace Inc. team. All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nimport argparse\nimport os\nimport re\n\nimport numpy as np\nimport PIL\nimport torch\nfrom timm import create_model\nfrom torch.optim.lr_scheduler import OneCycleLR\nfrom torch.utils.data import DataLoader, Dataset\nfrom torchvision.transforms import Compose, RandomResizedCrop, Resize, ToTensor\n\nfrom accelerate import Accelerator\n\n\n########################################################################\n# This is a fully working simple example to use Accelerate\n#\n# This example trains a ResNet50 on the Oxford-IIT Pet Dataset\n# in any of the following settings (with the same script):\n#   - single CPU or single GPU\n#   - multi GPUS (using PyTorch distributed mode)\n#   - (multi) TPUs\n#   - fp16 (mixed-precision) or fp32 (normal precision)\n#\n# To run it in each of these various modes, follow the instructions\n# in the readme for examples:\n# https://github.com/huggingface/accelerate/tree/main/examples\n#\n########################################################################\n\n\n# Function to get the label from the filename\ndef extract_label(fname):\n    stem = fname.split(os.path.sep)[-1]\n    return re.search(r\"^(.*)_\\d+\\.jpg$\", stem).groups()[0]\n\n\nclass PetsDataset(Dataset):\n    def __init__(self, file_names, image_transform=None, label_to_id=None):\n        self.file_names = file_names\n        self.image_transform = image_transform\n        self.label_to_id = label_to_id\n\n    def __len__(self):\n        return len(self.file_names)\n\n    def __getitem__(self, idx):\n        fname = self.file_names[idx]\n        raw_image = PIL.Image.open(fname)\n        image = raw_image.convert(\"RGB\")\n        if self.image_transform is not None:\n            image = self.image_transform(image)\n        label = extract_label(fname)\n        if self.label_to_id is not None:\n            label = self.label_to_id[label]\n        return {\"image\": image, \"label\": label}\n\n\ndef training_function(config, args):\n    # Initialize accelerator\n    accelerator = Accelerator(cpu=args.cpu, mixed_precision=args.mixed_precision)\n\n    # Sample hyper-parameters for learning rate, batch size, seed and a few other HPs\n    lr = config[\"lr\"]\n    num_epochs = int(config[\"num_epochs\"])\n    seed = int(config[\"seed\"])\n    batch_size = int(config[\"batch_size\"])\n    image_size = config[\"image_size\"]\n    if not isinstance(image_size, (list, tuple)):\n        image_size = (image_size, image_size)\n\n    # Grab all the image filenames\n    file_names = [os.path.join(args.data_dir, fname) for fname in os.listdir(args.data_dir) if fname.endswith(\".jpg\")]\n\n    # Build the label correspondences\n    all_labels = [extract_label(fname) for fname in file_names]\n    id_to_label = list(set(all_labels))\n    id_to_label.sort()\n    label_to_id = {lbl: i for i, lbl in enumerate(id_to_label)}\n\n    # Set the seed before splitting the data.\n    np.random.seed(seed)\n    torch.manual_seed(seed)\n    torch.cuda.manual_seed_all(seed)\n\n    # Split our filenames between train and validation\n    random_perm = np.random.permutation(len(file_names))\n    cut = int(0.8 * len(file_names))\n    train_split = random_perm[:cut]\n    eval_split = random_perm[cut:]\n\n    # For training we use a simple RandomResizedCrop\n    train_tfm = Compose([RandomResizedCrop(image_size, scale=(0.5, 1.0)), ToTensor()])\n    train_dataset = PetsDataset(\n        [file_names[i] for i in train_split], image_transform=train_tfm, label_to_id=label_to_id\n    )\n\n    # For evaluation, we use a deterministic Resize\n    eval_tfm = Compose([Resize(image_size), ToTensor()])\n    eval_dataset = PetsDataset([file_names[i] for i in eval_split], image_transform=eval_tfm, label_to_id=label_to_id)\n\n    # Instantiate dataloaders.\n    train_dataloader = DataLoader(train_dataset, shuffle=True, batch_size=batch_size, num_workers=4)\n    eval_dataloader = DataLoader(eval_dataset, shuffle=False, batch_size=batch_size, num_workers=4)\n\n    # Instantiate the model (we build the model here so that the seed also control new weights initialization)\n    model = create_model(\"resnet50d\", pretrained=True, num_classes=len(label_to_id))\n\n    # We could avoid this line since the accelerator is set with `device_placement=True` (default value).\n    # Note that if you are placing tensors on devices manually, this line absolutely needs to be before the optimizer\n    # creation otherwise training will not work on TPU (`accelerate` will kindly throw an error to make us aware of that).\n    model = model.to(accelerator.device)\n\n    # Freezing the base model\n    for param in model.parameters():\n        param.requires_grad = False\n    for param in model.get_classifier().parameters():\n        param.requires_grad = True\n\n    # We normalize the batches of images to be a bit faster.\n    mean = torch.tensor(model.default_cfg[\"mean\"])[None, :, None, None].to(accelerator.device)\n    std = torch.tensor(model.default_cfg[\"std\"])[None, :, None, None].to(accelerator.device)\n\n    # Instantiate optimizer\n    optimizer = torch.optim.Adam(params=model.parameters(), lr=lr / 25)\n\n    # Instantiate learning rate scheduler\n    lr_scheduler = OneCycleLR(optimizer=optimizer, max_lr=lr, epochs=num_epochs, steps_per_epoch=len(train_dataloader))\n\n    # Prepare everything\n    # There is no specific order to remember, we just need to unpack the objects in the same order we gave them to the\n    # prepare method.\n    model, optimizer, train_dataloader, eval_dataloader, lr_scheduler = accelerator.prepare(\n        model, optimizer, train_dataloader, eval_dataloader, lr_scheduler\n    )\n\n    # Now we train the model\n    for epoch in range(num_epochs):\n        model.train()\n        for step, batch in enumerate(train_dataloader):\n            # We could avoid this line since we set the accelerator with `device_placement=True`.\n            batch = {k: v.to(accelerator.device) for k, v in batch.items()}\n            inputs = (batch[\"image\"] - mean) / std\n            outputs = model(inputs)\n            loss = torch.nn.functional.cross_entropy(outputs, batch[\"label\"])\n            accelerator.backward(loss)\n            optimizer.step()\n            lr_scheduler.step()\n            optimizer.zero_grad()\n\n        model.eval()\n        accurate = 0\n        num_elems = 0\n        for _, batch in enumerate(eval_dataloader):\n            # We could avoid this line since we set the accelerator with `device_placement=True`.\n            batch = {k: v.to(accelerator.device) for k, v in batch.items()}\n            inputs = (batch[\"image\"] - mean) / std\n            with torch.no_grad():\n                outputs = model(inputs)\n            predictions = outputs.argmax(dim=-1)\n            predictions, references = accelerator.gather_for_metrics((predictions, batch[\"label\"]))\n            accurate_preds = predictions == references\n            num_elems += accurate_preds.shape[0]\n            accurate += accurate_preds.long().sum()\n\n        eval_metric = accurate.item() / num_elems\n        # Use accelerator.print to print only on the main process.\n        accelerator.print(f\"epoch {epoch}: {100 * eval_metric:.2f}\")\n\n\ndef main():\n    parser = argparse.ArgumentParser(description=\"Simple example of training script.\")\n    parser.add_argument(\"--data_dir\", required=True, help=\"The data folder on disk.\")\n    parser.add_argument(\n        \"--mixed_precision\",\n        type=str,\n        default=None,\n        choices=[\"no\", \"fp16\", \"bf16\", \"fp8\"],\n        help=\"Whether to use mixed precision. Choose\"\n        \"between fp16 and bf16 (bfloat16). Bf16 requires PyTorch >= 1.10.\"\n        \"and an Nvidia Ampere GPU.\",\n    )\n    parser.add_argument(\n        \"--checkpointing_steps\",\n        type=str,\n        default=None,\n        help=\"Whether the various states should be saved at the end of every n steps, or 'epoch' for each epoch.\",\n    )\n    parser.add_argument(\"--cpu\", action=\"store_true\", help=\"If passed, will train on the CPU.\")\n    args = parser.parse_args()\n    config = {\"lr\": 3e-2, \"num_epochs\": 3, \"seed\": 42, \"batch_size\": 64, \"image_size\": 224}\n    training_function(config, args)\n\n\nif __name__ == \"__main__\":\n    main()\n", "# coding=utf-8\n# Copyright 2021 The HuggingFace Inc. team. All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nimport argparse\nimport os\n\nimport evaluate\nimport torch\nfrom datasets import load_dataset\nfrom torch.optim import AdamW\nfrom torch.utils.data import DataLoader\nfrom transformers import AutoModelForSequenceClassification, AutoTokenizer, get_linear_schedule_with_warmup, set_seed\n\nfrom accelerate import Accelerator, DistributedType\n\n\n########################################################################\n# This is a fully working simple example to use Accelerate\n#\n# This example trains a Bert base model on GLUE MRPC\n# in any of the following settings (with the same script):\n#   - single CPU or single GPU\n#   - multi GPUS (using PyTorch distributed mode)\n#   - (multi) TPUs\n#   - fp16 (mixed-precision) or fp32 (normal precision)\n#\n# This example also demonstrates the checkpointing and sharding capabilities\n#\n# To run it in each of these various modes, follow the instructions\n# in the readme for examples:\n# https://github.com/huggingface/accelerate/tree/main/examples\n#\n########################################################################\n\n\nMAX_GPU_BATCH_SIZE = 16\nEVAL_BATCH_SIZE = 32\n\n\ndef training_function(config, args):\n    # Initialize accelerator\n    if args.with_tracking:\n        accelerator = Accelerator(\n            cpu=args.cpu, mixed_precision=args.mixed_precision, log_with=\"all\", project_dir=args.project_dir\n        )\n    else:\n        accelerator = Accelerator(cpu=args.cpu, mixed_precision=args.mixed_precision)\n\n    if hasattr(args.checkpointing_steps, \"isdigit\"):\n        if args.checkpointing_steps == \"epoch\":\n            checkpointing_steps = args.checkpointing_steps\n        elif args.checkpointing_steps.isdigit():\n            checkpointing_steps = int(args.checkpointing_steps)\n        else:\n            raise ValueError(\n                f\"Argument `checkpointing_steps` must be either a number or `epoch`. `{args.checkpointing_steps}` passed.\"\n            )\n    else:\n        checkpointing_steps = None\n    # Sample hyper-parameters for learning rate, batch size, seed and a few other HPs\n    lr = config[\"lr\"]\n    num_epochs = int(config[\"num_epochs\"])\n    seed = int(config[\"seed\"])\n    batch_size = int(config[\"batch_size\"])\n\n    # We need to initialize the trackers we use, and also store our configuration\n    if args.with_tracking:\n        run = os.path.split(__file__)[-1].split(\".\")[0]\n        accelerator.init_trackers(run, config)\n\n    tokenizer = AutoTokenizer.from_pretrained(\"bert-base-cased\")\n    datasets = load_dataset(\"glue\", \"mrpc\")\n    metric = evaluate.load(\"glue\", \"mrpc\")\n\n    def tokenize_function(examples):\n        # max_length=None => use the model max length (it's actually the default)\n        outputs = tokenizer(examples[\"sentence1\"], examples[\"sentence2\"], truncation=True, max_length=None)\n        return outputs\n\n    # Apply the method we just defined to all the examples in all the splits of the dataset\n    # starting with the main process first:\n    with accelerator.main_process_first():\n        tokenized_datasets = datasets.map(\n            tokenize_function,\n            batched=True,\n            remove_columns=[\"idx\", \"sentence1\", \"sentence2\"],\n        )\n\n    # We also rename the 'label' column to 'labels' which is the expected name for labels by the models of the\n    # transformers library\n    tokenized_datasets = tokenized_datasets.rename_column(\"label\", \"labels\")\n\n    # If the batch size is too big we use gradient accumulation\n    gradient_accumulation_steps = 1\n    if batch_size > MAX_GPU_BATCH_SIZE and accelerator.distributed_type != DistributedType.TPU:\n        gradient_accumulation_steps = batch_size // MAX_GPU_BATCH_SIZE\n        batch_size = MAX_GPU_BATCH_SIZE\n\n    def collate_fn(examples):\n        # On TPU it's best to pad everything to the same length or training will be very slow.\n        max_length = 128 if accelerator.distributed_type == DistributedType.TPU else None\n        # When using mixed precision we want round multiples of 8/16\n        if accelerator.mixed_precision == \"fp8\":\n            pad_to_multiple_of = 16\n        elif accelerator.mixed_precision != \"no\":\n            pad_to_multiple_of = 8\n        else:\n            pad_to_multiple_of = None\n\n        return tokenizer.pad(\n            examples,\n            padding=\"longest\",\n            max_length=max_length,\n            pad_to_multiple_of=pad_to_multiple_of,\n            return_tensors=\"pt\",\n        )\n\n    # Instantiate dataloaders.\n    train_dataloader = DataLoader(\n        tokenized_datasets[\"train\"], shuffle=True, collate_fn=collate_fn, batch_size=batch_size\n    )\n    eval_dataloader = DataLoader(\n        tokenized_datasets[\"validation\"], shuffle=False, collate_fn=collate_fn, batch_size=EVAL_BATCH_SIZE\n    )\n\n    set_seed(seed)\n\n    # Instantiate the model (we build the model here so that the seed also control new weights initialization)\n    model = AutoModelForSequenceClassification.from_pretrained(\"bert-base-cased\", return_dict=True)\n\n    # We could avoid this line since the accelerator is set with `device_placement=True` (default value).\n    # Note that if you are placing tensors on devices manually, this line absolutely needs to be before the optimizer\n    # creation otherwise training will not work on TPU (`accelerate` will kindly throw an error to make us aware of that).\n    model = model.to(accelerator.device)\n\n    # Instantiate optimizer\n    optimizer = AdamW(params=model.parameters(), lr=lr)\n\n    # Instantiate scheduler\n    lr_scheduler = get_linear_schedule_with_warmup(\n        optimizer=optimizer,\n        num_warmup_steps=100,\n        num_training_steps=(len(train_dataloader) * num_epochs) // gradient_accumulation_steps,\n    )\n\n    # Prepare everything\n    # There is no specific order to remember, we just need to unpack the objects in the same order we gave them to the\n    # prepare method.\n    model, optimizer, train_dataloader, eval_dataloader, lr_scheduler = accelerator.prepare(\n        model, optimizer, train_dataloader, eval_dataloader, lr_scheduler\n    )\n\n    # We need to keep track of how many total steps we have iterated over\n    overall_step = 0\n    # We also need to keep track of the stating epoch so files are named properly\n    starting_epoch = 0\n\n    # Potentially load in the weights and states from a previous save\n    if args.resume_from_checkpoint:\n        if args.resume_from_checkpoint is not None or args.resume_from_checkpoint != \"\":\n            accelerator.print(f\"Resumed from checkpoint: {args.resume_from_checkpoint}\")\n            accelerator.load_state(args.resume_from_checkpoint)\n            path = os.path.basename(args.resume_from_checkpoint)\n        else:\n            # Get the most recent checkpoint\n            dirs = [f.name for f in os.scandir(os.getcwd()) if f.is_dir()]\n            dirs.sort(key=os.path.getctime)\n            path = dirs[-1]  # Sorts folders by date modified, most recent checkpoint is the last\n        # Extract `epoch_{i}` or `step_{i}`\n        training_difference = os.path.splitext(path)[0]\n\n        if \"epoch\" in training_difference:\n            starting_epoch = int(training_difference.replace(\"epoch_\", \"\")) + 1\n            resume_step = None\n        else:\n            resume_step = int(training_difference.replace(\"step_\", \"\"))\n            starting_epoch = resume_step // len(train_dataloader)\n            resume_step -= starting_epoch * len(train_dataloader)\n\n    # Now we train the model\n    for epoch in range(starting_epoch, num_epochs):\n        model.train()\n        if args.with_tracking:\n            total_loss = 0\n        if args.resume_from_checkpoint and epoch == starting_epoch and resume_step is not None:\n            # We need to skip steps until we reach the resumed step\n            active_dataloader = accelerator.skip_first_batches(train_dataloader, resume_step)\n            overall_step += resume_step\n        else:\n            # After the first iteration though, we need to go back to the original dataloader\n            active_dataloader = train_dataloader\n        for step, batch in enumerate(active_dataloader):\n            # We could avoid this line since we set the accelerator with `device_placement=True`.\n            batch.to(accelerator.device)\n            outputs = model(**batch)\n            loss = outputs.loss\n            loss = loss / gradient_accumulation_steps\n            # We keep track of the loss at each epoch\n            if args.with_tracking:\n                total_loss += loss.detach().float()\n            accelerator.backward(loss)\n            if step % gradient_accumulation_steps == 0:\n                optimizer.step()\n                lr_scheduler.step()\n                optimizer.zero_grad()\n\n            overall_step += 1\n\n            if isinstance(checkpointing_steps, int):\n                output_dir = f\"step_{overall_step}\"\n                if overall_step % checkpointing_steps == 0:\n                    if args.output_dir is not None:\n                        output_dir = os.path.join(args.output_dir, output_dir)\n                    accelerator.save_state(output_dir)\n\n        model.eval()\n        for step, batch in enumerate(eval_dataloader):\n            # We could avoid this line since we set the accelerator with `device_placement=True`.\n            batch.to(accelerator.device)\n            with torch.no_grad():\n                outputs = model(**batch)\n            predictions = outputs.logits.argmax(dim=-1)\n            predictions, references = accelerator.gather_for_metrics((predictions, batch[\"labels\"]))\n            metric.add_batch(\n                predictions=predictions,\n                references=references,\n            )\n\n        eval_metric = metric.compute()\n        # Use accelerator.print to print only on the main process.\n        accelerator.print(f\"epoch {epoch}:\", eval_metric)\n        if args.with_tracking:\n            accelerator.log(\n                {\n                    \"accuracy\": eval_metric[\"accuracy\"],\n                    \"f1\": eval_metric[\"f1\"],\n                    \"train_loss\": total_loss.item() / len(train_dataloader),\n                    \"epoch\": epoch,\n                },\n                step=epoch,\n            )\n\n        if checkpointing_steps == \"epoch\":\n            output_dir = f\"epoch_{epoch}\"\n            if args.output_dir is not None:\n                output_dir = os.path.join(args.output_dir, output_dir)\n            accelerator.save_state(output_dir)\n\n    if args.with_tracking:\n        accelerator.end_training()\n\n\ndef main():\n    parser = argparse.ArgumentParser(description=\"Simple example of training script.\")\n    parser.add_argument(\n        \"--mixed_precision\",\n        type=str,\n        default=None,\n        choices=[\"no\", \"fp16\", \"bf16\", \"fp8\"],\n        help=\"Whether to use mixed precision. Choose\"\n        \"between fp16 and bf16 (bfloat16). Bf16 requires PyTorch >= 1.10.\"\n        \"and an Nvidia Ampere GPU.\",\n    )\n    parser.add_argument(\"--cpu\", action=\"store_true\", help=\"If passed, will train on the CPU.\")\n    parser.add_argument(\n        \"--checkpointing_steps\",\n        type=str,\n        default=None,\n        help=\"Whether the various states should be saved at the end of every n steps, or 'epoch' for each epoch.\",\n    )\n    parser.add_argument(\n        \"--resume_from_checkpoint\",\n        type=str,\n        default=None,\n        help=\"If the training should continue from a checkpoint folder.\",\n    )\n    parser.add_argument(\n        \"--with_tracking\",\n        action=\"store_true\",\n        help=\"Whether to load in all available experiment trackers from the environment and use them for logging.\",\n    )\n    parser.add_argument(\n        \"--output_dir\",\n        type=str,\n        default=\".\",\n        help=\"Optional save directory where all checkpoint folders will be stored. Default is the current working directory.\",\n    )\n    parser.add_argument(\n        \"--project_dir\",\n        type=str,\n        default=\"logs\",\n        help=\"Location on where to store experiment tracking logs` and relevent project information\",\n    )\n    args = parser.parse_args()\n    config = {\"lr\": 2e-5, \"num_epochs\": 3, \"seed\": 42, \"batch_size\": 16}\n    training_function(config, args)\n\n\nif __name__ == \"__main__\":\n    main()\n", "import argparse\n\nimport runhouse as rh\nimport torch\nfrom nlp_example import training_function\n\nfrom accelerate.utils import PrepareForLaunch, patch_environment\n\n\ndef launch_train(*args):\n    num_processes = torch.cuda.device_count()\n    print(f\"Device count: {num_processes}\")\n    with patch_environment(\n        world_size=num_processes, master_addr=\"127.0.01\", master_port=\"29500\", mixed_precision=args[1].mixed_precision\n    ):\n        launcher = PrepareForLaunch(training_function, distributed_type=\"MULTI_GPU\")\n        torch.multiprocessing.start_processes(launcher, args=args, nprocs=num_processes, start_method=\"spawn\")\n\n\nif __name__ == \"__main__\":\n    # Refer to https://runhouse-docs.readthedocs-hosted.com/en/main/rh_primitives/cluster.html#hardware-setup\n    # for cloud access setup instructions (if using on-demand hardware), and for API specifications.\n\n    # on-demand GPU\n    # gpu = rh.cluster(name='rh-cluster', instance_type='V100:1', provider='cheapest', use_spot=False)  # single GPU\n    gpu = rh.cluster(name=\"rh-cluster\", instance_type=\"V100:4\", provider=\"cheapest\", use_spot=False)  # multi GPU\n    gpu.up_if_not()\n\n    # on-prem GPU\n    # gpu = rh.cluster(\n    #           ips=[\"ip_addr\"], ssh_creds={ssh_user:\"<username>\", ssh_private_key:\"<key_path>\"}, name=\"rh-cluster\"\n    #       )\n\n    # Set up remote function\n    reqs = [\n        \"pip:./\",\n        \"transformers\",\n        \"datasets\",\n        \"evaluate\",\n        \"tqdm\",\n        \"scipy\",\n        \"scikit-learn\",\n        \"tensorboard\",\n        \"torch --upgrade --extra-index-url https://download.pytorch.org/whl/cu117\",\n    ]\n    launch_train_gpu = rh.function(fn=launch_train, system=gpu, reqs=reqs, name=\"train_bert_glue\")\n\n    # Define train args/config, run train function\n    train_args = argparse.Namespace(cpu=False, mixed_precision=\"fp16\")\n    config = {\"lr\": 2e-5, \"num_epochs\": 3, \"seed\": 42, \"batch_size\": 16}\n    launch_train_gpu(config, train_args, stream_logs=True)\n\n    # Alternatively, we can just run as instructed in the README (but only because there's already a wrapper CLI):\n    # gpu.install_packages(reqs)\n    # gpu.run(['accelerate launch --multi_gpu accelerate/examples/nlp_example.py'])\n", "# coding=utf-8\n# Copyright 2021 The HuggingFace Inc. team. All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nimport argparse\nimport os\nimport re\n\nimport numpy as np\nimport PIL\nimport torch\nfrom timm import create_model\nfrom torch.optim.lr_scheduler import OneCycleLR\nfrom torch.utils.data import DataLoader, Dataset\nfrom torchvision.transforms import Compose, RandomResizedCrop, Resize, ToTensor\n\nfrom accelerate import Accelerator\n\n\n########################################################################\n# This is a fully working simple example to use Accelerate\n#\n# This example trains a ResNet50 on the Oxford-IIT Pet Dataset\n# in any of the following settings (with the same script):\n#   - single CPU or single GPU\n#   - multi GPUS (using PyTorch distributed mode)\n#   - (multi) TPUs\n#   - fp16 (mixed-precision) or fp32 (normal precision)\n#\n# To run it in each of these various modes, follow the instructions\n# in the readme for examples:\n# https://github.com/huggingface/accelerate/tree/main/examples\n#\n########################################################################\n\n\n# Function to get the label from the filename\ndef extract_label(fname):\n    stem = fname.split(os.path.sep)[-1]\n    return re.search(r\"^(.*)_\\d+\\.jpg$\", stem).groups()[0]\n\n\nclass PetsDataset(Dataset):\n    def __init__(self, file_names, image_transform=None, label_to_id=None):\n        self.file_names = file_names\n        self.image_transform = image_transform\n        self.label_to_id = label_to_id\n\n    def __len__(self):\n        return len(self.file_names)\n\n    def __getitem__(self, idx):\n        fname = self.file_names[idx]\n        raw_image = PIL.Image.open(fname)\n        image = raw_image.convert(\"RGB\")\n        if self.image_transform is not None:\n            image = self.image_transform(image)\n        label = extract_label(fname)\n        if self.label_to_id is not None:\n            label = self.label_to_id[label]\n        return {\"image\": image, \"label\": label}\n\n\ndef training_function(config, args):\n    # Initialize accelerator\n    if args.with_tracking:\n        accelerator = Accelerator(\n            cpu=args.cpu, mixed_precision=args.mixed_precision, log_with=\"all\", project_dir=args.project_dir\n        )\n    else:\n        accelerator = Accelerator(cpu=args.cpu, mixed_precision=args.mixed_precision)\n\n    # Sample hyper-parameters for learning rate, batch size, seed and a few other HPs\n    lr = config[\"lr\"]\n    num_epochs = int(config[\"num_epochs\"])\n    seed = int(config[\"seed\"])\n    batch_size = int(config[\"batch_size\"])\n    image_size = config[\"image_size\"]\n    if not isinstance(image_size, (list, tuple)):\n        image_size = (image_size, image_size)\n\n    # Parse out whether we are saving every epoch or after a certain number of batches\n    if hasattr(args.checkpointing_steps, \"isdigit\"):\n        if args.checkpointing_steps == \"epoch\":\n            checkpointing_steps = args.checkpointing_steps\n        elif args.checkpointing_steps.isdigit():\n            checkpointing_steps = int(args.checkpointing_steps)\n        else:\n            raise ValueError(\n                f\"Argument `checkpointing_steps` must be either a number or `epoch`. `{args.checkpointing_steps}` passed.\"\n            )\n    else:\n        checkpointing_steps = None\n\n    # We need to initialize the trackers we use, and also store our configuration\n    if args.with_tracking:\n        run = os.path.split(__file__)[-1].split(\".\")[0]\n        accelerator.init_trackers(run, config)\n\n    # Grab all the image filenames\n    file_names = [os.path.join(args.data_dir, fname) for fname in os.listdir(args.data_dir) if fname.endswith(\".jpg\")]\n\n    # Build the label correspondences\n    all_labels = [extract_label(fname) for fname in file_names]\n    id_to_label = list(set(all_labels))\n    id_to_label.sort()\n    label_to_id = {lbl: i for i, lbl in enumerate(id_to_label)}\n\n    # Set the seed before splitting the data.\n    np.random.seed(seed)\n    torch.manual_seed(seed)\n    torch.cuda.manual_seed_all(seed)\n\n    # Split our filenames between train and validation\n    random_perm = np.random.permutation(len(file_names))\n    cut = int(0.8 * len(file_names))\n    train_split = random_perm[:cut]\n    eval_split = random_perm[cut:]\n\n    # For training we use a simple RandomResizedCrop\n    train_tfm = Compose([RandomResizedCrop(image_size, scale=(0.5, 1.0)), ToTensor()])\n    train_dataset = PetsDataset(\n        [file_names[i] for i in train_split], image_transform=train_tfm, label_to_id=label_to_id\n    )\n\n    # For evaluation, we use a deterministic Resize\n    eval_tfm = Compose([Resize(image_size), ToTensor()])\n    eval_dataset = PetsDataset([file_names[i] for i in eval_split], image_transform=eval_tfm, label_to_id=label_to_id)\n\n    # Instantiate dataloaders.\n    train_dataloader = DataLoader(train_dataset, shuffle=True, batch_size=batch_size, num_workers=4)\n    eval_dataloader = DataLoader(eval_dataset, shuffle=False, batch_size=batch_size, num_workers=4)\n\n    # Instantiate the model (we build the model here so that the seed also control new weights initialization)\n    model = create_model(\"resnet50d\", pretrained=True, num_classes=len(label_to_id))\n\n    # We could avoid this line since the accelerator is set with `device_placement=True` (default value).\n    # Note that if you are placing tensors on devices manually, this line absolutely needs to be before the optimizer\n    # creation otherwise training will not work on TPU (`accelerate` will kindly throw an error to make us aware of that).\n    model = model.to(accelerator.device)\n\n    # Freezing the base model\n    for param in model.parameters():\n        param.requires_grad = False\n    for param in model.get_classifier().parameters():\n        param.requires_grad = True\n\n    # We normalize the batches of images to be a bit faster.\n    mean = torch.tensor(model.default_cfg[\"mean\"])[None, :, None, None].to(accelerator.device)\n    std = torch.tensor(model.default_cfg[\"std\"])[None, :, None, None].to(accelerator.device)\n\n    # Instantiate optimizer\n    optimizer = torch.optim.Adam(params=model.parameters(), lr=lr / 25)\n\n    # Instantiate learning rate scheduler\n    lr_scheduler = OneCycleLR(optimizer=optimizer, max_lr=lr, epochs=num_epochs, steps_per_epoch=len(train_dataloader))\n\n    # Prepare everything\n    # There is no specific order to remember, we just need to unpack the objects in the same order we gave them to the\n    # prepare method.\n    model, optimizer, train_dataloader, eval_dataloader, lr_scheduler = accelerator.prepare(\n        model, optimizer, train_dataloader, eval_dataloader, lr_scheduler\n    )\n    # We need to keep track of how many total steps we have iterated over\n    overall_step = 0\n    # We also need to keep track of the starting epoch so files are named properly\n    starting_epoch = 0\n\n    # Potentially load in the weights and states from a previous save\n    if args.resume_from_checkpoint:\n        if args.resume_from_checkpoint is not None or args.resume_from_checkpoint != \"\":\n            accelerator.print(f\"Resumed from checkpoint: {args.resume_from_checkpoint}\")\n            accelerator.load_state(args.resume_from_checkpoint)\n            path = os.path.basename(args.resume_from_checkpoint)\n        else:\n            # Get the most recent checkpoint\n            dirs = [f.name for f in os.scandir(os.getcwd()) if f.is_dir()]\n            dirs.sort(key=os.path.getctime)\n            path = dirs[-1]  # Sorts folders by date modified, most recent checkpoint is the last\n        # Extract `epoch_{i}` or `step_{i}`\n        training_difference = os.path.splitext(path)[0]\n\n        if \"epoch\" in training_difference:\n            starting_epoch = int(training_difference.replace(\"epoch_\", \"\")) + 1\n            resume_step = None\n        else:\n            resume_step = int(training_difference.replace(\"step_\", \"\"))\n            starting_epoch = resume_step // len(train_dataloader)\n            resume_step -= starting_epoch * len(train_dataloader)\n\n    # Now we train the model\n    for epoch in range(starting_epoch, num_epochs):\n        model.train()\n        if args.with_tracking:\n            total_loss = 0\n        if args.resume_from_checkpoint and epoch == starting_epoch and resume_step is not None:\n            # We need to skip steps until we reach the resumed step\n            active_dataloader = accelerator.skip_first_batches(train_dataloader, resume_step)\n            overall_step += resume_step\n        else:\n            # After the first iteration though, we need to go back to the original dataloader\n            active_dataloader = train_dataloader\n        for batch in active_dataloader:\n            # We could avoid this line since we set the accelerator with `device_placement=True`.\n            batch = {k: v.to(accelerator.device) for k, v in batch.items()}\n            inputs = (batch[\"image\"] - mean) / std\n            outputs = model(inputs)\n            loss = torch.nn.functional.cross_entropy(outputs, batch[\"label\"])\n            # We keep track of the loss at each epoch\n            if args.with_tracking:\n                total_loss += loss.detach().float()\n            accelerator.backward(loss)\n            optimizer.step()\n            lr_scheduler.step()\n            optimizer.zero_grad()\n            overall_step += 1\n            if isinstance(checkpointing_steps, int):\n                output_dir = f\"step_{overall_step}\"\n                if overall_step % checkpointing_steps == 0:\n                    if args.output_dir is not None:\n                        output_dir = os.path.join(args.output_dir, output_dir)\n                    accelerator.save_state(output_dir)\n        model.eval()\n        accurate = 0\n        num_elems = 0\n        for step, batch in enumerate(eval_dataloader):\n            # We could avoid this line since we set the accelerator with `device_placement=True`.\n            batch = {k: v.to(accelerator.device) for k, v in batch.items()}\n            inputs = (batch[\"image\"] - mean) / std\n            with torch.no_grad():\n                outputs = model(inputs)\n            predictions = outputs.argmax(dim=-1)\n            predictions, references = accelerator.gather_for_metrics((predictions, batch[\"label\"]))\n            accurate_preds = predictions == references\n            num_elems += accurate_preds.shape[0]\n            accurate += accurate_preds.long().sum()\n\n        eval_metric = accurate.item() / num_elems\n        # Use accelerator.print to print only on the main process.\n        accelerator.print(f\"epoch {epoch}: {100 * eval_metric:.2f}\")\n        if args.with_tracking:\n            accelerator.log(\n                {\n                    \"accuracy\": 100 * eval_metric,\n                    \"train_loss\": total_loss.item() / len(train_dataloader),\n                    \"epoch\": epoch,\n                },\n                step=overall_step,\n            )\n        if checkpointing_steps == \"epoch\":\n            output_dir = f\"epoch_{epoch}\"\n            if args.output_dir is not None:\n                output_dir = os.path.join(args.output_dir, output_dir)\n            accelerator.save_state(output_dir)\n\n    if args.with_tracking:\n        accelerator.end_training()\n\n\ndef main():\n    parser = argparse.ArgumentParser(description=\"Simple example of training script.\")\n    parser.add_argument(\"--data_dir\", required=True, help=\"The data folder on disk.\")\n    parser.add_argument(\"--fp16\", action=\"store_true\", help=\"If passed, will use FP16 training.\")\n    parser.add_argument(\n        \"--mixed_precision\",\n        type=str,\n        default=None,\n        choices=[\"no\", \"fp16\", \"bf16\", \"fp8\"],\n        help=\"Whether to use mixed precision. Choose\"\n        \"between fp16 and bf16 (bfloat16). Bf16 requires PyTorch >= 1.10.\"\n        \"and an Nvidia Ampere GPU.\",\n    )\n    parser.add_argument(\"--cpu\", action=\"store_true\", help=\"If passed, will train on the CPU.\")\n    parser.add_argument(\n        \"--checkpointing_steps\",\n        type=str,\n        default=None,\n        help=\"Whether the various states should be saved at the end of every n steps, or 'epoch' for each epoch.\",\n    )\n    parser.add_argument(\n        \"--output_dir\",\n        type=str,\n        default=\".\",\n        help=\"Optional save directory where all checkpoint folders will be stored. Default is the current working directory.\",\n    )\n    parser.add_argument(\n        \"--resume_from_checkpoint\",\n        type=str,\n        default=None,\n        help=\"If the training should continue from a checkpoint folder.\",\n    )\n    parser.add_argument(\n        \"--with_tracking\",\n        action=\"store_true\",\n        help=\"Whether to load in all available experiment trackers from the environment and use them for logging.\",\n    )\n    parser.add_argument(\n        \"--project_dir\",\n        type=str,\n        default=\"logs\",\n        help=\"Location on where to store experiment tracking logs` and relevent project information\",\n    )\n    args = parser.parse_args()\n    config = {\"lr\": 3e-2, \"num_epochs\": 3, \"seed\": 42, \"batch_size\": 64, \"image_size\": 224}\n    training_function(config, args)\n\n\nif __name__ == \"__main__\":\n    main()\n", "# coding=utf-8\n# Copyright 2021 The HuggingFace Inc. team. All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nimport argparse\n\nimport evaluate\nimport torch\nfrom datasets import load_dataset\nfrom torch.optim import AdamW\nfrom torch.utils.data import DataLoader\nfrom transformers import AutoModelForSequenceClassification, AutoTokenizer, get_linear_schedule_with_warmup, set_seed\n\nfrom accelerate import Accelerator, DistributedType\n\n\n########################################################################\n# This is a fully working simple example to use Accelerate\n#\n# This example trains a Bert base model on GLUE MRPC\n# in any of the following settings (with the same script):\n#   - single CPU or single GPU\n#   - multi GPUS (using PyTorch distributed mode)\n#   - (multi) TPUs\n#   - fp16 (mixed-precision) or fp32 (normal precision)\n#\n# To run it in each of these various modes, follow the instructions\n# in the readme for examples:\n# https://github.com/huggingface/accelerate/tree/main/examples\n#\n########################################################################\n\n\nMAX_GPU_BATCH_SIZE = 16\nEVAL_BATCH_SIZE = 32\n\n\ndef get_dataloaders(accelerator: Accelerator, batch_size: int = 16):\n    \"\"\"\n    Creates a set of `DataLoader`s for the `glue` dataset,\n    using \"bert-base-cased\" as the tokenizer.\n\n    Args:\n        accelerator (`Accelerator`):\n            An `Accelerator` object\n        batch_size (`int`, *optional*):\n            The batch size for the train and validation DataLoaders.\n    \"\"\"\n    tokenizer = AutoTokenizer.from_pretrained(\"bert-base-cased\")\n    datasets = load_dataset(\"glue\", \"mrpc\")\n\n    def tokenize_function(examples):\n        # max_length=None => use the model max length (it's actually the default)\n        outputs = tokenizer(examples[\"sentence1\"], examples[\"sentence2\"], truncation=True, max_length=None)\n        return outputs\n\n    # Apply the method we just defined to all the examples in all the splits of the dataset\n    # starting with the main process first:\n    with accelerator.main_process_first():\n        tokenized_datasets = datasets.map(\n            tokenize_function,\n            batched=True,\n            remove_columns=[\"idx\", \"sentence1\", \"sentence2\"],\n        )\n\n    # We also rename the 'label' column to 'labels' which is the expected name for labels by the models of the\n    # transformers library\n    tokenized_datasets = tokenized_datasets.rename_column(\"label\", \"labels\")\n\n    def collate_fn(examples):\n        # On TPU it's best to pad everything to the same length or training will be very slow.\n        max_length = 128 if accelerator.distributed_type == DistributedType.TPU else None\n        # When using mixed precision we want round multiples of 8/16\n        if accelerator.mixed_precision == \"fp8\":\n            pad_to_multiple_of = 16\n        elif accelerator.mixed_precision != \"no\":\n            pad_to_multiple_of = 8\n        else:\n            pad_to_multiple_of = None\n\n        return tokenizer.pad(\n            examples,\n            padding=\"longest\",\n            max_length=max_length,\n            pad_to_multiple_of=pad_to_multiple_of,\n            return_tensors=\"pt\",\n        )\n\n    # Instantiate dataloaders.\n    train_dataloader = DataLoader(\n        tokenized_datasets[\"train\"], shuffle=True, collate_fn=collate_fn, batch_size=batch_size, drop_last=True\n    )\n    eval_dataloader = DataLoader(\n        tokenized_datasets[\"validation\"],\n        shuffle=False,\n        collate_fn=collate_fn,\n        batch_size=EVAL_BATCH_SIZE,\n        drop_last=(accelerator.mixed_precision == \"fp8\"),\n    )\n\n    return train_dataloader, eval_dataloader\n\n\ndef training_function(config, args):\n    # Initialize accelerator\n    accelerator = Accelerator(cpu=args.cpu, mixed_precision=args.mixed_precision)\n    # Sample hyper-parameters for learning rate, batch size, seed and a few other HPs\n    lr = config[\"lr\"]\n    num_epochs = int(config[\"num_epochs\"])\n    seed = int(config[\"seed\"])\n    batch_size = int(config[\"batch_size\"])\n\n    metric = evaluate.load(\"glue\", \"mrpc\")\n\n    # If the batch size is too big we use gradient accumulation\n    gradient_accumulation_steps = 1\n    if batch_size > MAX_GPU_BATCH_SIZE and accelerator.distributed_type != DistributedType.TPU:\n        gradient_accumulation_steps = batch_size // MAX_GPU_BATCH_SIZE\n        batch_size = MAX_GPU_BATCH_SIZE\n\n    set_seed(seed)\n    train_dataloader, eval_dataloader = get_dataloaders(accelerator, batch_size)\n    # Instantiate the model (we build the model here so that the seed also control new weights initialization)\n    model = AutoModelForSequenceClassification.from_pretrained(\"bert-base-cased\", return_dict=True)\n\n    # We could avoid this line since the accelerator is set with `device_placement=True` (default value).\n    # Note that if you are placing tensors on devices manually, this line absolutely needs to be before the optimizer\n    # creation otherwise training will not work on TPU (`accelerate` will kindly throw an error to make us aware of that).\n    model = model.to(accelerator.device)\n    # Instantiate optimizer\n    optimizer = AdamW(params=model.parameters(), lr=lr)\n\n    # Instantiate scheduler\n    lr_scheduler = get_linear_schedule_with_warmup(\n        optimizer=optimizer,\n        num_warmup_steps=100,\n        num_training_steps=(len(train_dataloader) * num_epochs) // gradient_accumulation_steps,\n    )\n\n    # Prepare everything\n    # There is no specific order to remember, we just need to unpack the objects in the same order we gave them to the\n    # prepare method.\n\n    model, optimizer, train_dataloader, eval_dataloader, lr_scheduler = accelerator.prepare(\n        model, optimizer, train_dataloader, eval_dataloader, lr_scheduler\n    )\n\n    # Now we train the model\n    for epoch in range(num_epochs):\n        model.train()\n        for step, batch in enumerate(train_dataloader):\n            # We could avoid this line since we set the accelerator with `device_placement=True`.\n            batch.to(accelerator.device)\n            outputs = model(**batch)\n            loss = outputs.loss\n            loss = loss / gradient_accumulation_steps\n            accelerator.backward(loss)\n            if step % gradient_accumulation_steps == 0:\n                optimizer.step()\n                lr_scheduler.step()\n                optimizer.zero_grad()\n\n        model.eval()\n        for step, batch in enumerate(eval_dataloader):\n            # We could avoid this line since we set the accelerator with `device_placement=True`.\n            batch.to(accelerator.device)\n            with torch.no_grad():\n                outputs = model(**batch)\n            predictions = outputs.logits.argmax(dim=-1)\n            predictions, references = accelerator.gather_for_metrics((predictions, batch[\"labels\"]))\n            metric.add_batch(\n                predictions=predictions,\n                references=references,\n            )\n\n        eval_metric = metric.compute()\n        # Use accelerator.print to print only on the main process.\n        accelerator.print(f\"epoch {epoch}:\", eval_metric)\n\n\ndef main():\n    parser = argparse.ArgumentParser(description=\"Simple example of training script.\")\n    parser.add_argument(\n        \"--mixed_precision\",\n        type=str,\n        default=None,\n        choices=[\"no\", \"fp16\", \"bf16\", \"fp8\"],\n        help=\"Whether to use mixed precision. Choose\"\n        \"between fp16 and bf16 (bfloat16). Bf16 requires PyTorch >= 1.10.\"\n        \"and an Nvidia Ampere GPU.\",\n    )\n    parser.add_argument(\"--cpu\", action=\"store_true\", help=\"If passed, will train on the CPU.\")\n    args = parser.parse_args()\n    config = {\"lr\": 2e-5, \"num_epochs\": 3, \"seed\": 42, \"batch_size\": 16}\n    training_function(config, args)\n\n\nif __name__ == \"__main__\":\n    main()\n", "# What are these scripts?\n\nAll scripts in this folder originate from the `nlp_example.py` file, as it is a very simplistic NLP training example using Accelerate with zero extra features.\n\nFrom there, each further script adds in just **one** feature of Accelerate, showing how you can quickly modify your own scripts to implement these capabilities.\n\nA full example with all of these parts integrated together can be found in the `complete_nlp_example.py` script and `complete_cv_example.py` script.\n\nAdjustments to each script from the base `nlp_example.py` file can be found quickly by searching for \"# New Code #\"\n\n## Example Scripts by Feature and their Arguments\n\n### Base Example (`../nlp_example.py`)\n\n- Shows how to use `Accelerator` in an extremely simplistic PyTorch training loop\n- Arguments available:\n  - `mixed_precision`, whether to use mixed precision. (\"no\", \"fp16\", or \"bf16\")\n  - `cpu`, whether to train using only the CPU. (yes/no/1/0)\n\nAll following scripts also accept these arguments in addition to their added ones.\n\nThese arguments should be added at the end of any method for starting the python script (such as `python`, `accelerate launch`, `python -m torch.distributed.run`), such as:\n\n```bash\naccelerate launch ../nlp_example.py --mixed_precision fp16 --cpu 0\n```\n\n### Checkpointing and Resuming Training (`checkpointing.py`)\n\n- Shows how to use `Accelerator.save_state` and `Accelerator.load_state` to save or continue training\n- **It is assumed you are continuing off the same training script**\n- Arguments available:\n  - `checkpointing_steps`, after how many steps the various states should be saved. (\"epoch\", 1, 2, ...)\n  - `output_dir`, where saved state folders should be saved to, default is current working directory\n  - `resume_from_checkpoint`, what checkpoint folder to resume from. (\"epoch_0\", \"step_22\", ...)\n\nThese arguments should be added at the end of any method for starting the python script (such as `python`, `accelerate launch`, `python -m torchrun`), such as:\n\n(Note, `resume_from_checkpoint` assumes that we've ran the script for one epoch with the `--checkpointing_steps epoch` flag)\n\n```bash\naccelerate launch ./checkpointing.py --checkpointing_steps epoch output_dir \"checkpointing_tutorial\" --resume_from_checkpoint \"checkpointing_tutorial/epoch_0\"\n```\n\n### Cross Validation (`cross_validation.py`)\n\n- Shows how to use `Accelerator.free_memory` and run cross validation efficiently with `datasets`.\n- Arguments available:\n  - `num_folds`, the number of folds the training dataset should be split into.\n\nThese arguments should be added at the end of any method for starting the python script (such as `python`, `accelerate launch`, `python -m torchrun`), such as:\n\n```bash\naccelerate launch ./cross_validation.py --num_folds 2\n```\n\n### Experiment Tracking (`tracking.py`)\n\n- Shows how to use `Accelerate.init_trackers` and `Accelerator.log`\n- Can be used with Weights and Biases, TensorBoard, or CometML.\n- Arguments available:\n  - `with_tracking`, whether to load in all available experiment trackers from the environment.\n\nThese arguments should be added at the end of any method for starting the python script (such as `python`, `accelerate launch`, `python -m torchrun`), such as:\n\n```bash\naccelerate launch ./tracking.py --with_tracking\n```\n\n### Gradient Accumulation (`gradient_accumulation.py`)\n\n- Shows how to use `Accelerator.no_sync` to prevent gradient averaging in a distributed setup.\n- Arguments available:\n  - `gradient_accumulation_steps`, the number of steps to perform before the gradients are accumulated and the optimizer and scheduler are stepped + zero_grad\n\nThese arguments should be added at the end of any method for starting the python script (such as `python`, `accelerate launch`, `python -m torchrun`), such as:\n\n```bash\naccelerate launch ./gradient_accumulation.py --gradient_accumulation_steps 5\n```\n\n### LocalSGD (`local_sgd.py`)\n- Shows how to use `Accelerator.no_sync` to prevent gradient averaging in a distributed setup. However, unlike gradient accumulation, this method does not change the effective batch size. Local SGD can be combined with gradient accumulation.\n\nThese arguments should be added at the end of any method for starting the python script (such as `python`, `accelerate launch`, `python -m torchrun`), such as:\n\n```bash\naccelerate launch ./local_sgd.py --local_sgd_steps 4\n```\n\n\n", "# coding=utf-8\n# Copyright 2021 The HuggingFace Inc. team. All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nimport argparse\nimport os\n\nimport evaluate\nimport torch\nfrom datasets import load_dataset\nfrom torch.optim import AdamW\nfrom torch.utils.data import DataLoader\nfrom transformers import AutoModelForSequenceClassification, AutoTokenizer, get_linear_schedule_with_warmup, set_seed\n\nfrom accelerate import Accelerator, DistributedType\n\n\n########################################################################\n# This is a fully working simple example to use Accelerate\n# and perform gradient accumulation\n#\n# This example trains a Bert base model on GLUE MRPC\n# in any of the following settings (with the same script):\n#   - single CPU or single GPU\n#   - multi GPUS (using PyTorch distributed mode)\n#   - (multi) TPUs\n#   - fp16 (mixed-precision) or fp32 (normal precision)\n#\n# To run it in each of these various modes, follow the instructions\n# in the readme for examples:\n# https://github.com/huggingface/accelerate/tree/main/examples\n#\n########################################################################\n\n\nMAX_GPU_BATCH_SIZE = 16\nEVAL_BATCH_SIZE = 32\n\n\ndef get_dataloaders(accelerator: Accelerator, batch_size: int = 16):\n    \"\"\"\n    Creates a set of `DataLoader`s for the `glue` dataset,\n    using \"bert-base-cased\" as the tokenizer.\n\n    Args:\n        accelerator (`Accelerator`):\n            An `Accelerator` object\n        batch_size (`int`, *optional*):\n            The batch size for the train and validation DataLoaders.\n    \"\"\"\n    tokenizer = AutoTokenizer.from_pretrained(\"bert-base-cased\")\n    datasets = load_dataset(\"glue\", \"mrpc\")\n\n    def tokenize_function(examples):\n        # max_length=None => use the model max length (it's actually the default)\n        outputs = tokenizer(examples[\"sentence1\"], examples[\"sentence2\"], truncation=True, max_length=None)\n        return outputs\n\n    # Apply the method we just defined to all the examples in all the splits of the dataset\n    # starting with the main process first:\n    with accelerator.main_process_first():\n        tokenized_datasets = datasets.map(\n            tokenize_function,\n            batched=True,\n            remove_columns=[\"idx\", \"sentence1\", \"sentence2\"],\n        )\n\n    # We also rename the 'label' column to 'labels' which is the expected name for labels by the models of the\n    # transformers library\n    tokenized_datasets = tokenized_datasets.rename_column(\"label\", \"labels\")\n\n    def collate_fn(examples):\n        # On TPU it's best to pad everything to the same length or training will be very slow.\n        max_length = 128 if accelerator.distributed_type == DistributedType.TPU else None\n        # When using mixed precision we want round multiples of 8/16\n        if accelerator.mixed_precision == \"fp8\":\n            pad_to_multiple_of = 16\n        elif accelerator.mixed_precision != \"no\":\n            pad_to_multiple_of = 8\n        else:\n            pad_to_multiple_of = None\n\n        return tokenizer.pad(\n            examples,\n            padding=\"longest\",\n            max_length=max_length,\n            pad_to_multiple_of=pad_to_multiple_of,\n            return_tensors=\"pt\",\n        )\n\n    # Instantiate dataloaders.\n    train_dataloader = DataLoader(\n        tokenized_datasets[\"train\"], shuffle=True, collate_fn=collate_fn, batch_size=batch_size\n    )\n    eval_dataloader = DataLoader(\n        tokenized_datasets[\"validation\"], shuffle=False, collate_fn=collate_fn, batch_size=EVAL_BATCH_SIZE\n    )\n\n    return train_dataloader, eval_dataloader\n\n\n# For testing only\nif os.environ.get(\"TESTING_MOCKED_DATALOADERS\", None) == \"1\":\n    from accelerate.test_utils.training import mocked_dataloaders\n\n    get_dataloaders = mocked_dataloaders  # noqa: F811\n\n\ndef training_function(config, args):\n    # For testing only\n    if os.environ.get(\"TESTING_MOCKED_DATALOADERS\", None) == \"1\":\n        config[\"num_epochs\"] = 2\n    # New Code #\n    gradient_accumulation_steps = int(args.gradient_accumulation_steps)\n    # Initialize accelerator\n    accelerator = Accelerator(\n        cpu=args.cpu, mixed_precision=args.mixed_precision, gradient_accumulation_steps=gradient_accumulation_steps\n    )\n    if accelerator.distributed_type == DistributedType.TPU and gradient_accumulation_steps > 1:\n        raise NotImplementedError(\n            \"Gradient accumulation on TPUs is currently not supported. Pass `gradient_accumulation_steps=1`\"\n        )\n    # Sample hyper-parameters for learning rate, batch size, seed and a few other HPs\n    lr = config[\"lr\"]\n    num_epochs = int(config[\"num_epochs\"])\n    seed = int(config[\"seed\"])\n    batch_size = int(config[\"batch_size\"])\n\n    metric = evaluate.load(\"glue\", \"mrpc\")\n\n    set_seed(seed)\n    train_dataloader, eval_dataloader = get_dataloaders(accelerator, batch_size)\n    # Instantiate the model (we build the model here so that the seed also control new weights initialization)\n    model = AutoModelForSequenceClassification.from_pretrained(\"bert-base-cased\", return_dict=True)\n\n    # We could avoid this line since the accelerator is set with `device_placement=True` (default value).\n    # Note that if you are placing tensors on devices manually, this line absolutely needs to be before the optimizer\n    # creation otherwise training will not work on TPU (`accelerate` will kindly throw an error to make us aware of that).\n    model = model.to(accelerator.device)\n\n    # Instantiate optimizer\n    optimizer = AdamW(params=model.parameters(), lr=lr)\n\n    # Instantiate scheduler\n    lr_scheduler = get_linear_schedule_with_warmup(\n        optimizer=optimizer,\n        num_warmup_steps=100,\n        num_training_steps=(len(train_dataloader) * num_epochs),\n    )\n\n    # Prepare everything\n    # There is no specific order to remember, we just need to unpack the objects in the same order we gave them to the\n    # prepare method.\n    model, optimizer, train_dataloader, eval_dataloader, lr_scheduler = accelerator.prepare(\n        model, optimizer, train_dataloader, eval_dataloader, lr_scheduler\n    )\n\n    # Now we train the model\n    for epoch in range(num_epochs):\n        model.train()\n        for step, batch in enumerate(train_dataloader):\n            # We could avoid this line since we set the accelerator with `device_placement=True`.\n            batch.to(accelerator.device)\n            # New code #\n            # We use the new `accumulate` context manager to perform gradient accumulation\n            # We also currently do not support TPUs nor advise it as bugs were found on the XLA side when running our tests.\n            with accelerator.accumulate(model):\n                output = model(**batch)\n                loss = output.loss\n                accelerator.backward(loss)\n                optimizer.step()\n                lr_scheduler.step()\n                optimizer.zero_grad()\n\n        model.eval()\n        for step, batch in enumerate(eval_dataloader):\n            # We could avoid this line since we set the accelerator with `device_placement=True`.\n            batch.to(accelerator.device)\n            with torch.no_grad():\n                outputs = model(**batch)\n            predictions = outputs.logits.argmax(dim=-1)\n            predictions, references = accelerator.gather_for_metrics((predictions, batch[\"labels\"]))\n            metric.add_batch(\n                predictions=predictions,\n                references=references,\n            )\n\n        eval_metric = metric.compute()\n        # Use accelerator.print to print only on the main process.\n        accelerator.print(f\"epoch {epoch}:\", eval_metric)\n\n\ndef main():\n    parser = argparse.ArgumentParser(description=\"Simple example of training script.\")\n    parser.add_argument(\n        \"--mixed_precision\",\n        type=str,\n        default=None,\n        choices=[\"no\", \"fp16\", \"bf16\", \"fp8\"],\n        help=\"Whether to use mixed precision. Choose\"\n        \"between fp16 and bf16 (bfloat16). Bf16 requires PyTorch >= 1.10.\"\n        \"and an Nvidia Ampere GPU.\",\n    )\n    # New Code #\n    parser.add_argument(\n        \"--gradient_accumulation_steps\",\n        type=int,\n        default=1,\n        help=\"The number of minibatches to be ran before gradients are accumulated.\",\n    )\n    parser.add_argument(\"--cpu\", action=\"store_true\", help=\"If passed, will train on the CPU.\")\n    args = parser.parse_args()\n    config = {\"lr\": 2e-5, \"num_epochs\": 3, \"seed\": 42, \"batch_size\": 16}\n    training_function(config, args)\n\n\nif __name__ == \"__main__\":\n    main()\n", "# Copyright 2022 The HuggingFace Team. All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nimport argparse\nimport os\n\n# New Code #\nimport evaluate\nimport torch\nfrom datasets import load_dataset\nfrom torch.optim import AdamW\nfrom torch.utils.data import DataLoader\nfrom transformers import AutoModelForSequenceClassification, AutoTokenizer, get_linear_schedule_with_warmup, set_seed\n\nfrom accelerate import Accelerator, DistributedType\nfrom accelerate.utils import find_executable_batch_size\n\n\n########################################################################\n# This is a fully working simple example to use Accelerate,\n# specifically showcasing how to ensure out-of-memory errors never\n# interrupt training, and builds off the `nlp_example.py` script.\n#\n# This example trains a Bert base model on GLUE MRPC\n# in any of the following settings (with the same script):\n#   - single CPU or single GPU\n#   - multi GPUS (using PyTorch distributed mode)\n#   - (multi) TPUs\n#   - fp16 (mixed-precision) or fp32 (normal precision)\n#\n# New additions from the base script can be found quickly by\n# looking for the # New Code # tags\n#\n# To run it in each of these various modes, follow the instructions\n# in the readme for examples:\n# https://github.com/huggingface/accelerate/tree/main/examples\n#\n########################################################################\n\n\nMAX_GPU_BATCH_SIZE = 16\nEVAL_BATCH_SIZE = 32\n\n\ndef get_dataloaders(accelerator: Accelerator, batch_size: int = 16):\n    \"\"\"\n    Creates a set of `DataLoader`s for the `glue` dataset,\n    using \"bert-base-cased\" as the tokenizer.\n\n    Args:\n        accelerator (`Accelerator`):\n            An `Accelerator` object\n        batch_size (`int`, *optional*):\n            The batch size for the train and validation DataLoaders.\n    \"\"\"\n    tokenizer = AutoTokenizer.from_pretrained(\"bert-base-cased\")\n    datasets = load_dataset(\"glue\", \"mrpc\")\n\n    def tokenize_function(examples):\n        # max_length=None => use the model max length (it's actually the default)\n        outputs = tokenizer(examples[\"sentence1\"], examples[\"sentence2\"], truncation=True, max_length=None)\n        return outputs\n\n    # Apply the method we just defined to all the examples in all the splits of the dataset\n    # starting with the main process first:\n    with accelerator.main_process_first():\n        tokenized_datasets = datasets.map(\n            tokenize_function,\n            batched=True,\n            remove_columns=[\"idx\", \"sentence1\", \"sentence2\"],\n        )\n\n    # We also rename the 'label' column to 'labels' which is the expected name for labels by the models of the\n    # transformers library\n    tokenized_datasets = tokenized_datasets.rename_column(\"label\", \"labels\")\n\n    def collate_fn(examples):\n        # On TPU it's best to pad everything to the same length or training will be very slow.\n        max_length = 128 if accelerator.distributed_type == DistributedType.TPU else None\n        # When using mixed precision we want round multiples of 8/16\n        if accelerator.mixed_precision == \"fp8\":\n            pad_to_multiple_of = 16\n        elif accelerator.mixed_precision != \"no\":\n            pad_to_multiple_of = 8\n        else:\n            pad_to_multiple_of = None\n\n        return tokenizer.pad(\n            examples,\n            padding=\"longest\",\n            max_length=max_length,\n            pad_to_multiple_of=pad_to_multiple_of,\n            return_tensors=\"pt\",\n        )\n\n    # Instantiate dataloaders.\n    train_dataloader = DataLoader(\n        tokenized_datasets[\"train\"], shuffle=True, collate_fn=collate_fn, batch_size=batch_size\n    )\n    eval_dataloader = DataLoader(\n        tokenized_datasets[\"validation\"], shuffle=False, collate_fn=collate_fn, batch_size=EVAL_BATCH_SIZE\n    )\n\n    return train_dataloader, eval_dataloader\n\n\n# For testing only\nif os.environ.get(\"TESTING_MOCKED_DATALOADERS\", None) == \"1\":\n    from accelerate.test_utils.training import mocked_dataloaders\n\n    get_dataloaders = mocked_dataloaders  # noqa: F811\n\n\ndef training_function(config, args):\n    # For testing only\n    if os.environ.get(\"TESTING_MOCKED_DATALOADERS\", None) == \"1\":\n        config[\"num_epochs\"] = 2\n    # Initialize accelerator\n    accelerator = Accelerator(cpu=args.cpu, mixed_precision=args.mixed_precision)\n    # Sample hyper-parameters for learning rate, batch size, seed and a few other HPs\n    lr = config[\"lr\"]\n    num_epochs = int(config[\"num_epochs\"])\n    seed = int(config[\"seed\"])\n    batch_size = int(config[\"batch_size\"])\n\n    metric = evaluate.load(\"glue\", \"mrpc\")\n\n    # New Code #\n    # We now can define an inner training loop function. It should take a batch size as the only parameter,\n    # and build the dataloaders in there.\n    # It also gets our decorator\n    @find_executable_batch_size(starting_batch_size=batch_size)\n    def inner_training_loop(batch_size):\n        # And now just move everything below under this function\n        # We need to bring in the Accelerator object from earlier\n        nonlocal accelerator\n        # And reset all of its attributes that could hold onto any memory:\n        accelerator.free_memory()\n\n        # Then we can declare the model, optimizer, and everything else:\n        set_seed(seed)\n\n        # Instantiate the model (we build the model here so that the seed also control new weights initialization)\n        model = AutoModelForSequenceClassification.from_pretrained(\"bert-base-cased\", return_dict=True)\n\n        # We could avoid this line since the accelerator is set with `device_placement=True` (default value).\n        # Note that if you are placing tensors on devices manually, this line absolutely needs to be before the optimizer\n        # creation otherwise training will not work on TPU (`accelerate` will kindly throw an error to make us aware of that).\n        model = model.to(accelerator.device)\n\n        # Instantiate optimizer\n        optimizer = AdamW(params=model.parameters(), lr=lr)\n        train_dataloader, eval_dataloader = get_dataloaders(accelerator, batch_size)\n\n        # Instantiate scheduler\n        lr_scheduler = get_linear_schedule_with_warmup(\n            optimizer=optimizer,\n            num_warmup_steps=100,\n            num_training_steps=(len(train_dataloader) * num_epochs),\n        )\n\n        # Prepare everything\n        # There is no specific order to remember, we just need to unpack the objects in the same order we gave them to the\n        # prepare method.\n        model, optimizer, train_dataloader, eval_dataloader, lr_scheduler = accelerator.prepare(\n            model, optimizer, train_dataloader, eval_dataloader, lr_scheduler\n        )\n\n        # Now we train the model\n        for epoch in range(num_epochs):\n            model.train()\n            for step, batch in enumerate(train_dataloader):\n                # We could avoid this line since we set the accelerator with `device_placement=True`.\n                batch.to(accelerator.device)\n                outputs = model(**batch)\n                loss = outputs.loss\n                accelerator.backward(loss)\n                optimizer.step()\n                lr_scheduler.step()\n                optimizer.zero_grad()\n\n            model.eval()\n            for step, batch in enumerate(eval_dataloader):\n                # We could avoid this line since we set the accelerator with `device_placement=True`.\n                batch.to(accelerator.device)\n                with torch.no_grad():\n                    outputs = model(**batch)\n                predictions = outputs.logits.argmax(dim=-1)\n                predictions, references = accelerator.gather_for_metrics((predictions, batch[\"labels\"]))\n                metric.add_batch(\n                    predictions=predictions,\n                    references=references,\n                )\n\n            eval_metric = metric.compute()\n            # Use accelerator.print to print only on the main process.\n            accelerator.print(f\"epoch {epoch}:\", eval_metric)\n\n    # New Code #\n    # And call it at the end with no arguments\n    # Note: You could also refactor this outside of your training loop function\n    inner_training_loop()\n\n\ndef main():\n    parser = argparse.ArgumentParser(description=\"Simple example of training script.\")\n    parser.add_argument(\n        \"--mixed_precision\",\n        type=str,\n        default=None,\n        choices=[\"no\", \"fp16\", \"bf16\", \"fp8\"],\n        help=\"Whether to use mixed precision. Choose\"\n        \"between fp16 and bf16 (bfloat16). Bf16 requires PyTorch >= 1.10.\"\n        \"and an Nvidia Ampere GPU.\",\n    )\n    parser.add_argument(\"--cpu\", action=\"store_true\", help=\"If passed, will train on the CPU.\")\n    args = parser.parse_args()\n    config = {\"lr\": 2e-5, \"num_epochs\": 3, \"seed\": 42, \"batch_size\": 16}\n    training_function(config, args)\n\n\nif __name__ == \"__main__\":\n    main()\n", "# coding=utf-8\n# Copyright 2022 The HuggingFace Inc. team. All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nimport argparse\nfrom typing import List\n\nimport evaluate\nimport numpy as np\nimport torch\nfrom datasets import DatasetDict, load_dataset\n\n# New Code #\n# We'll be using StratifiedKFold for this example\nfrom sklearn.model_selection import StratifiedKFold\nfrom torch.optim import AdamW\nfrom torch.utils.data import DataLoader\nfrom transformers import AutoModelForSequenceClassification, AutoTokenizer, get_linear_schedule_with_warmup, set_seed\n\nfrom accelerate import Accelerator, DistributedType\n\n\n########################################################################\n# This is a fully working simple example to use Accelerate,\n# specifically showcasing how to perform Cross Validation,\n# and builds off the `nlp_example.py` script.\n#\n# This example trains a Bert base model on GLUE MRPC\n# in any of the following settings (with the same script):\n#   - single CPU or single GPU\n#   - multi GPUS (using PyTorch distributed mode)\n#   - (multi) TPUs\n#   - fp16 (mixed-precision) or fp32 (normal precision)\n#\n# To help focus on the differences in the code, building `DataLoaders`\n# was refactored into its own function.\n# New additions from the base script can be found quickly by\n# looking for the # New Code # tags\n#\n# To run it in each of these various modes, follow the instructions\n# in the readme for examples:\n# https://github.com/huggingface/accelerate/tree/main/examples\n#\n########################################################################\n\n\nMAX_GPU_BATCH_SIZE = 16\nEVAL_BATCH_SIZE = 32\n\n# New Code #\n# We need a different `get_dataloaders` function that will build dataloaders by index\n\n\ndef get_fold_dataloaders(\n    accelerator: Accelerator, dataset: DatasetDict, train_idxs: List[int], valid_idxs: List[int], batch_size: int = 16\n):\n    \"\"\"\n    Gets a set of train, valid, and test dataloaders for a particular fold\n\n    Args:\n        accelerator (`Accelerator`):\n            The main `Accelerator` object\n        train_idxs (list of `int`):\n            The split indices for the training dataset\n        valid_idxs (list of `int`):\n            The split indices for the validation dataset\n        batch_size (`int`):\n            The size of the minibatch. Default is 16\n    \"\"\"\n    tokenizer = AutoTokenizer.from_pretrained(\"bert-base-cased\")\n    datasets = DatasetDict(\n        {\n            \"train\": dataset[\"train\"].select(train_idxs),\n            \"validation\": dataset[\"train\"].select(valid_idxs),\n            \"test\": dataset[\"validation\"],\n        }\n    )\n\n    def tokenize_function(examples):\n        # max_length=None => use the model max length (it's actually the default)\n        outputs = tokenizer(examples[\"sentence1\"], examples[\"sentence2\"], truncation=True, max_length=None)\n        return outputs\n\n    # Apply the method we just defined to all the examples in all the splits of the dataset\n    # starting with the main process first:\n    with accelerator.main_process_first():\n        tokenized_datasets = datasets.map(\n            tokenize_function,\n            batched=True,\n            remove_columns=[\"idx\", \"sentence1\", \"sentence2\"],\n        )\n\n    # We also rename the 'label' column to 'labels' which is the expected name for labels by the models of the\n    # transformers library\n    tokenized_datasets = tokenized_datasets.rename_column(\"label\", \"labels\")\n\n    def collate_fn(examples):\n        # On TPU it's best to pad everything to the same length or training will be very slow.\n        max_length = 128 if accelerator.distributed_type == DistributedType.TPU else None\n        # When using mixed precision we want round multiples of 8/16\n        if accelerator.mixed_precision == \"fp8\":\n            pad_to_multiple_of = 16\n        elif accelerator.mixed_precision != \"no\":\n            pad_to_multiple_of = 8\n        else:\n            pad_to_multiple_of = None\n\n        return tokenizer.pad(\n            examples,\n            padding=\"longest\",\n            max_length=max_length,\n            pad_to_multiple_of=pad_to_multiple_of,\n            return_tensors=\"pt\",\n        )\n\n    # Instantiate dataloaders.\n    train_dataloader = DataLoader(\n        tokenized_datasets[\"train\"], shuffle=True, collate_fn=collate_fn, batch_size=batch_size\n    )\n    eval_dataloader = DataLoader(\n        tokenized_datasets[\"validation\"], shuffle=False, collate_fn=collate_fn, batch_size=EVAL_BATCH_SIZE\n    )\n\n    test_dataloader = DataLoader(\n        tokenized_datasets[\"test\"], shuffle=False, collate_fn=collate_fn, batch_size=EVAL_BATCH_SIZE\n    )\n\n    return train_dataloader, eval_dataloader, test_dataloader\n\n\ndef training_function(config, args):\n    # New Code #\n    test_predictions = []\n    # Download the dataset\n    datasets = load_dataset(\"glue\", \"mrpc\")\n    # Create our splits\n    kfold = StratifiedKFold(n_splits=int(args.num_folds))\n    # Initialize accelerator\n    accelerator = Accelerator(cpu=args.cpu, mixed_precision=args.mixed_precision)\n    # Sample hyper-parameters for learning rate, batch size, seed and a few other HPs\n    lr = config[\"lr\"]\n    num_epochs = int(config[\"num_epochs\"])\n    seed = int(config[\"seed\"])\n    batch_size = int(config[\"batch_size\"])\n\n    metric = evaluate.load(\"glue\", \"mrpc\")\n\n    # If the batch size is too big we use gradient accumulation\n    gradient_accumulation_steps = 1\n    if batch_size > MAX_GPU_BATCH_SIZE and accelerator.distributed_type != DistributedType.TPU:\n        gradient_accumulation_steps = batch_size // MAX_GPU_BATCH_SIZE\n        batch_size = MAX_GPU_BATCH_SIZE\n\n    set_seed(seed)\n\n    # New Code #\n    # Create our folds:\n    folds = kfold.split(np.zeros(datasets[\"train\"].num_rows), datasets[\"train\"][\"label\"])\n    test_references = []\n    # Iterate over them\n    for i, (train_idxs, valid_idxs) in enumerate(folds):\n        train_dataloader, eval_dataloader, test_dataloader = get_fold_dataloaders(\n            accelerator,\n            datasets,\n            train_idxs,\n            valid_idxs,\n        )\n        # Instantiate the model (we build the model here so that the seed also control new weights initialization)\n        model = AutoModelForSequenceClassification.from_pretrained(\"bert-base-cased\", return_dict=True)\n\n        # We could avoid this line since the accelerator is set with `device_placement=True` (default value).\n        # Note that if you are placing tensors on devices manually, this line absolutely needs to be before the optimizer\n        # creation otherwise training will not work on TPU (`accelerate` will kindly throw an error to make us aware of that).\n        model = model.to(accelerator.device)\n\n        # Instantiate optimizer\n        optimizer = AdamW(params=model.parameters(), lr=lr)\n\n        # Instantiate scheduler\n        lr_scheduler = get_linear_schedule_with_warmup(\n            optimizer=optimizer,\n            num_warmup_steps=100,\n            num_training_steps=(len(train_dataloader) * num_epochs) // gradient_accumulation_steps,\n        )\n\n        # Prepare everything\n        # There is no specific order to remember, we just need to unpack the objects in the same order we gave them to the\n        # prepare method.\n        model, optimizer, train_dataloader, eval_dataloader, lr_scheduler = accelerator.prepare(\n            model, optimizer, train_dataloader, eval_dataloader, lr_scheduler\n        )\n\n        # Now we train the model\n        for epoch in range(num_epochs):\n            model.train()\n            for step, batch in enumerate(train_dataloader):\n                # We could avoid this line since we set the accelerator with `device_placement=True`.\n                batch.to(accelerator.device)\n                outputs = model(**batch)\n                loss = outputs.loss\n                loss = loss / gradient_accumulation_steps\n                accelerator.backward(loss)\n                if step % gradient_accumulation_steps == 0:\n                    optimizer.step()\n                    lr_scheduler.step()\n                    optimizer.zero_grad()\n\n            model.eval()\n            for step, batch in enumerate(eval_dataloader):\n                # We could avoid this line since we set the accelerator with `device_placement=True`.\n                batch.to(accelerator.device)\n                with torch.no_grad():\n                    outputs = model(**batch)\n                predictions = outputs.logits.argmax(dim=-1)\n                predictions, references = accelerator.gather_for_metrics((predictions, batch[\"labels\"]))\n                metric.add_batch(\n                    predictions=predictions,\n                    references=references,\n                )\n\n            eval_metric = metric.compute()\n            # Use accelerator.print to print only on the main process.\n            accelerator.print(f\"epoch {epoch}:\", eval_metric)\n\n        # New Code #\n        # We also run predictions on the test set at the very end\n        fold_predictions = []\n        for step, batch in enumerate(test_dataloader):\n            # We could avoid this line since we set the accelerator with `device_placement=True`.\n            batch.to(accelerator.device)\n            with torch.no_grad():\n                outputs = model(**batch)\n            predictions = outputs.logits\n            predictions, references = accelerator.gather_for_metrics((predictions, batch[\"labels\"]))\n            fold_predictions.append(predictions.cpu())\n            if i == 0:\n                # We need all of the test predictions\n                test_references.append(references.cpu())\n        # Use accelerator.print to print only on the main process.\n        test_predictions.append(torch.cat(fold_predictions, dim=0))\n        # We now need to release all our memory and get rid of the current model, optimizer, etc\n        accelerator.free_memory()\n    # New Code #\n    # Finally we check the accuracy of our folded results:\n    test_references = torch.cat(test_references, dim=0)\n    preds = torch.stack(test_predictions, dim=0).sum(dim=0).div(int(args.num_folds)).argmax(dim=-1)\n    test_metric = metric.compute(predictions=preds, references=test_references)\n    accelerator.print(\"Average test metrics from all folds:\", test_metric)\n\n\ndef main():\n    parser = argparse.ArgumentParser(description=\"Simple example of training script.\")\n    parser.add_argument(\n        \"--mixed_precision\",\n        type=str,\n        default=None,\n        choices=[\"no\", \"fp16\", \"bf16\", \"fp8\"],\n        help=\"Whether to use mixed precision. Choose\"\n        \"between fp16 and bf16 (bfloat16). Bf16 requires PyTorch >= 1.10.\"\n        \"and an Nvidia Ampere GPU.\",\n    )\n    parser.add_argument(\"--cpu\", action=\"store_true\", help=\"If passed, will train on the CPU.\")\n    # New Code #\n    parser.add_argument(\"--num_folds\", type=int, default=3, help=\"The number of splits to perform across the dataset\")\n    args = parser.parse_args()\n    config = {\"lr\": 2e-5, \"num_epochs\": 3, \"seed\": 42, \"batch_size\": 16}\n    training_function(config, args)\n\n\nif __name__ == \"__main__\":\n    main()\n", "# Copyright 2022 The HuggingFace Team. All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nimport argparse\nimport os\n\n# New Code #\nimport evaluate\nimport torch\nfrom datasets import load_dataset\nfrom torch.optim import AdamW\nfrom torch.utils.data import DataLoader\nfrom transformers import AutoModelForSequenceClassification, AutoTokenizer, get_linear_schedule_with_warmup, set_seed\n\nfrom accelerate import Accelerator\nfrom accelerate.utils import find_executable_batch_size\n\n\n########################################################################\n# This is a fully working simple example to use Accelerate,\n# specifically showcasing how to combine both the gradient accumulation\n# and automatic batch size finder utilities of Accelerate to perfrom\n# automatic gradient accumulation\n#\n# This example trains a Bert base model on GLUE MRPC\n# in any of the following settings (with the same script):\n#   - single CPU or single GPU\n#   - multi GPUS (using PyTorch distributed mode)\n#   - (multi) TPUs\n#   - fp16 (mixed-precision) or fp32 (normal precision)\n#\n# New additions from the base script can be found quickly by\n# looking for the # New Code # tags\n#\n# To run it in each of these various modes, follow the instructions\n# in the readme for examples:\n# https://github.com/huggingface/accelerate/tree/main/examples\n#\n########################################################################\n\nEVAL_BATCH_SIZE = 32\n\n\ndef get_dataloaders(accelerator: Accelerator, batch_size: int = 16):\n    \"\"\"\n    Creates a set of `DataLoader`s for the `glue` dataset,\n    using \"bert-base-cased\" as the tokenizer.\n\n    Args:\n        accelerator (`Accelerator`):\n            An `Accelerator` object\n        batch_size (`int`, *optional*):\n            The batch size for the train and validation DataLoaders.\n    \"\"\"\n    tokenizer = AutoTokenizer.from_pretrained(\"bert-base-cased\")\n    datasets = load_dataset(\"glue\", \"mrpc\")\n\n    def tokenize_function(examples):\n        # max_length=None => use the model max length (it's actually the default)\n        outputs = tokenizer(examples[\"sentence1\"], examples[\"sentence2\"], truncation=True, max_length=None)\n        return outputs\n\n    # Apply the method we just defined to all the examples in all the splits of the dataset\n    # starting with the main process first:\n    with accelerator.main_process_first():\n        tokenized_datasets = datasets.map(\n            tokenize_function,\n            batched=True,\n            remove_columns=[\"idx\", \"sentence1\", \"sentence2\"],\n        )\n\n    # We also rename the 'label' column to 'labels' which is the expected name for labels by the models of the\n    # transformers library\n    tokenized_datasets = tokenized_datasets.rename_column(\"label\", \"labels\")\n\n    def collate_fn(examples):\n        # When using mixed precision we want round multiples of 8/16\n        if accelerator.mixed_precision == \"fp8\":\n            pad_to_multiple_of = 16\n        elif accelerator.mixed_precision != \"no\":\n            pad_to_multiple_of = 8\n        else:\n            pad_to_multiple_of = None\n\n        return tokenizer.pad(\n            examples,\n            padding=\"longest\",\n            pad_to_multiple_of=pad_to_multiple_of,\n            return_tensors=\"pt\",\n        )\n\n    # Instantiate dataloaders.\n    train_dataloader = DataLoader(\n        tokenized_datasets[\"train\"], shuffle=True, collate_fn=collate_fn, batch_size=batch_size\n    )\n    eval_dataloader = DataLoader(\n        tokenized_datasets[\"validation\"], shuffle=False, collate_fn=collate_fn, batch_size=EVAL_BATCH_SIZE\n    )\n\n    return train_dataloader, eval_dataloader\n\n\n# For testing only\nif os.environ.get(\"TESTING_MOCKED_DATALOADERS\", None) == \"1\":\n    from accelerate.test_utils.training import mocked_dataloaders\n\n    get_dataloaders = mocked_dataloaders  # noqa: F811\n\n\ndef training_function(config, args):\n    # For testing only\n    if os.environ.get(\"TESTING_MOCKED_DATALOADERS\", None) == \"1\":\n        config[\"num_epochs\"] = 2\n    # Initialize accelerator\n    accelerator = Accelerator(cpu=args.cpu, mixed_precision=args.mixed_precision)\n    # Sample hyper-parameters for learning rate, batch size, seed and a few other HPs\n    lr = config[\"lr\"]\n    num_epochs = int(config[\"num_epochs\"])\n    seed = int(config[\"seed\"])\n    observed_batch_size = int(config[\"batch_size\"])\n\n    metric = evaluate.load(\"glue\", \"mrpc\")\n\n    # New Code #\n    # We use the `find_executable_batch_size` decorator, passing in the desired observed batch size\n    # to train on. If a CUDA OOM error occurs, it will retry this loop cutting the batch size in\n    # half each time. From this, we can calculate the number of gradient accumulation steps needed\n    # and modify the Accelerator object as a result\n    @find_executable_batch_size(starting_batch_size=int(observed_batch_size))\n    def inner_training_loop(batch_size):\n        # Since we need to modify the outside accelerator object, we need to bring it\n        # to the local scope\n        nonlocal accelerator\n\n        # We can calculate the number of gradient accumulation steps based on the current\n        # batch size vs the starting batch size\n        num_gradient_accumulation_steps = observed_batch_size // batch_size\n\n        # And then set it in the Accelerator directly:\n        accelerator.gradient_accumulation_steps = num_gradient_accumulation_steps\n\n        # Next we need to free all of the stored model references in the Accelerator each time\n        accelerator.free_memory()\n\n        # And set the seed so our results are reproducable each reset\n        set_seed(seed)\n\n        # Instantiate the model (we build the model here so that the seed also control new weights initialization)\n        model = AutoModelForSequenceClassification.from_pretrained(\"bert-base-cased\", return_dict=True)\n\n        # We could avoid this line since the accelerator is set with `device_placement=True` (default value).\n        # Note that if you are placing tensors on devices manually, this line absolutely needs to be before the optimizer\n        # creation otherwise training will not work on TPU (`accelerate` will kindly throw an error to make us aware of that).\n        model = model.to(accelerator.device)\n\n        # Instantiate optimizer\n        optimizer = AdamW(params=model.parameters(), lr=lr)\n        train_dataloader, eval_dataloader = get_dataloaders(accelerator, batch_size)\n\n        # Instantiate scheduler\n        lr_scheduler = get_linear_schedule_with_warmup(\n            optimizer=optimizer,\n            num_warmup_steps=100,\n            num_training_steps=(len(train_dataloader) * num_epochs),\n        )\n\n        # Prepare everything\n        # There is no specific order to remember, we just need to unpack the objects in the same order we gave them to the\n        # prepare method.\n        model, optimizer, train_dataloader, eval_dataloader, lr_scheduler = accelerator.prepare(\n            model, optimizer, train_dataloader, eval_dataloader, lr_scheduler\n        )\n\n        # Now we train the model\n        for epoch in range(num_epochs):\n            model.train()\n            for step, batch in enumerate(train_dataloader):\n                # And perform gradient accumulation\n                with accelerator.accumulate(model):\n                    # We could avoid this line since we set the accelerator with `device_placement=True`.\n                    batch.to(accelerator.device)\n                    outputs = model(**batch)\n                    loss = outputs.loss\n                    accelerator.backward(loss)\n                    optimizer.step()\n                    lr_scheduler.step()\n                    optimizer.zero_grad()\n\n            model.eval()\n            for step, batch in enumerate(eval_dataloader):\n                # We could avoid this line since we set the accelerator with `device_placement=True`.\n                batch.to(accelerator.device)\n                with torch.no_grad():\n                    outputs = model(**batch)\n                predictions = outputs.logits.argmax(dim=-1)\n                predictions, references = accelerator.gather_for_metrics((predictions, batch[\"labels\"]))\n                metric.add_batch(\n                    predictions=predictions,\n                    references=references,\n                )\n\n            eval_metric = metric.compute()\n            # Use accelerator.print to print only on the main process.\n            accelerator.print(f\"epoch {epoch}:\", eval_metric)\n\n    # New Code #\n    # And call it at the end with no arguments\n    # Note: You could also refactor this outside of your training loop function\n    inner_training_loop()\n\n\ndef main():\n    parser = argparse.ArgumentParser(description=\"Simple example of training script.\")\n    parser.add_argument(\n        \"--mixed_precision\",\n        type=str,\n        default=None,\n        choices=[\"no\", \"fp16\", \"bf16\", \"fp8\"],\n        help=\"Whether to use mixed precision. Choose\"\n        \"between fp16 and bf16 (bfloat16). Bf16 requires PyTorch >= 1.10.\"\n        \"and an Nvidia Ampere GPU.\",\n    )\n    parser.add_argument(\"--cpu\", action=\"store_true\", help=\"If passed, will train on the CPU.\")\n    args = parser.parse_args()\n    # New Code #\n    # We modify the starting batch size to be an observed batch size of 256, to guarentee an initial CUDA OOM\n    config = {\"lr\": 2e-5, \"num_epochs\": 3, \"seed\": 42, \"batch_size\": 256}\n    training_function(config, args)\n\n\nif __name__ == \"__main__\":\n    main()\n", "#!/usr/bin/env python\n# coding=utf-8\n# Copyright 2022 The HuggingFace Inc. team. All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\"\"\"\nFine-tuning the library models for causal language modeling (GPT, GPT-2, CTRL, ...)\non a text file or a dataset without using HuggingFace Trainer.\n\nHere is the full list of checkpoints on the hub that can be fine-tuned by this script:\nhttps://huggingface.co/models?filter=text-generation\n\"\"\"\n# You can also adapt this script on your own causal language modeling task. Pointers for this are left as comments.\n\nimport argparse\nimport json\nimport logging\nimport math\nimport os\nimport random\nfrom itertools import chain\nfrom pathlib import Path\n\nimport datasets\nimport torch\nimport transformers\nfrom datasets import load_dataset\nfrom huggingface_hub import Repository\nfrom torch.utils.data import DataLoader\nfrom tqdm.auto import tqdm\nfrom transformers import (\n    CONFIG_MAPPING,\n    MODEL_MAPPING,\n    AutoConfig,\n    AutoModelForCausalLM,\n    AutoTokenizer,\n    SchedulerType,\n    default_data_collator,\n    get_scheduler,\n)\nfrom transformers.utils import get_full_repo_name\nfrom transformers.utils.versions import require_version\n\nfrom accelerate import Accelerator, DistributedType\nfrom accelerate.logging import get_logger\nfrom accelerate.utils import DummyOptim, DummyScheduler, set_seed\n\n\nlogger = get_logger(__name__)\n\nrequire_version(\"datasets>=1.8.0\", \"To fix: pip install -r examples/pytorch/language-modeling/requirements.txt\")\n\nMODEL_CONFIG_CLASSES = list(MODEL_MAPPING.keys())\nMODEL_TYPES = tuple(conf.model_type for conf in MODEL_CONFIG_CLASSES)\n\n\ndef parse_args():\n    parser = argparse.ArgumentParser(description=\"Finetune a transformers model on a causal language modeling task\")\n    parser.add_argument(\n        \"--dataset_name\",\n        type=str,\n        default=None,\n        help=\"The name of the dataset to use (via the datasets library).\",\n    )\n    parser.add_argument(\n        \"--dataset_config_name\",\n        type=str,\n        default=None,\n        help=\"The configuration name of the dataset to use (via the datasets library).\",\n    )\n    parser.add_argument(\n        \"--train_file\", type=str, default=None, help=\"A csv or a json file containing the training data.\"\n    )\n    parser.add_argument(\n        \"--validation_file\", type=str, default=None, help=\"A csv or a json file containing the validation data.\"\n    )\n    parser.add_argument(\n        \"--validation_split_percentage\",\n        default=5,\n        help=\"The percentage of the train set used as validation set in case there's no validation split\",\n    )\n    parser.add_argument(\n        \"--model_name_or_path\",\n        type=str,\n        help=\"Path to pretrained model or model identifier from huggingface.co/models.\",\n        required=False,\n    )\n    parser.add_argument(\n        \"--config_name\",\n        type=str,\n        default=None,\n        help=\"Pretrained config name or path if not the same as model_name\",\n    )\n    parser.add_argument(\n        \"--tokenizer_name\",\n        type=str,\n        default=None,\n        help=\"Pretrained tokenizer name or path if not the same as model_name\",\n    )\n    parser.add_argument(\n        \"--use_slow_tokenizer\",\n        action=\"store_true\",\n        help=\"If passed, will use a slow tokenizer (not backed by the \ud83e\udd17 Tokenizers library).\",\n    )\n    parser.add_argument(\n        \"--per_device_train_batch_size\",\n        type=int,\n        default=8,\n        help=\"Batch size (per device) for the training dataloader.\",\n    )\n    parser.add_argument(\n        \"--per_device_eval_batch_size\",\n        type=int,\n        default=8,\n        help=\"Batch size (per device) for the evaluation dataloader.\",\n    )\n    parser.add_argument(\n        \"--learning_rate\",\n        type=float,\n        default=5e-5,\n        help=\"Initial learning rate (after the potential warmup period) to use.\",\n    )\n    parser.add_argument(\"--weight_decay\", type=float, default=0.0, help=\"Weight decay to use.\")\n    parser.add_argument(\"--num_train_epochs\", type=int, default=3, help=\"Total number of training epochs to perform.\")\n    parser.add_argument(\n        \"--max_train_steps\",\n        type=int,\n        default=None,\n        help=\"Total number of training steps to perform. If provided, overrides num_train_epochs.\",\n    )\n    parser.add_argument(\n        \"--gradient_accumulation_steps\",\n        type=int,\n        default=1,\n        help=\"Number of updates steps to accumulate before performing a backward/update pass.\",\n    )\n    parser.add_argument(\n        \"--lr_scheduler_type\",\n        type=SchedulerType,\n        default=\"linear\",\n        help=\"The scheduler type to use.\",\n        choices=[\"linear\", \"cosine\", \"cosine_with_restarts\", \"polynomial\", \"constant\", \"constant_with_warmup\"],\n    )\n    parser.add_argument(\n        \"--num_warmup_steps\", type=int, default=0, help=\"Number of steps for the warmup in the lr scheduler.\"\n    )\n    parser.add_argument(\"--output_dir\", type=str, default=None, help=\"Where to store the final model.\")\n    parser.add_argument(\"--seed\", type=int, default=None, help=\"A seed for reproducible training.\")\n    parser.add_argument(\n        \"--model_type\",\n        type=str,\n        default=None,\n        help=\"Model type to use if training from scratch.\",\n        choices=MODEL_TYPES,\n    )\n    parser.add_argument(\n        \"--block_size\",\n        type=int,\n        default=None,\n        help=(\n            \"Optional input sequence length after tokenization. The training dataset will be truncated in block of\"\n            \" this size for training. Default to the model max input length for single sentence inputs (take into\"\n            \" account special tokens).\"\n        ),\n    )\n    parser.add_argument(\n        \"--preprocessing_num_workers\",\n        type=int,\n        default=None,\n        help=\"The number of processes to use for the preprocessing.\",\n    )\n    parser.add_argument(\n        \"--overwrite_cache\", type=bool, default=False, help=\"Overwrite the cached training and evaluation sets\"\n    )\n    parser.add_argument(\n        \"--no_keep_linebreaks\", action=\"store_true\", help=\"Do not keep line breaks when using TXT files.\"\n    )\n    parser.add_argument(\"--push_to_hub\", action=\"store_true\", help=\"Whether or not to push the model to the Hub.\")\n    parser.add_argument(\n        \"--hub_model_id\", type=str, help=\"The name of the repository to keep in sync with the local `output_dir`.\"\n    )\n    parser.add_argument(\"--hub_token\", type=str, help=\"The token to use to push to the Model Hub.\")\n    parser.add_argument(\n        \"--checkpointing_steps\",\n        type=str,\n        default=None,\n        help=\"Whether the various states should be saved at the end of every n steps, or 'epoch' for each epoch.\",\n    )\n    parser.add_argument(\n        \"--resume_from_checkpoint\",\n        type=str,\n        default=None,\n        help=\"If the training should continue from a checkpoint folder.\",\n    )\n    # New Code #\n    # Whether to load the best model at the end of training\n    parser.add_argument(\n        \"--load_best_model\",\n        action=\"store_true\",\n        help=\"Whether to load the best model at the end of training\",\n    )\n    parser.add_argument(\n        \"--with_tracking\",\n        action=\"store_true\",\n        help=\"Whether to enable experiment trackers for logging.\",\n    )\n    parser.add_argument(\n        \"--report_to\",\n        type=str,\n        default=\"all\",\n        help=(\n            'The integration to report the results and logs to. Supported platforms are `\"tensorboard\"`,'\n            ' `\"wandb\"` and `\"comet_ml\"`. Use `\"all\"` (default) to report to all integrations.'\n            \"Only applicable when `--with_tracking` is passed.\"\n        ),\n    )\n    args = parser.parse_args()\n\n    # Sanity checks\n    if args.dataset_name is None and args.train_file is None and args.validation_file is None:\n        raise ValueError(\"Need either a dataset name or a training/validation file.\")\n    else:\n        if args.train_file is not None:\n            extension = args.train_file.split(\".\")[-1]\n            assert extension in [\"csv\", \"json\", \"txt\"], \"`train_file` should be a csv, json or txt file.\"\n        if args.validation_file is not None:\n            extension = args.validation_file.split(\".\")[-1]\n            assert extension in [\"csv\", \"json\", \"txt\"], \"`validation_file` should be a csv, json or txt file.\"\n\n    if args.push_to_hub:\n        assert args.output_dir is not None, \"Need an `output_dir` to create a repo when `--push_to_hub` is passed.\"\n\n    return args\n\n\n# New Code #\ndef evaluate(args, model, eval_dataloader, accelerator, eval_dataset):\n    model.eval()\n    losses = []\n    for step, batch in enumerate(eval_dataloader):\n        with torch.no_grad():\n            outputs = model(**batch)\n\n        loss = outputs.loss\n        losses.append(accelerator.gather_for_metrics(loss.repeat(args.per_device_eval_batch_size)))\n\n    losses = torch.cat(losses)\n    try:\n        eval_loss = torch.mean(losses)\n        perplexity = math.exp(eval_loss)\n    except OverflowError:\n        perplexity = float(\"inf\")\n    return perplexity, eval_loss\n\n\ndef main():\n    args = parse_args()\n\n    # Initialize the accelerator. We will let the accelerator handle device placement for us in this example.\n    # If we're using tracking, we also need to initialize it here and it will by default pick up all supported trackers\n    # in the environment\n\n    # when using DeepSpeed, the `gradient_accumulation_steps` is properly set from the DeepSpeed plugin/config\n    # or from `accelerate launch` via `--gradient_accumulation_steps`  else\n    # defaulting to the passed `args.gradient_accumulation_steps`\n    accelerator = (\n        Accelerator(\n            log_with=args.report_to,\n            project_dir=args.output_dir,\n            gradient_accumulation_steps=args.gradient_accumulation_steps,\n        )\n        if args.with_tracking\n        else Accelerator(gradient_accumulation_steps=args.gradient_accumulation_steps)\n    )\n\n    # Make one log on every process with the configuration for debugging.\n    logging.basicConfig(\n        format=\"%(asctime)s - %(levelname)s - %(name)s - %(message)s\",\n        datefmt=\"%m/%d/%Y %H:%M:%S\",\n        level=logging.INFO,\n    )\n    logger.info(accelerator.state, main_process_only=False)\n    if accelerator.is_local_main_process:\n        datasets.utils.logging.set_verbosity_warning()\n        transformers.utils.logging.set_verbosity_info()\n    else:\n        datasets.utils.logging.set_verbosity_error()\n        transformers.utils.logging.set_verbosity_error()\n\n    # If passed along, set the training seed now.\n    if args.seed is not None:\n        set_seed(args.seed)\n\n    # Handle the repository creation\n    if accelerator.is_main_process:\n        if args.push_to_hub:\n            if args.hub_model_id is None:\n                repo_name = get_full_repo_name(Path(args.output_dir).name, token=args.hub_token)\n            else:\n                repo_name = args.hub_model_id\n            repo = Repository(args.output_dir, clone_from=repo_name)\n\n            with open(os.path.join(args.output_dir, \".gitignore\"), \"w+\") as gitignore:\n                if \"step_*\" not in gitignore:\n                    gitignore.write(\"step_*\\n\")\n                if \"epoch_*\" not in gitignore:\n                    gitignore.write(\"epoch_*\\n\")\n        elif args.output_dir is not None:\n            os.makedirs(args.output_dir, exist_ok=True)\n    accelerator.wait_for_everyone()\n\n    # Get the datasets: you can either provide your own CSV/JSON/TXT training and evaluation files (see below)\n    # or just provide the name of one of the public datasets available on the hub at https://huggingface.co/datasets/\n    # (the dataset will be downloaded automatically from the datasets Hub).\n    #\n    # For CSV/JSON files, this script will use the column called 'text' or the first column if no column called\n    # 'text' is found. You can easily tweak this behavior (see below).\n    #\n    # In distributed training, the load_dataset function guarantee that only one local process can concurrently\n    # download the dataset.\n    if args.dataset_name is not None:\n        # Downloading and loading a dataset from the hub.\n        raw_datasets = load_dataset(args.dataset_name, args.dataset_config_name)\n        if \"validation\" not in raw_datasets.keys():\n            raw_datasets[\"validation\"] = load_dataset(\n                args.dataset_name,\n                args.dataset_config_name,\n                split=f\"train[:{args.validation_split_percentage}%]\",\n            )\n            raw_datasets[\"train\"] = load_dataset(\n                args.dataset_name,\n                args.dataset_config_name,\n                split=f\"train[{args.validation_split_percentage}%:]\",\n            )\n    else:\n        data_files = {}\n        dataset_args = {}\n        if args.train_file is not None:\n            data_files[\"train\"] = args.train_file\n        if args.validation_file is not None:\n            data_files[\"validation\"] = args.validation_file\n        extension = args.train_file.split(\".\")[-1]\n        if extension == \"txt\":\n            extension = \"text\"\n            dataset_args[\"keep_linebreaks\"] = not args.no_keep_linebreaks\n        raw_datasets = load_dataset(extension, data_files=data_files, **dataset_args)\n        # If no validation data is there, validation_split_percentage will be used to divide the dataset.\n        if \"validation\" not in raw_datasets.keys():\n            raw_datasets[\"validation\"] = load_dataset(\n                extension,\n                data_files=data_files,\n                split=f\"train[:{args.validation_split_percentage}%]\",\n                **dataset_args,\n            )\n            raw_datasets[\"train\"] = load_dataset(\n                extension,\n                data_files=data_files,\n                split=f\"train[{args.validation_split_percentage}%:]\",\n                **dataset_args,\n            )\n\n    # See more about loading any type of standard or custom dataset (from files, python dict, pandas DataFrame, etc) at\n    # https://huggingface.co/docs/datasets/loading_datasets.html.\n\n    # Load pretrained model and tokenizer\n    #\n    # In distributed training, the .from_pretrained methods guarantee that only one local process can concurrently\n    # download model & vocab.\n    if args.config_name:\n        config = AutoConfig.from_pretrained(args.config_name)\n    elif args.model_name_or_path:\n        config = AutoConfig.from_pretrained(args.model_name_or_path)\n    else:\n        config = CONFIG_MAPPING[args.model_type]()\n        logger.warning(\"You are instantiating a new config instance from scratch.\")\n\n    if args.tokenizer_name:\n        tokenizer = AutoTokenizer.from_pretrained(args.tokenizer_name, use_fast=not args.use_slow_tokenizer)\n    elif args.model_name_or_path:\n        tokenizer = AutoTokenizer.from_pretrained(args.model_name_or_path, use_fast=not args.use_slow_tokenizer)\n    else:\n        raise ValueError(\n            \"You are instantiating a new tokenizer from scratch. This is not supported by this script.\"\n            \"You can do it from another script, save it, and load it from here, using --tokenizer_name.\"\n        )\n\n    if args.model_name_or_path:\n        model = AutoModelForCausalLM.from_pretrained(\n            args.model_name_or_path,\n            from_tf=bool(\".ckpt\" in args.model_name_or_path),\n            config=config,\n        )\n    else:\n        logger.info(\"Training new model from scratch\")\n        model = AutoModelForCausalLM.from_config(config)\n\n    model.resize_token_embeddings(len(tokenizer))\n\n    # Preprocessing the datasets.\n    # First we tokenize all the texts.\n    column_names = raw_datasets[\"train\"].column_names\n    text_column_name = \"text\" if \"text\" in column_names else column_names[0]\n\n    def tokenize_function(examples):\n        return tokenizer(examples[text_column_name])\n\n    with accelerator.main_process_first():\n        tokenized_datasets = raw_datasets.map(\n            tokenize_function,\n            batched=True,\n            num_proc=args.preprocessing_num_workers,\n            remove_columns=column_names,\n            load_from_cache_file=not args.overwrite_cache,\n            desc=\"Running tokenizer on dataset\",\n        )\n\n    if args.block_size is None:\n        block_size = tokenizer.model_max_length\n        if block_size > 1024:\n            logger.warning(\n                f\"The tokenizer picked seems to have a very large `model_max_length` ({tokenizer.model_max_length}). \"\n                \"Picking 1024 instead. You can change that default value by passing --block_size xxx.\"\n            )\n        block_size = 1024\n    else:\n        if args.block_size > tokenizer.model_max_length:\n            logger.warning(\n                f\"The block_size passed ({args.block_size}) is larger than the maximum length for the model\"\n                f\"({tokenizer.model_max_length}). Using block_size={tokenizer.model_max_length}.\"\n            )\n        block_size = min(args.block_size, tokenizer.model_max_length)\n\n    # Main data processing function that will concatenate all texts from our dataset and generate chunks of block_size.\n    def group_texts(examples):\n        # Concatenate all texts.\n        concatenated_examples = {k: list(chain(*examples[k])) for k in examples.keys()}\n        total_length = len(concatenated_examples[list(examples.keys())[0]])\n        # We drop the small remainder, we could add padding if the model supported it instead of this drop, you can\n        # customize this part to your needs.\n        if total_length >= block_size:\n            total_length = (total_length // block_size) * block_size\n        # Split by chunks of max_len.\n        result = {\n            k: [t[i : i + block_size] for i in range(0, total_length, block_size)]\n            for k, t in concatenated_examples.items()\n        }\n        result[\"labels\"] = result[\"input_ids\"].copy()\n        return result\n\n    # Note that with `batched=True`, this map processes 1,000 texts together, so group_texts throws away a remainder\n    # for each of those groups of 1,000 texts. You can adjust that batch_size here but a higher value might be slower\n    # to preprocess.\n    #\n    # To speed up this part, we use multiprocessing. See the documentation of the map method for more information:\n    # https://huggingface.co/docs/datasets/package_reference/main_classes.html#datasets.Dataset.map\n\n    with accelerator.main_process_first():\n        lm_datasets = tokenized_datasets.map(\n            group_texts,\n            batched=True,\n            num_proc=args.preprocessing_num_workers,\n            load_from_cache_file=not args.overwrite_cache,\n            desc=f\"Grouping texts in chunks of {block_size}\",\n        )\n\n    train_dataset = lm_datasets[\"train\"]\n    eval_dataset = lm_datasets[\"validation\"]\n\n    # Log a few random samples from the training set:\n    for index in random.sample(range(len(train_dataset)), 3):\n        logger.info(f\"Sample {index} of the training set: {train_dataset[index]}.\")\n\n    # DataLoaders creation:\n    train_dataloader = DataLoader(\n        train_dataset, shuffle=True, collate_fn=default_data_collator, batch_size=args.per_device_train_batch_size\n    )\n    eval_dataloader = DataLoader(\n        eval_dataset, collate_fn=default_data_collator, batch_size=args.per_device_eval_batch_size\n    )\n\n    # Optimizer\n    # Split weights in two groups, one with weight decay and the other not.\n    no_decay = [\"bias\", \"LayerNorm.weight\"]\n    optimizer_grouped_parameters = [\n        {\n            \"params\": [p for n, p in model.named_parameters() if not any(nd in n for nd in no_decay)],\n            \"weight_decay\": args.weight_decay,\n        },\n        {\n            \"params\": [p for n, p in model.named_parameters() if any(nd in n for nd in no_decay)],\n            \"weight_decay\": 0.0,\n        },\n    ]\n    # New Code #\n    # Creates Dummy Optimizer if `optimizer` was specified in the config file else creates Adam Optimizer\n    optimizer_cls = (\n        torch.optim.AdamW\n        if accelerator.state.deepspeed_plugin is None\n        or \"optimizer\" not in accelerator.state.deepspeed_plugin.deepspeed_config\n        else DummyOptim\n    )\n    optimizer = optimizer_cls(optimizer_grouped_parameters, lr=args.learning_rate)\n\n    # On TPU, the tie weights in our model have been disconnected, so we need to restore the ties.\n    if accelerator.distributed_type == DistributedType.TPU:\n        model.tie_weights()\n\n    # Scheduler and math around the number of training steps.\n    num_update_steps_per_epoch = math.ceil(len(train_dataloader) / accelerator.gradient_accumulation_steps)\n    overrode_max_train_steps = False\n    if args.max_train_steps is None:\n        args.max_train_steps = args.num_train_epochs * num_update_steps_per_epoch\n        overrode_max_train_steps = True\n    else:\n        args.num_train_epochs = math.ceil(args.max_train_steps / num_update_steps_per_epoch)\n\n    # New Code #\n    # Creates Dummy Scheduler if `scheduler` was specified in the config file else creates `args.lr_scheduler_type` Scheduler\n    if (\n        accelerator.state.deepspeed_plugin is None\n        or \"scheduler\" not in accelerator.state.deepspeed_plugin.deepspeed_config\n    ):\n        lr_scheduler = get_scheduler(\n            name=args.lr_scheduler_type,\n            optimizer=optimizer,\n            num_warmup_steps=args.num_warmup_steps,\n            num_training_steps=args.max_train_steps,\n        )\n    else:\n        lr_scheduler = DummyScheduler(\n            optimizer, total_num_steps=args.max_train_steps, warmup_num_steps=args.num_warmup_steps\n        )\n\n    # Prepare everything with our `accelerator`.\n    model, optimizer, train_dataloader, eval_dataloader, lr_scheduler = accelerator.prepare(\n        model, optimizer, train_dataloader, eval_dataloader, lr_scheduler\n    )\n\n    # We need to recalculate our total training steps as the size of the training dataloader may have changed.\n    num_update_steps_per_epoch = math.ceil(len(train_dataloader) / accelerator.gradient_accumulation_steps)\n    if overrode_max_train_steps:\n        args.max_train_steps = args.num_train_epochs * num_update_steps_per_epoch\n    # Afterwards we recalculate our number of training epochs\n    args.num_train_epochs = math.ceil(args.max_train_steps / num_update_steps_per_epoch)\n\n    # Figure out how many steps we should save the Accelerator states\n    checkpointing_steps = args.checkpointing_steps\n    if checkpointing_steps is not None and checkpointing_steps.isdigit():\n        checkpointing_steps = int(checkpointing_steps)\n\n    # We need to initialize the trackers we use, and also store our configuration.\n    # The trackers initializes automatically on the main process.\n    if args.with_tracking:\n        experiment_config = vars(args)\n        # TensorBoard cannot log Enums, need the raw value\n        experiment_config[\"lr_scheduler_type\"] = experiment_config[\"lr_scheduler_type\"].value\n        accelerator.init_trackers(\"clm_no_trainer\", experiment_config)\n\n    # Train!\n    total_batch_size = (\n        args.per_device_train_batch_size * accelerator.num_processes * accelerator.gradient_accumulation_steps\n    )\n\n    logger.info(\"***** Running training *****\")\n    logger.info(f\"  Num examples = {len(train_dataset)}\")\n    logger.info(f\"  Num Epochs = {args.num_train_epochs}\")\n    logger.info(f\"  Instantaneous batch size per device = {args.per_device_train_batch_size}\")\n    logger.info(f\"  Total train batch size (w. parallel, distributed & accumulation) = {total_batch_size}\")\n    logger.info(f\"  Gradient Accumulation steps = {accelerator.gradient_accumulation_steps}\")\n    logger.info(f\"  Total optimization steps = {args.max_train_steps}\")\n    # Only show the progress bar once on each machine.\n    progress_bar = tqdm(range(args.max_train_steps), disable=not accelerator.is_local_main_process)\n    completed_steps = 0\n    starting_epoch = 0\n    best_metric = None\n    best_metric_checkpoint = None\n\n    # Potentially load in the weights and states from a previous save\n    if args.resume_from_checkpoint:\n        accelerator.load_state(args.resume_from_checkpoint)\n        accelerator.print(f\"Resumed from checkpoint: {args.resume_from_checkpoint}\")\n        path = os.path.basename(args.resume_from_checkpoint)\n        training_difference = os.path.splitext(path)[0]\n\n        if \"epoch\" in training_difference:\n            starting_epoch = int(training_difference.replace(\"epoch_\", \"\")) + 1\n            resume_step = None\n            completed_steps = starting_epoch * num_update_steps_per_epoch\n        else:\n            resume_step = int(training_difference.replace(\"step_\", \"\"))\n            starting_epoch = resume_step // num_update_steps_per_epoch\n            resume_step -= starting_epoch * num_update_steps_per_epoch\n            completed_steps = resume_step\n\n    for epoch in range(starting_epoch, args.num_train_epochs):\n        model.train()\n        if args.with_tracking:\n            total_loss = 0\n\n        # skip new `skip_first_batches` to skip the batches when resuming from ckpt\n        if args.resume_from_checkpoint:\n            train_dataloader = accelerator.skip_first_batches(train_dataloader, num_batches=resume_step)\n        for step, batch in enumerate(train_dataloader):\n            # In particular, DeepSpeed handles `gradient_accumulation` via `DeepSpeedEngine`.\n            # Below, we use `accelerator.accumulate` if the user\n            # wants to switch to other approaches such as plain DDP, PyTorch FSDP ...\n            # This avoids having to change any code as things are all handled across different distributed setups.\n            with accelerator.accumulate(model):\n                outputs = model(**batch)\n                loss = outputs.loss\n                accelerator.backward(loss)\n                optimizer.step()\n                lr_scheduler.step()\n                optimizer.zero_grad()\n\n                if accelerator.sync_gradients:\n                    progress_bar.update(1)\n                    completed_steps += 1\n\n            # We keep track of the loss at each epoch\n            if args.with_tracking:\n                step_loss = accelerator.reduce(loss.detach().clone()).item()\n                total_loss += step_loss\n\n            if isinstance(checkpointing_steps, int):\n                if completed_steps % checkpointing_steps == 0:\n                    output_dir = f\"step_{completed_steps}\"\n                    if args.output_dir is not None:\n                        output_dir = os.path.join(args.output_dir, output_dir)\n                    accelerator.save_state(output_dir)\n            if completed_steps >= args.max_train_steps:\n                break\n\n        perplexity, eval_loss = evaluate(args, model, eval_dataloader, accelerator, eval_dataset)\n        logger.info(f\"epoch {epoch}: perplexity: {perplexity} eval_loss: {eval_loss}\")\n\n        if args.with_tracking:\n            accelerator.log(\n                {\n                    \"perplexity\": perplexity,\n                    \"eval_loss\": eval_loss,\n                    \"train_loss\": total_loss / len(train_dataloader),\n                    \"epoch\": epoch,\n                    \"step\": completed_steps,\n                },\n                step=completed_steps,\n            )\n\n        if isinstance(checkpointing_steps, str) and checkpointing_steps == \"epoch\":\n            accelerator.save_state(os.path.join(args.output_dir, f\"epoch_{epoch}\"))\n\n        # New Code #\n        # Tracks the best checkpoint and best metric\n        if best_metric is None or best_metric > perplexity:\n            best_metric = perplexity\n            best_metric_checkpoint = os.path.join(args.output_dir, \"best_checkpoint\")\n            accelerator.save_state(best_metric_checkpoint)\n            accelerator.print(f\"New best metric: {best_metric} at epoch {epoch}\")\n            accelerator.print(f\"best_metric_checkpoint: {best_metric_checkpoint}\")\n\n    # New Code #\n    # Loads the best checkpoint after the training is finished\n    if args.load_best_model:\n        accelerator.load_state(best_metric_checkpoint)\n\n    # New Code #\n    # Evaluates using the best checkpoint\n    perplexity, eval_loss = evaluate(args, model, eval_dataloader, accelerator, eval_dataset)\n    logger.info(f\"Best model metrics: perplexity: {perplexity} eval_loss: {eval_loss}\")\n    if perplexity != best_metric:\n        raise AssertionError(\n            f\"Best metric {best_metric} does not match the metric {perplexity} of the loaded best model.\"\n        )\n\n    if args.output_dir is not None:\n        accelerator.wait_for_everyone()\n        unwrapped_model = accelerator.unwrap_model(model)\n\n        # New Code #\n        # Saves the whole/unpartitioned fp16 model when in ZeRO Stage-3 to the output directory if\n        # `stage3_gather_16bit_weights_on_model_save` is True in DeepSpeed Config file or\n        # `zero3_save_16bit_model` is True in DeepSpeed Plugin.\n        # For Zero Stages 1 and 2, models are saved as usual in the output directory.\n        # The model name saved is `pytorch_model.bin`\n        unwrapped_model.save_pretrained(\n            args.output_dir,\n            is_main_process=accelerator.is_main_process,\n            save_function=accelerator.save,\n            state_dict=accelerator.get_state_dict(model),\n        )\n        if accelerator.is_main_process:\n            tokenizer.save_pretrained(args.output_dir)\n            if args.push_to_hub:\n                repo.push_to_hub(commit_message=\"End of training\", auto_lfs_prune=True)\n\n        with open(os.path.join(args.output_dir, \"all_results.json\"), \"w\") as f:\n            json.dump({\"perplexity\": perplexity, \"eval_loss\": eval_loss.item()}, f)\n\n\nif __name__ == \"__main__\":\n    main()\n", "# coding=utf-8\n# Copyright 2023 The HuggingFace Inc. team. All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nimport argparse\nimport os\n\nimport evaluate\nimport torch\nfrom datasets import load_dataset\nfrom torch.optim import AdamW\nfrom torch.utils.data import DataLoader\nfrom transformers import AutoModelForSequenceClassification, AutoTokenizer, get_linear_schedule_with_warmup, set_seed\n\nfrom accelerate import Accelerator, DistributedType\nfrom accelerate.local_sgd import LocalSGD\n\n\n########################################################################\n# This is a fully working simple example to use Accelerate\n# with LocalSGD, which is a method to synchronize model\n# parameters every K batches. It is different, but complementary\n# to gradient accumulation.\n#\n# This example trains a Bert base model on GLUE MRPC\n# in any of the following settings (with the same script):\n#   - single CPU or single GPU\n#   - multi GPUS (using PyTorch distributed mode)\n#   - (multi) TPUs\n#   - fp16 (mixed-precision) or fp32 (normal precision)\n#\n# To run it in each of these various modes, follow the instructions\n# in the readme for examples:\n# https://github.com/huggingface/accelerate/tree/main/examples\n#\n########################################################################\n\n\nMAX_GPU_BATCH_SIZE = 16\nEVAL_BATCH_SIZE = 32\n\n\ndef get_dataloaders(accelerator: Accelerator, batch_size: int = 16):\n    \"\"\"\n    Creates a set of `DataLoader`s for the `glue` dataset,\n    using \"bert-base-cased\" as the tokenizer.\n\n    Args:\n        accelerator (`Accelerator`):\n            An `Accelerator` object\n        batch_size (`int`, *optional*):\n            The batch size for the train and validation DataLoaders.\n    \"\"\"\n    tokenizer = AutoTokenizer.from_pretrained(\"bert-base-cased\")\n    datasets = load_dataset(\"glue\", \"mrpc\")\n\n    def tokenize_function(examples):\n        # max_length=None => use the model max length (it's actually the default)\n        outputs = tokenizer(examples[\"sentence1\"], examples[\"sentence2\"], truncation=True, max_length=None)\n        return outputs\n\n    # Apply the method we just defined to all the examples in all the splits of the dataset\n    # starting with the main process first:\n    with accelerator.main_process_first():\n        tokenized_datasets = datasets.map(\n            tokenize_function,\n            batched=True,\n            remove_columns=[\"idx\", \"sentence1\", \"sentence2\"],\n        )\n\n    # We also rename the 'label' column to 'labels' which is the expected name for labels by the models of the\n    # transformers library\n    tokenized_datasets = tokenized_datasets.rename_column(\"label\", \"labels\")\n\n    def collate_fn(examples):\n        # On TPU it's best to pad everything to the same length or training will be very slow.\n        max_length = 128 if accelerator.distributed_type == DistributedType.TPU else None\n        # When using mixed precision we want round multiples of 8/16\n        if accelerator.mixed_precision == \"fp8\":\n            pad_to_multiple_of = 16\n        elif accelerator.mixed_precision != \"no\":\n            pad_to_multiple_of = 8\n        else:\n            pad_to_multiple_of = None\n\n        return tokenizer.pad(\n            examples,\n            padding=\"longest\",\n            max_length=max_length,\n            pad_to_multiple_of=pad_to_multiple_of,\n            return_tensors=\"pt\",\n        )\n\n    # Instantiate dataloaders.\n    train_dataloader = DataLoader(\n        tokenized_datasets[\"train\"], shuffle=True, collate_fn=collate_fn, batch_size=batch_size\n    )\n    eval_dataloader = DataLoader(\n        tokenized_datasets[\"validation\"], shuffle=False, collate_fn=collate_fn, batch_size=EVAL_BATCH_SIZE\n    )\n\n    return train_dataloader, eval_dataloader\n\n\n# For testing only\nif os.environ.get(\"TESTING_MOCKED_DATALOADERS\", None) == \"1\":\n    from accelerate.test_utils.training import mocked_dataloaders\n\n    get_dataloaders = mocked_dataloaders  # noqa: F811\n\n\ndef training_function(config, args):\n    # For testing only\n    if os.environ.get(\"TESTING_MOCKED_DATALOADERS\", None) == \"1\":\n        config[\"num_epochs\"] = 2\n    # New Code #\n    gradient_accumulation_steps = int(args.gradient_accumulation_steps)\n    local_sgd_steps = int(args.local_sgd_steps)\n    # Initialize accelerator\n    accelerator = Accelerator(\n        cpu=args.cpu, mixed_precision=args.mixed_precision, gradient_accumulation_steps=gradient_accumulation_steps\n    )\n    if accelerator.distributed_type not in [DistributedType.NO, DistributedType.MULTI_CPU, DistributedType.MULTI_GPU]:\n        raise NotImplementedError(\"LocalSGD is supported only for CPUs and GPUs (no DeepSpeed or MegatronLM)\")\n    # Sample hyper-parameters for learning rate, batch size, seed and a few other HPs\n    lr = config[\"lr\"]\n    num_epochs = int(config[\"num_epochs\"])\n    seed = int(config[\"seed\"])\n    batch_size = int(config[\"batch_size\"])\n\n    metric = evaluate.load(\"glue\", \"mrpc\")\n\n    set_seed(seed)\n    train_dataloader, eval_dataloader = get_dataloaders(accelerator, batch_size)\n    # Instantiate the model (we build the model here so that the seed also control new weights initialization)\n    model = AutoModelForSequenceClassification.from_pretrained(\"bert-base-cased\", return_dict=True)\n\n    # We could avoid this line since the accelerator is set with `device_placement=True` (default value).\n    # Note that if you are placing tensors on devices manually, this line absolutely needs to be before the optimizer\n    # creation otherwise training will not work on TPU (`accelerate` will kindly throw an error to make us aware of that).\n    model = model.to(accelerator.device)\n\n    # Instantiate optimizer\n    optimizer = AdamW(params=model.parameters(), lr=lr)\n\n    # Instantiate scheduler\n    lr_scheduler = get_linear_schedule_with_warmup(\n        optimizer=optimizer,\n        num_warmup_steps=100,\n        num_training_steps=(len(train_dataloader) * num_epochs),\n    )\n\n    # Prepare everything\n    # There is no specific order to remember, we just need to unpack the objects in the same order we gave them to the\n    # prepare method.\n    model, optimizer, train_dataloader, eval_dataloader, lr_scheduler = accelerator.prepare(\n        model, optimizer, train_dataloader, eval_dataloader, lr_scheduler\n    )\n\n    # Now we train the model\n    for epoch in range(num_epochs):\n        model.train()\n        with LocalSGD(\n            accelerator=accelerator, model=model, local_sgd_steps=local_sgd_steps, enabled=local_sgd_steps is not None\n        ) as local_sgd:\n            for step, batch in enumerate(train_dataloader):\n                # We could avoid this line since we set the accelerator with `device_placement=True`.\n                batch.to(accelerator.device)\n                # New code #\n                # We use the new `accumulate` context manager to perform gradient accumulation\n                # We also currently do not support TPUs nor advise it as bugs were found on the XLA side when running our tests.\n                with accelerator.accumulate(model):\n                    output = model(**batch)\n                    loss = output.loss\n                    accelerator.backward(loss)\n                    optimizer.step()\n                    lr_scheduler.step()\n                    optimizer.zero_grad()\n                    # LocalSGD-specific line\n                    local_sgd.step()\n\n        model.eval()\n        for step, batch in enumerate(eval_dataloader):\n            # We could avoid this line since we set the accelerator with `device_placement=True`.\n            batch.to(accelerator.device)\n            with torch.no_grad():\n                outputs = model(**batch)\n            predictions = outputs.logits.argmax(dim=-1)\n            predictions, references = accelerator.gather_for_metrics((predictions, batch[\"labels\"]))\n            metric.add_batch(\n                predictions=predictions,\n                references=references,\n            )\n\n        eval_metric = metric.compute()\n        # Use accelerator.print to print only on the main process.\n        accelerator.print(f\"epoch {epoch}:\", eval_metric)\n\n\ndef main():\n    parser = argparse.ArgumentParser(description=\"Simple example of training script.\")\n    parser.add_argument(\n        \"--mixed_precision\",\n        type=str,\n        default=None,\n        choices=[\"no\", \"fp16\", \"bf16\", \"fp8\"],\n        help=\"Whether to use mixed precision. Choose\"\n        \"between fp16 and bf16 (bfloat16). Bf16 requires PyTorch >= 1.10.\"\n        \"and an Nvidia Ampere GPU.\",\n    )\n    # New Code #\n    parser.add_argument(\n        \"--gradient_accumulation_steps\",\n        type=int,\n        default=1,\n        help=\"The number of minibatches to be ran before gradients are accumulated.\",\n    )\n    parser.add_argument(\n        \"--local_sgd_steps\", type=int, default=8, help=\"Number of local SGD steps or None to disable local SGD\"\n    )\n    parser.add_argument(\"--cpu\", action=\"store_true\", help=\"If passed, will train on the CPU.\")\n    args = parser.parse_args()\n    config = {\"lr\": 2e-5, \"num_epochs\": 3, \"seed\": 42, \"batch_size\": 16}\n    training_function(config, args)\n\n\nif __name__ == \"__main__\":\n    main()\n", "# coding=utf-8\n# Copyright 2021 The HuggingFace Inc. team. All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nimport argparse\nimport os\n\nimport evaluate\nimport torch\nfrom datasets import load_dataset\nfrom torch.optim import AdamW\nfrom torch.utils.data import DataLoader\nfrom transformers import AutoModelForSequenceClassification, AutoTokenizer, get_linear_schedule_with_warmup, set_seed\n\nfrom accelerate import Accelerator, DistributedType\n\n\n########################################################################\n# This is a fully working simple example to use Accelerate,\n# specifically showcasing the experiment tracking capability,\n# and builds off the `nlp_example.py` script.\n#\n# This example trains a Bert base model on GLUE MRPC\n# in any of the following settings (with the same script):\n#   - single CPU or single GPU\n#   - multi GPUS (using PyTorch distributed mode)\n#   - (multi) TPUs\n#   - fp16 (mixed-precision) or fp32 (normal precision)\n#\n# To help focus on the differences in the code, building `DataLoaders`\n# was refactored into its own function.\n# New additions from the base script can be found quickly by\n# looking for the # New Code # tags\n#\n# To run it in each of these various modes, follow the instructions\n# in the readme for examples:\n# https://github.com/huggingface/accelerate/tree/main/examples\n#\n########################################################################\n\nMAX_GPU_BATCH_SIZE = 16\nEVAL_BATCH_SIZE = 32\n\n\ndef get_dataloaders(accelerator: Accelerator, batch_size: int = 16):\n    \"\"\"\n    Creates a set of `DataLoader`s for the `glue` dataset,\n    using \"bert-base-cased\" as the tokenizer.\n\n    Args:\n        accelerator (`Accelerator`):\n            An `Accelerator` object\n        batch_size (`int`, *optional*):\n            The batch size for the train and validation DataLoaders.\n    \"\"\"\n    tokenizer = AutoTokenizer.from_pretrained(\"bert-base-cased\")\n    datasets = load_dataset(\"glue\", \"mrpc\")\n\n    def tokenize_function(examples):\n        # max_length=None => use the model max length (it's actually the default)\n        outputs = tokenizer(examples[\"sentence1\"], examples[\"sentence2\"], truncation=True, max_length=None)\n        return outputs\n\n    # Apply the method we just defined to all the examples in all the splits of the dataset\n    # starting with the main process first:\n    with accelerator.main_process_first():\n        tokenized_datasets = datasets.map(\n            tokenize_function,\n            batched=True,\n            remove_columns=[\"idx\", \"sentence1\", \"sentence2\"],\n        )\n\n    # We also rename the 'label' column to 'labels' which is the expected name for labels by the models of the\n    # transformers library\n    tokenized_datasets = tokenized_datasets.rename_column(\"label\", \"labels\")\n\n    def collate_fn(examples):\n        # On TPU it's best to pad everything to the same length or training will be very slow.\n        max_length = 128 if accelerator.distributed_type == DistributedType.TPU else None\n        # When using mixed precision we want round multiples of 8/16\n        if accelerator.mixed_precision == \"fp8\":\n            pad_to_multiple_of = 16\n        elif accelerator.mixed_precision != \"no\":\n            pad_to_multiple_of = 8\n        else:\n            pad_to_multiple_of = None\n\n        return tokenizer.pad(\n            examples,\n            padding=\"longest\",\n            max_length=max_length,\n            pad_to_multiple_of=pad_to_multiple_of,\n            return_tensors=\"pt\",\n        )\n\n    # Instantiate dataloaders.\n    train_dataloader = DataLoader(\n        tokenized_datasets[\"train\"], shuffle=True, collate_fn=collate_fn, batch_size=batch_size\n    )\n    eval_dataloader = DataLoader(\n        tokenized_datasets[\"validation\"], shuffle=False, collate_fn=collate_fn, batch_size=EVAL_BATCH_SIZE\n    )\n\n    return train_dataloader, eval_dataloader\n\n\n# For testing only\nif os.environ.get(\"TESTING_MOCKED_DATALOADERS\", None) == \"1\":\n    from accelerate.test_utils.training import mocked_dataloaders\n\n    get_dataloaders = mocked_dataloaders  # noqa: F811\n\n\ndef training_function(config, args):\n    # For testing only\n    if os.environ.get(\"TESTING_MOCKED_DATALOADERS\", None) == \"1\":\n        config[\"num_epochs\"] = 2\n    # Initialize Accelerator\n\n    # New Code #\n    # We pass in \"all\" to `log_with` to grab all available trackers in the environment\n    # Note: If using a custom `Tracker` class, should be passed in here such as:\n    # >>> log_with = [\"all\", MyCustomTrackerClassInstance()]\n    if args.with_tracking:\n        accelerator = Accelerator(\n            cpu=args.cpu, mixed_precision=args.mixed_precision, log_with=\"all\", project_dir=args.project_dir\n        )\n    else:\n        accelerator = Accelerator(cpu=args.cpu, mixed_precision=args.mixed_precision)\n    # Sample hyper-parameters for learning rate, batch size, seed and a few other HPs\n    lr = config[\"lr\"]\n    num_epochs = int(config[\"num_epochs\"])\n    seed = int(config[\"seed\"])\n    batch_size = int(config[\"batch_size\"])\n    set_seed(seed)\n\n    train_dataloader, eval_dataloader = get_dataloaders(accelerator, batch_size)\n    metric = evaluate.load(\"glue\", \"mrpc\")\n\n    # If the batch size is too big we use gradient accumulation\n    gradient_accumulation_steps = 1\n    if batch_size > MAX_GPU_BATCH_SIZE and accelerator.distributed_type != DistributedType.TPU:\n        gradient_accumulation_steps = batch_size // MAX_GPU_BATCH_SIZE\n        batch_size = MAX_GPU_BATCH_SIZE\n\n    # Instantiate the model (we build the model here so that the seed also control new weights initialization)\n    model = AutoModelForSequenceClassification.from_pretrained(\"bert-base-cased\", return_dict=True)\n\n    # We could avoid this line since the accelerator is set with `device_placement=True` (default value).\n    # Note that if you are placing tensors on devices manually, this line absolutely needs to be before the optimizer\n    # creation otherwise training will not work on TPU (`accelerate` will kindly throw an error to make us aware of that).\n    model = model.to(accelerator.device)\n\n    # Instantiate optimizer\n    optimizer = AdamW(params=model.parameters(), lr=lr)\n\n    # Instantiate scheduler\n    lr_scheduler = get_linear_schedule_with_warmup(\n        optimizer=optimizer,\n        num_warmup_steps=100,\n        num_training_steps=(len(train_dataloader) * num_epochs) // gradient_accumulation_steps,\n    )\n\n    # Prepare everything\n    # There is no specific order to remember, we just need to unpack the objects in the same order we gave them to the\n    # prepare method.\n    model, optimizer, train_dataloader, eval_dataloader, lr_scheduler = accelerator.prepare(\n        model, optimizer, train_dataloader, eval_dataloader, lr_scheduler\n    )\n\n    # New Code #\n    # We need to initialize the trackers we use. Overall configurations can also be stored\n    if args.with_tracking:\n        run = os.path.split(__file__)[-1].split(\".\")[0]\n        accelerator.init_trackers(run, config)\n\n    # Now we train the model\n    for epoch in range(num_epochs):\n        model.train()\n        # New Code #\n        # For our tracking example, we will log the total loss of each epoch\n        if args.with_tracking:\n            total_loss = 0\n        for step, batch in enumerate(train_dataloader):\n            # We could avoid this line since we set the accelerator with `device_placement=True`.\n            batch.to(accelerator.device)\n            outputs = model(**batch)\n            loss = outputs.loss\n            # New Code #\n            if args.with_tracking:\n                total_loss += loss.detach().float()\n            loss = loss / gradient_accumulation_steps\n            accelerator.backward(loss)\n            if step % gradient_accumulation_steps == 0:\n                optimizer.step()\n                lr_scheduler.step()\n                optimizer.zero_grad()\n\n        model.eval()\n        for step, batch in enumerate(eval_dataloader):\n            # We could avoid this line since we set the accelerator with `device_placement=True` (the default).\n            batch.to(accelerator.device)\n            with torch.no_grad():\n                outputs = model(**batch)\n            predictions = outputs.logits.argmax(dim=-1)\n            predictions, references = accelerator.gather_for_metrics((predictions, batch[\"labels\"]))\n            metric.add_batch(\n                predictions=predictions,\n                references=references,\n            )\n\n        eval_metric = metric.compute()\n        # Use accelerator.print to print only on the main process.\n        accelerator.print(f\"epoch {epoch}:\", eval_metric)\n\n        # New Code #\n        # To actually log, we call `Accelerator.log`\n        # The values passed can be of `str`, `int`, `float` or `dict` of `str` to `float`/`int`\n        if args.with_tracking:\n            accelerator.log(\n                {\n                    \"accuracy\": eval_metric[\"accuracy\"],\n                    \"f1\": eval_metric[\"f1\"],\n                    \"train_loss\": total_loss.item() / len(train_dataloader),\n                    \"epoch\": epoch,\n                },\n                step=epoch,\n            )\n\n    # New Code #\n    # When a run is finished, you should call `accelerator.end_training()`\n    # to close all of the open trackers\n    if args.with_tracking:\n        accelerator.end_training()\n\n\ndef main():\n    parser = argparse.ArgumentParser(description=\"Simple example of training script.\")\n    parser.add_argument(\n        \"--mixed_precision\",\n        type=str,\n        default=None,\n        choices=[\"no\", \"fp16\", \"bf16\", \"fp8\"],\n        help=\"Whether to use mixed precision. Choose\"\n        \"between fp16 and bf16 (bfloat16). Bf16 requires PyTorch >= 1.10.\"\n        \"and an Nvidia Ampere GPU.\",\n    )\n    parser.add_argument(\"--cpu\", action=\"store_true\", help=\"If passed, will train on the CPU.\")\n    parser.add_argument(\n        \"--with_tracking\",\n        action=\"store_true\",\n        help=\"Whether to load in all available experiment trackers from the environment and use them for logging.\",\n    )\n    parser.add_argument(\n        \"--project_dir\",\n        type=str,\n        default=\"logs\",\n        help=\"Location on where to store experiment tracking logs` and relevent project information\",\n    )\n    args = parser.parse_args()\n    config = {\"lr\": 2e-5, \"num_epochs\": 3, \"seed\": 42, \"batch_size\": 16}\n    training_function(config, args)\n\n\nif __name__ == \"__main__\":\n    main()\n", "# coding=utf-8\n# Copyright 2021 The HuggingFace Inc. team. All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nimport argparse\nimport gc\nimport os\nimport threading\n\nimport evaluate\nimport psutil\nimport torch\nfrom datasets import load_dataset\nfrom torch.distributed.fsdp.fully_sharded_data_parallel import FullOptimStateDictConfig, FullStateDictConfig\nfrom torch.utils.data import DataLoader\nfrom transformers import (\n    AutoModelForSequenceClassification,\n    AutoTokenizer,\n    get_linear_schedule_with_warmup,\n    set_seed,\n)\n\nfrom accelerate import Accelerator, DistributedType, FullyShardedDataParallelPlugin\n\n\n########################################################################\n# This is a fully working simple example to use Accelerate\n#\n# This example trains a Bert base model on GLUE MRPC\n# in any of the following settings (with the same script):\n#   - single CPU or single GPU\n#   - multi GPUS (using PyTorch distributed mode)\n#   - (multi) TPUs\n#   - fp16 (mixed-precision) or fp32 (normal precision)\n#   - FSDP\n#\n# This example also demonstrates the checkpointing and sharding capabilities\n#\n# To run it in each of these various modes, follow the instructions\n# in the readme for examples:\n# https://github.com/huggingface/accelerate/tree/main/examples\n#\n########################################################################\n\n\nMAX_GPU_BATCH_SIZE = 16\nEVAL_BATCH_SIZE = 32\n\n\n# New Code #\n# Converting Bytes to Megabytes\ndef b2mb(x):\n    return int(x / 2**20)\n\n\n# New Code #\n# This context manager is used to track the peak memory usage of the process\nclass TorchTracemalloc:\n    def __enter__(self):\n        gc.collect()\n        torch.cuda.empty_cache()\n        torch.cuda.reset_max_memory_allocated()  # reset the peak gauge to zero\n        self.begin = torch.cuda.memory_allocated()\n        self.process = psutil.Process()\n\n        self.cpu_begin = self.cpu_mem_used()\n        self.peak_monitoring = True\n        peak_monitor_thread = threading.Thread(target=self.peak_monitor_func)\n        peak_monitor_thread.daemon = True\n        peak_monitor_thread.start()\n        return self\n\n    def cpu_mem_used(self):\n        \"\"\"get resident set size memory for the current process\"\"\"\n        return self.process.memory_info().rss\n\n    def peak_monitor_func(self):\n        self.cpu_peak = -1\n\n        while True:\n            self.cpu_peak = max(self.cpu_mem_used(), self.cpu_peak)\n\n            # can't sleep or will not catch the peak right (this comment is here on purpose)\n            # time.sleep(0.001) # 1msec\n\n            if not self.peak_monitoring:\n                break\n\n    def __exit__(self, *exc):\n        self.peak_monitoring = False\n\n        gc.collect()\n        torch.cuda.empty_cache()\n        self.end = torch.cuda.memory_allocated()\n        self.peak = torch.cuda.max_memory_allocated()\n        self.used = b2mb(self.end - self.begin)\n        self.peaked = b2mb(self.peak - self.begin)\n\n        self.cpu_end = self.cpu_mem_used()\n        self.cpu_used = b2mb(self.cpu_end - self.cpu_begin)\n        self.cpu_peaked = b2mb(self.cpu_peak - self.cpu_begin)\n        # print(f\"delta used/peak {self.used:4d}/{self.peaked:4d}\")\n\n\n# For testing only\nif os.environ.get(\"TESTING_MOCKED_DATALOADERS\", None) == \"1\":\n    from accelerate.test_utils.training import mocked_dataloaders\n\n    get_dataloaders = mocked_dataloaders  # noqa: F811\n\n\ndef training_function(config, args):\n    # For testing only\n    if os.environ.get(\"TESTING_MOCKED_DATALOADERS\", None) == \"1\":\n        config[\"num_epochs\"] = 2\n\n    # New Code #\n    # Pass the advanced FSDP settings not part of the accelerate config by creating fsdp_plugin\n    fsdp_plugin = FullyShardedDataParallelPlugin(\n        state_dict_config=FullStateDictConfig(offload_to_cpu=False, rank0_only=False),\n        optim_state_dict_config=FullOptimStateDictConfig(offload_to_cpu=False, rank0_only=False),\n    )\n\n    # Initialize accelerator\n    if args.with_tracking:\n        accelerator = Accelerator(\n            cpu=args.cpu,\n            mixed_precision=args.mixed_precision,\n            log_with=\"wandb\",\n            project_dir=args.logging_dir,\n            fsdp_plugin=fsdp_plugin,\n        )\n    else:\n        accelerator = Accelerator(fsdp_plugin=fsdp_plugin)\n    accelerator.print(accelerator.distributed_type)\n\n    if hasattr(args.checkpointing_steps, \"isdigit\"):\n        if args.checkpointing_steps == \"epoch\":\n            checkpointing_steps = args.checkpointing_steps\n        elif args.checkpointing_steps.isdigit():\n            checkpointing_steps = int(args.checkpointing_steps)\n        else:\n            raise ValueError(\n                f\"Argument `checkpointing_steps` must be either a number or `epoch`. `{args.checkpointing_steps}` passed.\"\n            )\n    else:\n        checkpointing_steps = None\n    # Sample hyper-parameters for learning rate, batch size, seed and a few other HPs\n    lr = config[\"lr\"]\n    num_epochs = int(config[\"num_epochs\"])\n    seed = int(config[\"seed\"])\n    batch_size = int(config[\"batch_size\"])\n\n    # We need to initialize the trackers we use, and also store our configuration\n    if args.with_tracking:\n        experiment_config = vars(args)\n        accelerator.init_trackers(\"fsdp_glue_no_trainer\", experiment_config)\n\n    tokenizer = AutoTokenizer.from_pretrained(args.model_name_or_path)\n    datasets = load_dataset(\"glue\", \"mrpc\")\n    metric = evaluate.load(\"glue\", \"mrpc\")\n\n    def tokenize_function(examples):\n        # max_length=None => use the model max length (it's actually the default)\n        outputs = tokenizer(examples[\"sentence1\"], examples[\"sentence2\"], truncation=True, max_length=None)\n        return outputs\n\n    # Apply the method we just defined to all the examples in all the splits of the dataset\n    # starting with the main process first:\n    with accelerator.main_process_first():\n        tokenized_datasets = datasets.map(\n            tokenize_function,\n            batched=True,\n            remove_columns=[\"idx\", \"sentence1\", \"sentence2\"],\n        )\n\n    # We also rename the 'label' column to 'labels' which is the expected name for labels by the models of the\n    # transformers library\n    tokenized_datasets = tokenized_datasets.rename_column(\"label\", \"labels\")\n\n    # If the batch size is too big we use gradient accumulation\n    gradient_accumulation_steps = 1\n    if batch_size > MAX_GPU_BATCH_SIZE and accelerator.distributed_type != DistributedType.TPU:\n        gradient_accumulation_steps = batch_size // MAX_GPU_BATCH_SIZE\n        batch_size = MAX_GPU_BATCH_SIZE\n\n    def collate_fn(examples):\n        # On TPU it's best to pad everything to the same length or training will be very slow.\n        max_length = 128 if accelerator.distributed_type == DistributedType.TPU else None\n        # When using mixed precision we want round multiples of 8/16\n        if accelerator.mixed_precision == \"fp8\":\n            pad_to_multiple_of = 16\n        elif accelerator.mixed_precision != \"no\":\n            pad_to_multiple_of = 8\n        else:\n            pad_to_multiple_of = None\n\n        return tokenizer.pad(\n            examples,\n            padding=\"longest\",\n            max_length=max_length,\n            pad_to_multiple_of=pad_to_multiple_of,\n            return_tensors=\"pt\",\n        )\n\n    # Instantiate dataloaders.\n    train_dataloader = DataLoader(\n        tokenized_datasets[\"train\"], shuffle=True, collate_fn=collate_fn, batch_size=batch_size\n    )\n    eval_dataloader = DataLoader(\n        tokenized_datasets[\"validation\"], shuffle=False, collate_fn=collate_fn, batch_size=EVAL_BATCH_SIZE\n    )\n\n    set_seed(seed)\n\n    # Instantiate the model (we build the model here so that the seed also control new weights initialization)\n    model = AutoModelForSequenceClassification.from_pretrained(\n        args.model_name_or_path, return_dict=True, low_cpu_mem_usage=True\n    )\n\n    # New Code #\n    # For FSDP feature, it is highly recommended and efficient to prepare the model before creating optimizer\n    model = accelerator.prepare(model)\n    accelerator.print(model)\n\n    # Instantiate optimizer\n    # New Code #\n    # For FSDP feature, at present it doesn't support multiple parameter groups,\n    # so we need to create a single parameter group for the whole model\n    optimizer = torch.optim.AdamW(params=model.parameters(), lr=lr, weight_decay=2e-4)\n\n    # Instantiate scheduler\n    lr_scheduler = get_linear_schedule_with_warmup(\n        optimizer=optimizer,\n        num_warmup_steps=10,\n        num_training_steps=(len(train_dataloader) * num_epochs) // gradient_accumulation_steps,\n    )\n\n    # New Code #\n    # For FSDP feature, prepare everything except the model as we have already prepared the model\n    # before creating the optimizer\n    # There is no specific order to remember, we just need to unpack the objects in the same order we gave them to the\n    # prepare method.\n    optimizer, train_dataloader, eval_dataloader, lr_scheduler = accelerator.prepare(\n        optimizer, train_dataloader, eval_dataloader, lr_scheduler\n    )\n\n    overall_step = 0\n\n    # Potentially load in the weights and states from a previous save\n    if args.resume_from_checkpoint:\n        if args.resume_from_checkpoint is not None or args.resume_from_checkpoint != \"\":\n            accelerator.print(f\"Resumed from checkpoint: {args.resume_from_checkpoint}\")\n            accelerator.load_state(args.resume_from_checkpoint)\n            path = os.path.basename(args.resume_from_checkpoint)\n        else:\n            # Get the most recent checkpoint\n            dirs = [f.name for f in os.scandir(os.getcwd()) if f.is_dir()]\n            dirs.sort(key=os.path.getctime)\n            path = dirs[-1]  # Sorts folders by date modified, most recent checkpoint is the last\n        # Extract `epoch_{i}` or `step_{i}`\n        training_difference = os.path.splitext(path)[0]\n\n        if \"epoch\" in training_difference:\n            num_epochs -= int(training_difference.replace(\"epoch_\", \"\"))\n            resume_step = None\n        else:\n            resume_step = int(training_difference.replace(\"step_\", \"\"))\n            num_epochs -= resume_step // len(train_dataloader)\n            # If resuming by step, we also need to know exactly how far into the DataLoader we went\n            resume_step = (num_epochs * len(train_dataloader)) - resume_step\n\n    # Now we train the model\n    for epoch in range(num_epochs):\n        # New Code #\n        # context manager to track the peak memory usage during the training epoch\n        with TorchTracemalloc() as tracemalloc:\n            model.train()\n            if args.with_tracking:\n                total_loss = 0\n            for step, batch in enumerate(train_dataloader):\n                # We need to skip steps until we reach the resumed step\n                if args.resume_from_checkpoint and epoch == 0:\n                    if resume_step is not None and step < resume_step:\n                        pass\n                # We could avoid this line since we set the accelerator with `device_placement=True`.\n                batch.to(accelerator.device)\n                outputs = model(**batch)\n                loss = outputs.loss\n                loss = loss / gradient_accumulation_steps\n                # We keep track of the loss at each epoch\n                if args.with_tracking:\n                    total_loss += loss.detach().float()\n                accelerator.backward(loss)\n                if step % gradient_accumulation_steps == 0:\n                    optimizer.step()\n                    lr_scheduler.step()\n                    optimizer.zero_grad()\n                    # accelerator.print(lr_scheduler.get_lr())\n\n                overall_step += 1\n\n                if isinstance(checkpointing_steps, int):\n                    output_dir = f\"step_{overall_step}\"\n                    if overall_step % checkpointing_steps == 0:\n                        if args.output_dir is not None:\n                            output_dir = os.path.join(args.output_dir, output_dir)\n                        accelerator.save_state(output_dir)\n        # New Code #\n        # Printing the GPU memory usage details such as allocated memory, peak memory, and total memory usage\n        accelerator.print(\"Memory before entering the train : {}\".format(b2mb(tracemalloc.begin)))\n        accelerator.print(\"Memory consumed at the end of the train (end-begin): {}\".format(tracemalloc.used))\n        accelerator.print(\"Peak Memory consumed during the train (max-begin): {}\".format(tracemalloc.peaked))\n        accelerator.print(\n            \"Total Peak Memory consumed during the train (max): {}\".format(\n                tracemalloc.peaked + b2mb(tracemalloc.begin)\n            )\n        )\n        # Logging the peak memory usage of the GPU to the tracker\n        if args.with_tracking:\n            accelerator.log(\n                {\n                    \"train_total_peak_memory\": tracemalloc.peaked + b2mb(tracemalloc.begin),\n                },\n                step=epoch,\n            )\n\n        # New Code #\n        # context manager to track the peak memory usage during the evaluation\n        with TorchTracemalloc() as tracemalloc:\n            model.eval()\n            for step, batch in enumerate(eval_dataloader):\n                # We could avoid this line since we set the accelerator with `device_placement=True`.\n                batch.to(accelerator.device)\n                with torch.no_grad():\n                    outputs = model(**batch)\n                predictions = outputs.logits.argmax(dim=-1)\n                predictions, references = accelerator.gather_for_metrics((predictions, batch[\"labels\"]))\n                metric.add_batch(\n                    predictions=predictions,\n                    references=references,\n                )\n\n            eval_metric = metric.compute()\n            # Use accelerator.print to print only on the main process.\n            accelerator.print(f\"epoch {epoch}:\", eval_metric)\n            if args.with_tracking:\n                accelerator.log(\n                    {\n                        \"accuracy\": eval_metric[\"accuracy\"],\n                        \"f1\": eval_metric[\"f1\"],\n                        \"train_loss\": total_loss.item() / len(train_dataloader),\n                    },\n                    step=epoch,\n                )\n\n            if checkpointing_steps == \"epoch\":\n                output_dir = f\"epoch_{epoch}\"\n                if args.output_dir is not None:\n                    output_dir = os.path.join(args.output_dir, output_dir)\n                accelerator.save_state(output_dir)\n        # New Code #\n        # Printing the GPU memory usage details such as allocated memory, peak memory, and total memory usage\n        accelerator.print(\"Memory before entering the eval : {}\".format(b2mb(tracemalloc.begin)))\n        accelerator.print(\"Memory consumed at the end of the eval (end-begin): {}\".format(tracemalloc.used))\n        accelerator.print(\"Peak Memory consumed during the eval (max-begin): {}\".format(tracemalloc.peaked))\n        accelerator.print(\n            \"Total Peak Memory consumed during the eval (max): {}\".format(tracemalloc.peaked + b2mb(tracemalloc.begin))\n        )\n        # Logging the peak memory usage of the GPU to the tracker\n        if args.with_tracking:\n            accelerator.log(\n                {\n                    \"eval_total_peak_memory\": tracemalloc.peaked + b2mb(tracemalloc.begin),\n                },\n                step=epoch,\n            )\n\n    if args.with_tracking:\n        accelerator.end_training()\n\n\ndef main():\n    parser = argparse.ArgumentParser(description=\"Simple example of training script.\")\n    parser.add_argument(\n        \"--mixed_precision\",\n        type=str,\n        default=None,\n        choices=[\"no\", \"fp16\", \"bf16\", \"fp8\"],\n        help=\"Whether to use mixed precision. Choose\"\n        \"between fp16 and bf16 (bfloat16). Bf16 requires PyTorch >= 1.10.\"\n        \"and an Nvidia Ampere GPU.\",\n    )\n    parser.add_argument(\"--cpu\", action=\"store_true\", help=\"If passed, will train on the CPU.\")\n    parser.add_argument(\n        \"--checkpointing_steps\",\n        type=str,\n        default=None,\n        help=\"Whether the various states should be saved at the end of every n steps, or 'epoch' for each epoch.\",\n    )\n    parser.add_argument(\n        \"--resume_from_checkpoint\",\n        type=str,\n        default=None,\n        help=\"If the training should continue from a checkpoint folder.\",\n    )\n    parser.add_argument(\n        \"--with_tracking\",\n        action=\"store_true\",\n        help=\"Whether to load in all available experiment trackers from the environment and use them for logging.\",\n    )\n    parser.add_argument(\n        \"--output_dir\",\n        type=str,\n        default=\".\",\n        help=\"Optional save directory where all checkpoint folders will be stored. Default is the current working directory.\",\n    )\n    parser.add_argument(\n        \"--logging_dir\",\n        type=str,\n        default=\"logs\",\n        help=\"Location on where to store experiment tracking logs`\",\n    )\n    parser.add_argument(\n        \"--model_name_or_path\",\n        type=str,\n        help=\"Path to pretrained model or model identifier from huggingface.co/models.\",\n        required=True,\n    )\n    args = parser.parse_args()\n    config = {\"lr\": 2e-5, \"num_epochs\": 3, \"seed\": 42, \"batch_size\": 16}\n    training_function(config, args)\n\n\nif __name__ == \"__main__\":\n    main()\n", "#!/usr/bin/env python\n# coding=utf-8\n# Copyright 2021 The HuggingFace Inc. team. All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\"\"\"\nFine-tuning the library models for causal language modeling (GPT, GPT-2, CTRL, ...)\non a text file or a dataset without using HuggingFace Trainer.\n\nHere is the full list of checkpoints on the hub that can be fine-tuned by this script:\nhttps://huggingface.co/models?filter=text-generation\n\"\"\"\n# You can also adapt this script on your own causal language modeling task. Pointers for this are left as comments.\n\nimport argparse\nimport json\nimport logging\nimport math\nimport os\nimport random\nfrom itertools import chain\nfrom pathlib import Path\n\nimport datasets\nimport torch\nimport transformers\nfrom datasets import load_dataset\nfrom huggingface_hub import Repository\nfrom torch.utils.data import DataLoader\nfrom tqdm.auto import tqdm\nfrom transformers import (\n    CONFIG_MAPPING,\n    MODEL_MAPPING,\n    AutoConfig,\n    AutoModelForCausalLM,\n    AutoTokenizer,\n    SchedulerType,\n    default_data_collator,\n    get_scheduler,\n)\nfrom transformers.utils import check_min_version, get_full_repo_name, send_example_telemetry\nfrom transformers.utils.versions import require_version\n\nfrom accelerate import Accelerator, DistributedType\nfrom accelerate.logging import get_logger\nfrom accelerate.utils import MegatronLMDummyScheduler, set_seed\n\n\n# Will error if the minimal version of Transformers is not installed. Remove at your own risks.\ncheck_min_version(\"4.23.0.dev0\")\n\nlogger = get_logger(__name__)\n\nrequire_version(\"datasets>=1.8.0\", \"To fix: pip install -r examples/pytorch/language-modeling/requirements.txt\")\n\nMODEL_CONFIG_CLASSES = list(MODEL_MAPPING.keys())\nMODEL_TYPES = tuple(conf.model_type for conf in MODEL_CONFIG_CLASSES)\n\n\ndef parse_args():\n    parser = argparse.ArgumentParser(description=\"Finetune a transformers model on a causal language modeling task\")\n    parser.add_argument(\n        \"--dataset_name\",\n        type=str,\n        default=None,\n        help=\"The name of the dataset to use (via the datasets library).\",\n    )\n    parser.add_argument(\n        \"--dataset_config_name\",\n        type=str,\n        default=None,\n        help=\"The configuration name of the dataset to use (via the datasets library).\",\n    )\n    parser.add_argument(\n        \"--train_file\", type=str, default=None, help=\"A csv or a json file containing the training data.\"\n    )\n    parser.add_argument(\n        \"--validation_file\", type=str, default=None, help=\"A csv or a json file containing the validation data.\"\n    )\n    parser.add_argument(\n        \"--validation_split_percentage\",\n        default=5,\n        help=\"The percentage of the train set used as validation set in case there's no validation split\",\n    )\n    parser.add_argument(\n        \"--model_name_or_path\",\n        type=str,\n        help=\"Path to pretrained model or model identifier from huggingface.co/models.\",\n        required=False,\n    )\n    parser.add_argument(\n        \"--config_name\",\n        type=str,\n        default=None,\n        help=\"Pretrained config name or path if not the same as model_name\",\n    )\n    parser.add_argument(\n        \"--tokenizer_name\",\n        type=str,\n        default=None,\n        help=\"Pretrained tokenizer name or path if not the same as model_name\",\n    )\n    parser.add_argument(\n        \"--use_slow_tokenizer\",\n        action=\"store_true\",\n        help=\"If passed, will use a slow tokenizer (not backed by the \ud83e\udd17 Tokenizers library).\",\n    )\n    parser.add_argument(\n        \"--per_device_train_batch_size\",\n        type=int,\n        default=8,\n        help=\"Batch size (per device) for the training dataloader.\",\n    )\n    parser.add_argument(\n        \"--per_device_eval_batch_size\",\n        type=int,\n        default=8,\n        help=\"Batch size (per device) for the evaluation dataloader.\",\n    )\n    parser.add_argument(\n        \"--learning_rate\",\n        type=float,\n        default=5e-5,\n        help=\"Initial learning rate (after the potential warmup period) to use.\",\n    )\n    parser.add_argument(\"--weight_decay\", type=float, default=0.0, help=\"Weight decay to use.\")\n    parser.add_argument(\"--num_train_epochs\", type=int, default=3, help=\"Total number of training epochs to perform.\")\n    parser.add_argument(\n        \"--max_train_steps\",\n        type=int,\n        default=None,\n        help=\"Total number of training steps to perform. If provided, overrides num_train_epochs.\",\n    )\n    parser.add_argument(\n        \"--gradient_accumulation_steps\",\n        type=int,\n        default=1,\n        help=\"Number of updates steps to accumulate before performing a backward/update pass.\",\n    )\n    parser.add_argument(\n        \"--lr_scheduler_type\",\n        type=SchedulerType,\n        default=\"linear\",\n        help=\"The scheduler type to use.\",\n        choices=[\"linear\", \"cosine\", \"cosine_with_restarts\", \"polynomial\", \"constant\", \"constant_with_warmup\"],\n    )\n    parser.add_argument(\n        \"--num_warmup_steps\", type=int, default=0, help=\"Number of steps for the warmup in the lr scheduler.\"\n    )\n    parser.add_argument(\"--output_dir\", type=str, default=None, help=\"Where to store the final model.\")\n    parser.add_argument(\"--seed\", type=int, default=None, help=\"A seed for reproducible training.\")\n    parser.add_argument(\n        \"--model_type\",\n        type=str,\n        default=None,\n        help=\"Model type to use if training from scratch.\",\n        choices=MODEL_TYPES,\n    )\n    parser.add_argument(\n        \"--block_size\",\n        type=int,\n        default=None,\n        help=(\n            \"Optional input sequence length after tokenization. The training dataset will be truncated in block of\"\n            \" this size for training. Default to the model max input length for single sentence inputs (take into\"\n            \" account special tokens).\"\n        ),\n    )\n    parser.add_argument(\n        \"--preprocessing_num_workers\",\n        type=int,\n        default=None,\n        help=\"The number of processes to use for the preprocessing.\",\n    )\n    parser.add_argument(\n        \"--overwrite_cache\", action=\"store_true\", help=\"Overwrite the cached training and evaluation sets\"\n    )\n    parser.add_argument(\n        \"--no_keep_linebreaks\", action=\"store_true\", help=\"Do not keep line breaks when using TXT files.\"\n    )\n    parser.add_argument(\"--push_to_hub\", action=\"store_true\", help=\"Whether or not to push the model to the Hub.\")\n    parser.add_argument(\n        \"--hub_model_id\", type=str, help=\"The name of the repository to keep in sync with the local `output_dir`.\"\n    )\n    parser.add_argument(\"--hub_token\", type=str, help=\"The token to use to push to the Model Hub.\")\n    parser.add_argument(\n        \"--checkpointing_steps\",\n        type=str,\n        default=None,\n        help=\"Whether the various states should be saved at the end of every n steps, or 'epoch' for each epoch.\",\n    )\n    parser.add_argument(\n        \"--resume_from_checkpoint\",\n        type=str,\n        default=None,\n        help=\"If the training should continue from a checkpoint folder.\",\n    )\n    parser.add_argument(\n        \"--with_tracking\",\n        action=\"store_true\",\n        help=\"Whether to enable experiment trackers for logging.\",\n    )\n    parser.add_argument(\n        \"--report_to\",\n        type=str,\n        default=\"all\",\n        help=(\n            'The integration to report the results and logs to. Supported platforms are `\"tensorboard\"`,'\n            ' `\"wandb\"` and `\"comet_ml\"`. Use `\"all\"` (default) to report to all integrations.'\n            \"Only applicable when `--with_tracking` is passed.\"\n        ),\n    )\n    args = parser.parse_args()\n\n    # Sanity checks\n    if args.dataset_name is None and args.train_file is None and args.validation_file is None:\n        raise ValueError(\"Need either a dataset name or a training/validation file.\")\n    else:\n        if args.train_file is not None:\n            extension = args.train_file.split(\".\")[-1]\n            assert extension in [\"csv\", \"json\", \"txt\"], \"`train_file` should be a csv, json or txt file.\"\n        if args.validation_file is not None:\n            extension = args.validation_file.split(\".\")[-1]\n            assert extension in [\"csv\", \"json\", \"txt\"], \"`validation_file` should be a csv, json or txt file.\"\n\n    if args.push_to_hub:\n        assert args.output_dir is not None, \"Need an `output_dir` to create a repo when `--push_to_hub` is passed.\"\n\n    return args\n\n\ndef main():\n    args = parse_args()\n\n    # Sending telemetry. Tracking the example usage helps us better allocate resources to maintain them. The\n    # information sent is the one passed as arguments along with your Python/PyTorch versions.\n    send_example_telemetry(\"run_clm_no_trainer\", args)\n\n    # Initialize the accelerator. We will let the accelerator handle device placement for us in this example.\n    # If we're using tracking, we also need to initialize it here and it will by default pick up all supported trackers\n    # in the environment\n    accelerator_log_kwargs = {}\n\n    if args.with_tracking:\n        accelerator_log_kwargs[\"log_with\"] = args.report_to\n        accelerator_log_kwargs[\"logging_dir\"] = args.output_dir\n\n    accelerator = Accelerator(gradient_accumulation_steps=args.gradient_accumulation_steps, **accelerator_log_kwargs)\n\n    # Make one log on every process with the configuration for debugging.\n    logging.basicConfig(\n        format=\"%(asctime)s - %(levelname)s - %(name)s - %(message)s\",\n        datefmt=\"%m/%d/%Y %H:%M:%S\",\n        level=logging.INFO,\n    )\n    logger.info(accelerator.state, main_process_only=False)\n    if accelerator.is_local_main_process:\n        datasets.utils.logging.set_verbosity_warning()\n        transformers.utils.logging.set_verbosity_info()\n    else:\n        datasets.utils.logging.set_verbosity_error()\n        transformers.utils.logging.set_verbosity_error()\n\n    # If passed along, set the training seed now.\n    if args.seed is not None:\n        set_seed(args.seed)\n\n    # Handle the repository creation\n    if accelerator.is_main_process:\n        if args.push_to_hub:\n            if args.hub_model_id is None:\n                repo_name = get_full_repo_name(Path(args.output_dir).name, token=args.hub_token)\n            else:\n                repo_name = args.hub_model_id\n            repo = Repository(args.output_dir, clone_from=repo_name)\n\n            with open(os.path.join(args.output_dir, \".gitignore\"), \"w+\") as gitignore:\n                if \"step_*\" not in gitignore:\n                    gitignore.write(\"step_*\\n\")\n                if \"epoch_*\" not in gitignore:\n                    gitignore.write(\"epoch_*\\n\")\n        elif args.output_dir is not None:\n            os.makedirs(args.output_dir, exist_ok=True)\n    accelerator.wait_for_everyone()\n\n    # Get the datasets: you can either provide your own CSV/JSON/TXT training and evaluation files (see below)\n    # or just provide the name of one of the public datasets available on the hub at https://huggingface.co/datasets/\n    # (the dataset will be downloaded automatically from the datasets Hub).\n    #\n    # For CSV/JSON files, this script will use the column called 'text' or the first column if no column called\n    # 'text' is found. You can easily tweak this behavior (see below).\n    #\n    # In distributed training, the load_dataset function guarantee that only one local process can concurrently\n    # download the dataset.\n    if args.dataset_name is not None:\n        # Downloading and loading a dataset from the hub.\n        raw_datasets = load_dataset(args.dataset_name, args.dataset_config_name)\n        if \"validation\" not in raw_datasets.keys():\n            raw_datasets[\"validation\"] = load_dataset(\n                args.dataset_name,\n                args.dataset_config_name,\n                split=f\"train[:{args.validation_split_percentage}%]\",\n            )\n            raw_datasets[\"train\"] = load_dataset(\n                args.dataset_name,\n                args.dataset_config_name,\n                split=f\"train[{args.validation_split_percentage}%:]\",\n            )\n    else:\n        data_files = {}\n        dataset_args = {}\n        if args.train_file is not None:\n            data_files[\"train\"] = args.train_file\n        if args.validation_file is not None:\n            data_files[\"validation\"] = args.validation_file\n        extension = args.train_file.split(\".\")[-1]\n        if extension == \"txt\":\n            extension = \"text\"\n            dataset_args[\"keep_linebreaks\"] = not args.no_keep_linebreaks\n        raw_datasets = load_dataset(extension, data_files=data_files, **dataset_args)\n        # If no validation data is there, validation_split_percentage will be used to divide the dataset.\n        if \"validation\" not in raw_datasets.keys():\n            raw_datasets[\"validation\"] = load_dataset(\n                extension,\n                data_files=data_files,\n                split=f\"train[:{args.validation_split_percentage}%]\",\n                **dataset_args,\n            )\n            raw_datasets[\"train\"] = load_dataset(\n                extension,\n                data_files=data_files,\n                split=f\"train[{args.validation_split_percentage}%:]\",\n                **dataset_args,\n            )\n\n    # See more about loading any type of standard or custom dataset (from files, python dict, pandas DataFrame, etc) at\n    # https://huggingface.co/docs/datasets/loading_datasets.html.\n\n    # Load pretrained model and tokenizer\n    #\n    # In distributed training, the .from_pretrained methods guarantee that only one local process can concurrently\n    # download model & vocab.\n    if args.config_name:\n        config = AutoConfig.from_pretrained(args.config_name)\n    elif args.model_name_or_path:\n        config = AutoConfig.from_pretrained(args.model_name_or_path)\n    else:\n        config = CONFIG_MAPPING[args.model_type]()\n        logger.warning(\"You are instantiating a new config instance from scratch.\")\n\n    if args.tokenizer_name:\n        tokenizer = AutoTokenizer.from_pretrained(args.tokenizer_name, use_fast=not args.use_slow_tokenizer)\n    elif args.model_name_or_path:\n        tokenizer = AutoTokenizer.from_pretrained(args.model_name_or_path, use_fast=not args.use_slow_tokenizer)\n    else:\n        raise ValueError(\n            \"You are instantiating a new tokenizer from scratch. This is not supported by this script.\"\n            \"You can do it from another script, save it, and load it from here, using --tokenizer_name.\"\n        )\n\n    if args.model_name_or_path:\n        model = AutoModelForCausalLM.from_pretrained(\n            args.model_name_or_path,\n            from_tf=bool(\".ckpt\" in args.model_name_or_path),\n            config=config,\n        )\n    else:\n        logger.info(\"Training new model from scratch\")\n        model = AutoModelForCausalLM.from_config(config)\n\n    model.resize_token_embeddings(len(tokenizer))\n\n    # Preprocessing the datasets.\n    # First we tokenize all the texts.\n    column_names = raw_datasets[\"train\"].column_names\n    text_column_name = \"text\" if \"text\" in column_names else column_names[0]\n\n    def tokenize_function(examples):\n        return tokenizer(examples[text_column_name])\n\n    with accelerator.main_process_first():\n        tokenized_datasets = raw_datasets.map(\n            tokenize_function,\n            batched=True,\n            num_proc=args.preprocessing_num_workers,\n            remove_columns=column_names,\n            load_from_cache_file=not args.overwrite_cache,\n            desc=\"Running tokenizer on dataset\",\n        )\n\n    if args.block_size is None:\n        block_size = tokenizer.model_max_length\n        if block_size > 1024:\n            logger.warning(\n                f\"The tokenizer picked seems to have a very large `model_max_length` ({tokenizer.model_max_length}). \"\n                \"Picking 1024 instead. You can change that default value by passing --block_size xxx.\"\n            )\n        block_size = 1024\n    else:\n        if args.block_size > tokenizer.model_max_length:\n            logger.warning(\n                f\"The block_size passed ({args.block_size}) is larger than the maximum length for the model\"\n                f\"({tokenizer.model_max_length}). Using block_size={tokenizer.model_max_length}.\"\n            )\n        block_size = min(args.block_size, tokenizer.model_max_length)\n\n    # Main data processing function that will concatenate all texts from our dataset and generate chunks of block_size.\n    def group_texts(examples):\n        # Concatenate all texts.\n        concatenated_examples = {k: list(chain(*examples[k])) for k in examples.keys()}\n        total_length = len(concatenated_examples[list(examples.keys())[0]])\n        # We drop the small remainder, we could add padding if the model supported it instead of this drop, you can\n        # customize this part to your needs.\n        if total_length >= block_size:\n            total_length = (total_length // block_size) * block_size\n        # Split by chunks of max_len.\n        result = {\n            k: [t[i : i + block_size] for i in range(0, total_length, block_size)]\n            for k, t in concatenated_examples.items()\n        }\n        result[\"labels\"] = result[\"input_ids\"].copy()\n        return result\n\n    # Note that with `batched=True`, this map processes 1,000 texts together, so group_texts throws away a remainder\n    # for each of those groups of 1,000 texts. You can adjust that batch_size here but a higher value might be slower\n    # to preprocess.\n    #\n    # To speed up this part, we use multiprocessing. See the documentation of the map method for more information:\n    # https://huggingface.co/docs/datasets/package_reference/main_classes.html#datasets.Dataset.map\n\n    with accelerator.main_process_first():\n        lm_datasets = tokenized_datasets.map(\n            group_texts,\n            batched=True,\n            num_proc=args.preprocessing_num_workers,\n            load_from_cache_file=not args.overwrite_cache,\n            desc=f\"Grouping texts in chunks of {block_size}\",\n        )\n\n    train_dataset = lm_datasets[\"train\"]\n    eval_dataset = lm_datasets[\"validation\"]\n\n    # Log a few random samples from the training set:\n    for index in random.sample(range(len(train_dataset)), 3):\n        logger.info(f\"Sample {index} of the training set: {train_dataset[index]}.\")\n\n    # DataLoaders creation:\n    train_dataloader = DataLoader(\n        train_dataset, shuffle=True, collate_fn=default_data_collator, batch_size=args.per_device_train_batch_size\n    )\n    eval_dataloader = DataLoader(\n        eval_dataset, collate_fn=default_data_collator, batch_size=args.per_device_eval_batch_size\n    )\n\n    # Optimizer\n    # Split weights in two groups, one with weight decay and the other not.\n    no_decay = [\"bias\", \"layer_norm.weight\"]\n    optimizer_grouped_parameters = [\n        {\n            \"params\": [p for n, p in model.named_parameters() if not any(nd in n for nd in no_decay)],\n            \"weight_decay\": args.weight_decay,\n        },\n        {\n            \"params\": [p for n, p in model.named_parameters() if any(nd in n for nd in no_decay)],\n            \"weight_decay\": 0.0,\n        },\n    ]\n    optimizer = torch.optim.AdamW(optimizer_grouped_parameters, lr=args.learning_rate)\n\n    # Scheduler and math around the number of training steps.\n    overrode_max_train_steps = False\n    num_update_steps_per_epoch = math.ceil(len(train_dataloader) / args.gradient_accumulation_steps)\n    if args.max_train_steps is None:\n        args.max_train_steps = args.num_train_epochs * num_update_steps_per_epoch\n        overrode_max_train_steps = True\n\n    # New Code\n    # For Megatron-LM, we need to use `MegatronLMDummyScheduler` instead of regular schedulers\n    if accelerator.distributed_type == DistributedType.MEGATRON_LM:\n        lr_scheduler = MegatronLMDummyScheduler(\n            optimizer=optimizer,\n            total_num_steps=args.max_train_steps,\n            warmup_num_steps=args.num_warmup_steps,\n        )\n    else:\n        lr_scheduler = get_scheduler(\n            name=args.lr_scheduler_type,\n            optimizer=optimizer,\n            num_warmup_steps=args.num_warmup_steps * args.gradient_accumulation_steps,\n            num_training_steps=args.max_train_steps * args.gradient_accumulation_steps,\n        )\n\n    # Prepare everything with our `accelerator`.\n    model, optimizer, train_dataloader, eval_dataloader, lr_scheduler = accelerator.prepare(\n        model, optimizer, train_dataloader, eval_dataloader, lr_scheduler\n    )\n\n    # On TPU, the tie weights in our model have been disconnected, so we need to restore the ties.\n    if accelerator.distributed_type == DistributedType.TPU:\n        model.tie_weights()\n\n    # We need to recalculate our total training steps as the size of the training dataloader may have changed.\n    num_update_steps_per_epoch = math.ceil(len(train_dataloader) / args.gradient_accumulation_steps)\n    if overrode_max_train_steps:\n        args.max_train_steps = args.num_train_epochs * num_update_steps_per_epoch\n    # Afterwards we recalculate our number of training epochs\n    args.num_train_epochs = math.ceil(args.max_train_steps / num_update_steps_per_epoch)\n\n    # Figure out how many steps we should save the Accelerator states\n    checkpointing_steps = args.checkpointing_steps\n    if checkpointing_steps is not None and checkpointing_steps.isdigit():\n        checkpointing_steps = int(checkpointing_steps)\n\n    # We need to initialize the trackers we use, and also store our configuration.\n    # The trackers initializes automatically on the main process.\n    if args.with_tracking:\n        experiment_config = vars(args)\n        # TensorBoard cannot log Enums, need the raw value\n        experiment_config[\"lr_scheduler_type\"] = experiment_config[\"lr_scheduler_type\"].value\n        accelerator.init_trackers(\"clm_no_trainer\", experiment_config)\n\n    # Train!\n    # New Code\n    # For Megatron-LM, we need to get `global_batch_size` from megatron_lm_plugin\n    # as it handles the specifics related to data parallelism, tensor model parallelism and pipeline parallelism\n    if accelerator.distributed_type == DistributedType.MEGATRON_LM:\n        total_batch_size = accelerator.state.megatron_lm_plugin.global_batch_size\n    else:\n        total_batch_size = (\n            args.per_device_train_batch_size * accelerator.num_processes * args.gradient_accumulation_steps\n        )\n\n    logger.info(\"***** Running training *****\")\n    logger.info(f\"  Num examples = {len(train_dataset)}\")\n    logger.info(f\"  Num Epochs = {args.num_train_epochs}\")\n    logger.info(f\"  Instantaneous batch size per device = {args.per_device_train_batch_size}\")\n    logger.info(f\"  Total train batch size (w. parallel, distributed & accumulation) = {total_batch_size}\")\n    logger.info(f\"  Gradient Accumulation steps = {args.gradient_accumulation_steps}\")\n    logger.info(f\"  Total optimization steps = {args.max_train_steps}\")\n    # Only show the progress bar once on each machine.\n    progress_bar = tqdm(range(args.max_train_steps), disable=not accelerator.is_local_main_process)\n    completed_steps = 0\n    starting_epoch = 0\n\n    # Potentially load in the weights and states from a previous save\n    if args.resume_from_checkpoint:\n        if args.resume_from_checkpoint is not None or args.resume_from_checkpoint != \"\":\n            accelerator.print(f\"Resumed from checkpoint: {args.resume_from_checkpoint}\")\n            accelerator.load_state(args.resume_from_checkpoint)\n            path = os.path.basename(args.resume_from_checkpoint)\n        else:\n            # Get the most recent checkpoint\n            dirs = [f.name for f in os.scandir(os.getcwd()) if f.is_dir()]\n            dirs.sort(key=os.path.getctime)\n            path = dirs[-1]  # Sorts folders by date modified, most recent checkpoint is the last\n        # Extract `epoch_{i}` or `step_{i}`\n        training_difference = os.path.splitext(path)[0]\n\n        if \"epoch\" in training_difference:\n            starting_epoch = int(training_difference.replace(\"epoch_\", \"\")) + 1\n            resume_step = None\n        else:\n            # need to multiply `gradient_accumulation_steps` to reflect real steps\n            resume_step = int(training_difference.replace(\"step_\", \"\")) * args.gradient_accumulation_steps\n            starting_epoch = resume_step // len(train_dataloader)\n            resume_step -= starting_epoch * len(train_dataloader)\n\n    # update the progress_bar if load from checkpoint\n    progress_bar.update(starting_epoch * num_update_steps_per_epoch)\n    completed_steps = starting_epoch * num_update_steps_per_epoch\n\n    for epoch in range(starting_epoch, args.num_train_epochs):\n        model.train()\n        if args.with_tracking:\n            total_loss = 0\n        for step, batch in enumerate(train_dataloader):\n            # We need to skip steps until we reach the resumed step\n            if args.resume_from_checkpoint and epoch == starting_epoch:\n                if resume_step is not None and step < resume_step:\n                    if step % args.gradient_accumulation_steps == 0:\n                        progress_bar.update(1)\n                        completed_steps += 1\n                    continue\n\n            with accelerator.accumulate(model):\n                outputs = model(**batch)\n                loss = outputs.loss\n                # We keep track of the loss at each epoch\n                if args.with_tracking:\n                    total_loss += loss.detach().float()\n                accelerator.backward(loss)\n                optimizer.step()\n                lr_scheduler.step()\n                optimizer.zero_grad()\n\n            # Checks if the accelerator has performed an optimization step behind the scenes\n            if accelerator.sync_gradients:\n                progress_bar.update(1)\n                completed_steps += 1\n\n            if isinstance(checkpointing_steps, int):\n                if completed_steps % checkpointing_steps == 0:\n                    output_dir = f\"step_{completed_steps }\"\n                    if args.output_dir is not None:\n                        output_dir = os.path.join(args.output_dir, output_dir)\n                    accelerator.save_state(output_dir)\n            if completed_steps >= args.max_train_steps:\n                break\n\n        model.eval()\n        losses = []\n        for step, batch in enumerate(eval_dataloader):\n            with torch.no_grad():\n                outputs = model(**batch)\n\n            loss = outputs.loss\n            # New Code\n            # For Megatron-LM, the losses are already averaged across the data parallel group\n            if accelerator.distributed_type == DistributedType.MEGATRON_LM:\n                losses.append(loss)\n            else:\n                losses.append(accelerator.gather_for_metrics(loss.repeat(args.per_device_eval_batch_size)))\n        try:\n            if accelerator.distributed_type == DistributedType.MEGATRON_LM:\n                losses = torch.tensor(losses)\n            else:\n                losses = torch.cat(losses)\n            eval_loss = torch.mean(losses)\n            perplexity = math.exp(eval_loss)\n        except OverflowError:\n            perplexity = float(\"inf\")\n\n        logger.info(f\"epoch {epoch}: perplexity: {perplexity} eval_loss: {eval_loss}\")\n\n        if args.with_tracking:\n            accelerator.log(\n                {\n                    \"perplexity\": perplexity,\n                    \"eval_loss\": eval_loss,\n                    \"train_loss\": total_loss.item() / len(train_dataloader),\n                    \"epoch\": epoch,\n                    \"step\": completed_steps,\n                },\n                step=completed_steps,\n            )\n\n        if args.push_to_hub and epoch < args.num_train_epochs - 1:\n            accelerator.wait_for_everyone()\n            unwrapped_model = accelerator.unwrap_model(model)\n            unwrapped_model.save_pretrained(\n                args.output_dir, is_main_process=accelerator.is_main_process, save_function=accelerator.save\n            )\n            if accelerator.is_main_process:\n                tokenizer.save_pretrained(args.output_dir)\n                repo.push_to_hub(\n                    commit_message=f\"Training in progress epoch {epoch}\", blocking=False, auto_lfs_prune=True\n                )\n\n        if args.checkpointing_steps == \"epoch\":\n            output_dir = f\"epoch_{epoch}\"\n            if args.output_dir is not None:\n                output_dir = os.path.join(args.output_dir, output_dir)\n            accelerator.save_state(output_dir)\n\n    # this is causing some issue with Megatron-LM when using `wandb` at the end of the main function.\n    # Everything works fine inspite of commenting this out. (wandb finishes/closes the run without error)\n    # if args.with_tracking:\n    #     accelerator.end_training()\n\n    if args.output_dir is not None:\n        accelerator.wait_for_everyone()\n        # New Code\n        # For Megatron-LM, we need to save the model using `accelerator.save_state`\n        if accelerator.distributed_type == DistributedType.MEGATRON_LM:\n            accelerator.save_state(args.output_dir)\n        else:\n            unwrapped_model = accelerator.unwrap_model(model)\n            unwrapped_model.save_pretrained(\n                args.output_dir, is_main_process=accelerator.is_main_process, save_function=accelerator.save\n            )\n        if accelerator.is_main_process:\n            tokenizer.save_pretrained(args.output_dir)\n            if args.push_to_hub:\n                repo.push_to_hub(commit_message=\"End of training\", auto_lfs_prune=True)\n\n        with open(os.path.join(args.output_dir, \"all_results.json\"), \"w\") as f:\n            json.dump({\"perplexity\": perplexity}, f)\n\n\nif __name__ == \"__main__\":\n    main()\n", "# coding=utf-8\n# Copyright 2022 The HuggingFace Inc. team. All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nimport argparse\nimport os\n\nimport evaluate\nimport torch\nfrom datasets import load_dataset\nfrom torch.optim import AdamW\nfrom torch.utils.data import DataLoader\nfrom transformers import AutoModelForSequenceClassification, AutoTokenizer, get_linear_schedule_with_warmup, set_seed\n\nfrom accelerate import Accelerator, DistributedType\n\n\n########################################################################\n# This is a fully working simple example to use Accelerate,\n# specifically showcasing how to properly calculate the metrics on the\n# validation dataset when in a distributed system, and builds off the\n# `nlp_example.py` script.\n#\n# This example trains a Bert base model on GLUE MRPC\n# in any of the following settings (with the same script):\n#   - single CPU or single GPU\n#   - multi GPUS (using PyTorch distributed mode)\n#   - (multi) TPUs\n#   - fp16 (mixed-precision) or fp32 (normal precision)\n#\n# To help focus on the differences in the code, building `DataLoaders`\n# was refactored into its own function.\n# New additions from the base script can be found quickly by\n# looking for the # New Code # tags\n#\n# To run it in each of these various modes, follow the instructions\n# in the readme for examples:\n# https://github.com/huggingface/accelerate/tree/main/examples\n#\n########################################################################\n\n\nMAX_GPU_BATCH_SIZE = 16\nEVAL_BATCH_SIZE = 32\n\n\ndef get_dataloaders(accelerator: Accelerator, batch_size: int = 16):\n    \"\"\"\n    Creates a set of `DataLoader`s for the `glue` dataset,\n    using \"bert-base-cased\" as the tokenizer.\n\n    Args:\n        accelerator (`Accelerator`):\n            An `Accelerator` object\n        batch_size (`int`, *optional*):\n            The batch size for the train and validation DataLoaders.\n    \"\"\"\n    tokenizer = AutoTokenizer.from_pretrained(\"bert-base-cased\")\n    datasets = load_dataset(\"glue\", \"mrpc\")\n\n    def tokenize_function(examples):\n        # max_length=None => use the model max length (it's actually the default)\n        outputs = tokenizer(examples[\"sentence1\"], examples[\"sentence2\"], truncation=True, max_length=None)\n        return outputs\n\n    # Apply the method we just defined to all the examples in all the splits of the dataset\n    # starting with the main process first:\n    with accelerator.main_process_first():\n        tokenized_datasets = datasets.map(\n            tokenize_function,\n            batched=True,\n            remove_columns=[\"idx\", \"sentence1\", \"sentence2\"],\n        )\n\n    # We also rename the 'label' column to 'labels' which is the expected name for labels by the models of the\n    # transformers library\n    tokenized_datasets = tokenized_datasets.rename_column(\"label\", \"labels\")\n\n    def collate_fn(examples):\n        # On TPU it's best to pad everything to the same length or training will be very slow.\n        max_length = 128 if accelerator.distributed_type == DistributedType.TPU else None\n        # When using mixed precision we want round multiples of 8/16\n        if accelerator.mixed_precision == \"fp8\":\n            pad_to_multiple_of = 16\n        elif accelerator.mixed_precision != \"no\":\n            pad_to_multiple_of = 8\n        else:\n            pad_to_multiple_of = None\n\n        return tokenizer.pad(\n            examples,\n            padding=\"longest\",\n            max_length=max_length,\n            pad_to_multiple_of=pad_to_multiple_of,\n            return_tensors=\"pt\",\n        )\n\n    # Instantiate dataloaders.\n    train_dataloader = DataLoader(\n        tokenized_datasets[\"train\"], shuffle=True, collate_fn=collate_fn, batch_size=batch_size\n    )\n    eval_dataloader = DataLoader(\n        tokenized_datasets[\"validation\"], shuffle=False, collate_fn=collate_fn, batch_size=EVAL_BATCH_SIZE\n    )\n\n    return train_dataloader, eval_dataloader\n\n\n# For testing only\nif os.environ.get(\"TESTING_MOCKED_DATALOADERS\", None) == \"1\":\n    from accelerate.test_utils.training import mocked_dataloaders\n\n    get_dataloaders = mocked_dataloaders  # noqa: F811\n\n\ndef training_function(config, args):\n    # For testing only\n    if os.environ.get(\"TESTING_MOCKED_DATALOADERS\", None) == \"1\":\n        config[\"num_epochs\"] = 2\n    # Initialize accelerator\n    accelerator = Accelerator(cpu=args.cpu, mixed_precision=args.mixed_precision)\n    # Sample hyper-parameters for learning rate, batch size, seed and a few other HPs\n    lr = config[\"lr\"]\n    num_epochs = int(config[\"num_epochs\"])\n    seed = int(config[\"seed\"])\n    batch_size = int(config[\"batch_size\"])\n\n    metric = evaluate.load(\"glue\", \"mrpc\")\n\n    # If the batch size is too big we use gradient accumulation\n    gradient_accumulation_steps = 1\n    if batch_size > MAX_GPU_BATCH_SIZE and accelerator.distributed_type != DistributedType.TPU:\n        gradient_accumulation_steps = batch_size // MAX_GPU_BATCH_SIZE\n        batch_size = MAX_GPU_BATCH_SIZE\n\n    set_seed(seed)\n    train_dataloader, eval_dataloader = get_dataloaders(accelerator, batch_size)\n    # Instantiate the model (we build the model here so that the seed also control new weights initialization)\n    model = AutoModelForSequenceClassification.from_pretrained(\"bert-base-cased\", return_dict=True)\n\n    # We could avoid this line since the accelerator is set with `device_placement=True` (default value).\n    # Note that if you are placing tensors on devices manually, this line absolutely needs to be before the optimizer\n    # creation otherwise training will not work on TPU (`accelerate` will kindly throw an error to make us aware of that).\n    model = model.to(accelerator.device)\n\n    # Instantiate optimizer\n    optimizer = AdamW(params=model.parameters(), lr=lr)\n\n    # Instantiate scheduler\n    lr_scheduler = get_linear_schedule_with_warmup(\n        optimizer=optimizer,\n        num_warmup_steps=100,\n        num_training_steps=(len(train_dataloader) * num_epochs) // gradient_accumulation_steps,\n    )\n\n    # Prepare everything\n    # There is no specific order to remember, we just need to unpack the objects in the same order we gave them to the\n    # prepare method.\n    model, optimizer, train_dataloader, eval_dataloader, lr_scheduler = accelerator.prepare(\n        model, optimizer, train_dataloader, eval_dataloader, lr_scheduler\n    )\n\n    # Now we train the model\n    for epoch in range(num_epochs):\n        model.train()\n        for step, batch in enumerate(train_dataloader):\n            # We could avoid this line since we set the accelerator with `device_placement=True`.\n            batch.to(accelerator.device)\n            outputs = model(**batch)\n            loss = outputs.loss\n            loss = loss / gradient_accumulation_steps\n            accelerator.backward(loss)\n            if step % gradient_accumulation_steps == 0:\n                optimizer.step()\n                lr_scheduler.step()\n                optimizer.zero_grad()\n\n        model.eval()\n        samples_seen = 0\n        for step, batch in enumerate(eval_dataloader):\n            # We could avoid this line since we set the accelerator with `device_placement=True`.\n            batch.to(accelerator.device)\n            with torch.no_grad():\n                outputs = model(**batch)\n            predictions = outputs.logits.argmax(dim=-1)\n            predictions, references = accelerator.gather((predictions, batch[\"labels\"]))\n            # New Code #\n            # First we check if it's a distributed system\n            if accelerator.use_distributed:\n                # Then see if we're on the last batch of our eval dataloader\n                if step == len(eval_dataloader) - 1:\n                    # Last batch needs to be truncated on distributed systems as it contains additional samples\n                    predictions = predictions[: len(eval_dataloader.dataset) - samples_seen]\n                    references = references[: len(eval_dataloader.dataset) - samples_seen]\n                else:\n                    # Otherwise we add the number of samples seen\n                    samples_seen += references.shape[0]\n            # All of this can be avoided if you use `Accelerator.gather_for_metrics` instead of `Accelerator.gather`:\n            # accelerator.gather_for_metrics((predictions, batch[\"labels\"]))\n            metric.add_batch(\n                predictions=predictions,\n                references=references,\n            )\n\n        eval_metric = metric.compute()\n        # Use accelerator.print to print only on the main process.\n        accelerator.print(f\"epoch {epoch}:\", eval_metric)\n\n\ndef main():\n    parser = argparse.ArgumentParser(description=\"Simple example of training script.\")\n    parser.add_argument(\n        \"--mixed_precision\",\n        type=str,\n        default=None,\n        choices=[\"no\", \"fp16\", \"bf16\", \"fp8\"],\n        help=\"Whether to use mixed precision. Choose\"\n        \"between fp16 and bf16 (bfloat16). Bf16 requires PyTorch >= 1.10.\"\n        \"and an Nvidia Ampere GPU.\",\n    )\n    parser.add_argument(\"--cpu\", action=\"store_true\", help=\"If passed, will train on the CPU.\")\n    args = parser.parse_args()\n    config = {\"lr\": 2e-5, \"num_epochs\": 3, \"seed\": 42, \"batch_size\": 16}\n    training_function(config, args)\n\n\nif __name__ == \"__main__\":\n    main()\n", "# coding=utf-8\n# Copyright 2021 The HuggingFace Inc. team. All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\nimport argparse\nimport os\n\nimport evaluate\nimport torch\nfrom datasets import load_dataset\nfrom torch.optim import AdamW\nfrom torch.utils.data import DataLoader\nfrom transformers import AutoModelForSequenceClassification, AutoTokenizer, get_linear_schedule_with_warmup, set_seed\n\nfrom accelerate import Accelerator, DistributedType\n\n\n########################################################################\n# This is a fully working simple example to use Accelerate,\n# specifically showcasing the checkpointing capability,\n# and builds off the `nlp_example.py` script.\n#\n# This example trains a Bert base model on GLUE MRPC\n# in any of the following settings (with the same script):\n#   - single CPU or single GPU\n#   - multi GPUS (using PyTorch distributed mode)\n#   - (multi) TPUs\n#   - fp16 (mixed-precision) or fp32 (normal precision)\n#\n# To help focus on the differences in the code, building `DataLoaders`\n# was refactored into its own function.\n# New additions from the base script can be found quickly by\n# looking for the # New Code # tags\n#\n# To run it in each of these various modes, follow the instructions\n# in the readme for examples:\n# https://github.com/huggingface/accelerate/tree/main/examples\n#\n########################################################################\n\nMAX_GPU_BATCH_SIZE = 16\nEVAL_BATCH_SIZE = 32\n\n\ndef get_dataloaders(accelerator: Accelerator, batch_size: int = 16):\n    \"\"\"\n    Creates a set of `DataLoader`s for the `glue` dataset,\n    using \"bert-base-cased\" as the tokenizer.\n\n    Args:\n        accelerator (`Accelerator`):\n            An `Accelerator` object\n        batch_size (`int`, *optional*):\n            The batch size for the train and validation DataLoaders.\n    \"\"\"\n    tokenizer = AutoTokenizer.from_pretrained(\"bert-base-cased\")\n    datasets = load_dataset(\"glue\", \"mrpc\")\n\n    def tokenize_function(examples):\n        # max_length=None => use the model max length (it's actually the default)\n        outputs = tokenizer(examples[\"sentence1\"], examples[\"sentence2\"], truncation=True, max_length=None)\n        return outputs\n\n    # Apply the method we just defined to all the examples in all the splits of the dataset\n    # starting with the main process first:\n    with accelerator.main_process_first():\n        tokenized_datasets = datasets.map(\n            tokenize_function,\n            batched=True,\n            remove_columns=[\"idx\", \"sentence1\", \"sentence2\"],\n        )\n\n    # We also rename the 'label' column to 'labels' which is the expected name for labels by the models of the\n    # transformers library\n    tokenized_datasets = tokenized_datasets.rename_column(\"label\", \"labels\")\n\n    def collate_fn(examples):\n        # On TPU it's best to pad everything to the same length or training will be very slow.\n        max_length = 128 if accelerator.distributed_type == DistributedType.TPU else None\n        # When using mixed precision we want round multiples of 8/16\n        if accelerator.mixed_precision == \"fp8\":\n            pad_to_multiple_of = 16\n        elif accelerator.mixed_precision != \"no\":\n            pad_to_multiple_of = 8\n        else:\n            pad_to_multiple_of = None\n\n        return tokenizer.pad(\n            examples,\n            padding=\"longest\",\n            max_length=max_length,\n            pad_to_multiple_of=pad_to_multiple_of,\n            return_tensors=\"pt\",\n        )\n\n    # Instantiate dataloaders.\n    train_dataloader = DataLoader(\n        tokenized_datasets[\"train\"], shuffle=True, collate_fn=collate_fn, batch_size=batch_size\n    )\n    eval_dataloader = DataLoader(\n        tokenized_datasets[\"validation\"], shuffle=False, collate_fn=collate_fn, batch_size=EVAL_BATCH_SIZE\n    )\n\n    return train_dataloader, eval_dataloader\n\n\n# For testing only\nif os.environ.get(\"TESTING_MOCKED_DATALOADERS\", None) == \"1\":\n    from accelerate.test_utils.training import mocked_dataloaders\n\n    get_dataloaders = mocked_dataloaders  # noqa: F811\n\n\ndef training_function(config, args):\n    # For testing only\n    if os.environ.get(\"TESTING_MOCKED_DATALOADERS\", None) == \"1\":\n        config[\"num_epochs\"] = 2\n    # Initialize accelerator\n    accelerator = Accelerator(cpu=args.cpu, mixed_precision=args.mixed_precision)\n    # Sample hyper-parameters for learning rate, batch size, seed and a few other HPs\n    lr = config[\"lr\"]\n    num_epochs = int(config[\"num_epochs\"])\n    seed = int(config[\"seed\"])\n    batch_size = int(config[\"batch_size\"])\n\n    # New Code #\n    # Parse out whether we are saving every epoch or after a certain number of batches\n    if hasattr(args.checkpointing_steps, \"isdigit\"):\n        if args.checkpointing_steps == \"epoch\":\n            checkpointing_steps = args.checkpointing_steps\n        elif args.checkpointing_steps.isdigit():\n            checkpointing_steps = int(args.checkpointing_steps)\n        else:\n            raise ValueError(\n                f\"Argument `checkpointing_steps` must be either a number or `epoch`. `{args.checkpointing_steps}` passed.\"\n            )\n    else:\n        checkpointing_steps = None\n\n    set_seed(seed)\n\n    train_dataloader, eval_dataloader = get_dataloaders(accelerator, batch_size)\n    metric = evaluate.load(\"glue\", \"mrpc\")\n\n    # If the batch size is too big we use gradient accumulation\n    gradient_accumulation_steps = 1\n    if batch_size > MAX_GPU_BATCH_SIZE and accelerator.distributed_type != DistributedType.TPU:\n        gradient_accumulation_steps = batch_size // MAX_GPU_BATCH_SIZE\n        batch_size = MAX_GPU_BATCH_SIZE\n\n    # Instantiate the model (we build the model here so that the seed also control new weights initialization)\n    model = AutoModelForSequenceClassification.from_pretrained(\"bert-base-cased\", return_dict=True)\n\n    # We could avoid this line since the accelerator is set with `device_placement=True` (default value).\n    # Note that if you are placing tensors on devices manually, this line absolutely needs to be before the optimizer\n    # creation otherwise training will not work on TPU (`accelerate` will kindly throw an error to make us aware of that).\n    model = model.to(accelerator.device)\n\n    # Instantiate optimizer\n    optimizer = AdamW(params=model.parameters(), lr=lr)\n\n    # Instantiate scheduler\n    lr_scheduler = get_linear_schedule_with_warmup(\n        optimizer=optimizer,\n        num_warmup_steps=100,\n        num_training_steps=(len(train_dataloader) * num_epochs) // gradient_accumulation_steps,\n    )\n\n    # Prepare everything\n    # There is no specific order to remember, we just need to unpack the objects in the same order we gave them to the\n    # prepare method.\n    model, optimizer, train_dataloader, eval_dataloader, lr_scheduler = accelerator.prepare(\n        model, optimizer, train_dataloader, eval_dataloader, lr_scheduler\n    )\n\n    # New Code #\n    # We need to keep track of how many total steps we have iterated over\n    overall_step = 0\n    # We also need to keep track of the stating epoch so files are named properly\n    starting_epoch = 0\n\n    # We need to load the checkpoint back in before training here with `load_state`\n    # The total number of epochs is adjusted based on where the state is being loaded from,\n    # as we assume continuation of the same training script\n    if args.resume_from_checkpoint:\n        if args.resume_from_checkpoint is not None or args.resume_from_checkpoint != \"\":\n            accelerator.print(f\"Resumed from checkpoint: {args.resume_from_checkpoint}\")\n            accelerator.load_state(args.resume_from_checkpoint)\n            path = os.path.basename(args.resume_from_checkpoint)\n        else:\n            # Get the most recent checkpoint\n            dirs = [f.name for f in os.scandir(os.getcwd()) if f.is_dir()]\n            dirs.sort(key=os.path.getctime)\n            path = dirs[-1]  # Sorts folders by date modified, most recent checkpoint is the last\n        # Extract `epoch_{i}` or `step_{i}`\n        training_difference = os.path.splitext(path)[0]\n\n        if \"epoch\" in training_difference:\n            starting_epoch = int(training_difference.replace(\"epoch_\", \"\")) + 1\n            resume_step = None\n        else:\n            resume_step = int(training_difference.replace(\"step_\", \"\"))\n            starting_epoch = resume_step // len(train_dataloader)\n            resume_step -= starting_epoch * len(train_dataloader)\n\n    # Now we train the model\n    for epoch in range(starting_epoch, num_epochs):\n        model.train()\n        # New Code #\n        if args.resume_from_checkpoint and epoch == starting_epoch and resume_step is not None:\n            # We need to skip steps until we reach the resumed step\n            active_dataloader = accelerator.skip_first_batches(train_dataloader, resume_step)\n            overall_step += resume_step\n        else:\n            # After the first iteration though, we need to go back to the original dataloader\n            active_dataloader = train_dataloader\n        for step, batch in enumerate(active_dataloader):\n            # We could avoid this line since we set the accelerator with `device_placement=True`.\n            batch.to(accelerator.device)\n            outputs = model(**batch)\n            loss = outputs.loss\n            loss = loss / gradient_accumulation_steps\n            accelerator.backward(loss)\n            if step % gradient_accumulation_steps == 0:\n                optimizer.step()\n                lr_scheduler.step()\n                optimizer.zero_grad()\n            # New Code #\n            overall_step += 1\n\n            # New Code #\n            # We save the model, optimizer, lr_scheduler, and seed states by calling `save_state`\n            # These are saved to folders named `step_{overall_step}`\n            # Will contain files: \"pytorch_model.bin\", \"optimizer.bin\", \"scheduler.bin\", and \"random_states.pkl\"\n            # If mixed precision was used, will also save a \"scalar.bin\" file\n            if isinstance(checkpointing_steps, int):\n                output_dir = f\"step_{overall_step}\"\n                if overall_step % checkpointing_steps == 0:\n                    if args.output_dir is not None:\n                        output_dir = os.path.join(args.output_dir, output_dir)\n                    accelerator.save_state(output_dir)\n\n        model.eval()\n        for step, batch in enumerate(eval_dataloader):\n            # We could avoid this line since we set the accelerator with `device_placement=True` (the default).\n            batch.to(accelerator.device)\n            with torch.no_grad():\n                outputs = model(**batch)\n            predictions = outputs.logits.argmax(dim=-1)\n            predictions, references = accelerator.gather_for_metrics((predictions, batch[\"labels\"]))\n            metric.add_batch(\n                predictions=predictions,\n                references=references,\n            )\n\n        eval_metric = metric.compute()\n        # Use accelerator.print to print only on the main process.\n        accelerator.print(f\"epoch {epoch}:\", eval_metric)\n\n        # New Code #\n        # We save the model, optimizer, lr_scheduler, and seed states by calling `save_state`\n        # These are saved to folders named `epoch_{epoch}`\n        # Will contain files: \"pytorch_model.bin\", \"optimizer.bin\", \"scheduler.bin\", and \"random_states.pkl\"\n        # If mixed precision was used, will also save a \"scalar.bin\" file\n        if checkpointing_steps == \"epoch\":\n            output_dir = f\"epoch_{epoch}\"\n            if args.output_dir is not None:\n                output_dir = os.path.join(args.output_dir, output_dir)\n            accelerator.save_state(output_dir)\n\n\ndef main():\n    parser = argparse.ArgumentParser(description=\"Simple example of training script.\")\n    parser.add_argument(\n        \"--mixed_precision\",\n        type=str,\n        default=None,\n        choices=[\"no\", \"fp16\", \"bf16\", \"fp8\"],\n        help=\"Whether to use mixed precision. Choose\"\n        \"between fp16 and bf16 (bfloat16). Bf16 requires PyTorch >= 1.10.\"\n        \"and an Nvidia Ampere GPU.\",\n    )\n    parser.add_argument(\"--cpu\", action=\"store_true\", help=\"If passed, will train on the CPU.\")\n    parser.add_argument(\n        \"--checkpointing_steps\",\n        type=str,\n        default=None,\n        help=\"Whether the various states should be saved at the end of every n steps, or 'epoch' for each epoch.\",\n    )\n    parser.add_argument(\n        \"--output_dir\",\n        type=str,\n        default=\".\",\n        help=\"Optional save directory where all checkpoint folders will be stored. Default is the current working directory.\",\n    )\n    parser.add_argument(\n        \"--resume_from_checkpoint\",\n        type=str,\n        default=None,\n        help=\"If the training should continue from a checkpoint folder.\",\n    )\n    args = parser.parse_args()\n    config = {\"lr\": 2e-5, \"num_epochs\": 3, \"seed\": 42, \"batch_size\": 16}\n    training_function(config, args)\n\n\nif __name__ == \"__main__\":\n    main()\n", "{\n    \"fp16\": {\n        \"enabled\": true,\n        \"loss_scale\": 0,\n        \"loss_scale_window\": 1000,\n        \"initial_scale_power\": 16,\n        \"hysteresis\": 2,\n        \"min_loss_scale\": 1\n    },\n    \"optimizer\": {\n        \"type\": \"AdamW\",\n        \"params\": {\n            \"lr\": \"auto\",\n            \"weight_decay\": \"auto\"\n        }\n    },\n    \"scheduler\": {\n        \"type\": \"WarmupDecayLR\",\n        \"params\": {\n            \"warmup_min_lr\": \"auto\",\n            \"warmup_max_lr\": \"auto\",\n            \"warmup_num_steps\": \"auto\",\n            \"total_num_steps\": \"auto\"\n        }\n    },\n    \"zero_optimization\": {\n        \"stage\": 3,\n        \"offload_optimizer\": {\n            \"device\": \"cpu\",\n            \"pin_memory\": true\n        },\n        \"offload_param\": {\n            \"device\": \"cpu\",\n            \"pin_memory\": true\n        },\n        \"overlap_comm\": true,\n        \"contiguous_gradients\": true,\n        \"reduce_bucket_size\": \"auto\",\n        \"stage3_prefetch_bucket_size\": \"auto\",\n        \"stage3_param_persistence_threshold\": \"auto\",\n        \"sub_group_size\": 1e9,\n        \"stage3_max_live_parameters\": 1e9,\n        \"stage3_max_reuse_distance\": 1e9,\n        \"stage3_gather_16bit_weights_on_model_save\": \"auto\"\n    },\n    \"gradient_accumulation_steps\": 1,\n    \"gradient_clipping\": \"auto\",\n    \"steps_per_print\": 2000,\n    \"train_batch_size\": \"auto\",\n    \"train_micro_batch_size_per_gpu\": \"auto\",\n    \"wall_clock_breakdown\": false\n}", "{\n    \"fp16\": {\n        \"enabled\": true,\n        \"loss_scale\": 0,\n        \"loss_scale_window\": 1000,\n        \"initial_scale_power\": 16,\n        \"hysteresis\": 2,\n        \"min_loss_scale\": 1\n    },\n    \"optimizer\": {\n        \"type\": \"AdamW\",\n        \"params\": {\n            \"lr\": \"auto\",\n            \"weight_decay\": \"auto\",\n            \"torch_adam\": true,\n            \"adam_w_mode\": true\n        }\n    },\n    \"scheduler\": {\n        \"type\": \"WarmupDecayLR\",\n        \"params\": {\n            \"warmup_min_lr\": \"auto\",\n            \"warmup_max_lr\": \"auto\",\n            \"warmup_num_steps\": \"auto\",\n            \"total_num_steps\": \"auto\"\n        }\n    },\n    \"zero_optimization\": {\n        \"stage\": 1,\n        \"allgather_partitions\": true,\n        \"allgather_bucket_size\": 2e8,\n        \"overlap_comm\": true,\n        \"reduce_scatter\": true,\n        \"reduce_bucket_size\": \"auto\",\n        \"contiguous_gradients\": true\n    },\n    \"gradient_accumulation_steps\": 1,\n    \"gradient_clipping\": \"auto\",\n    \"steps_per_print\": 2000,\n    \"train_batch_size\": \"auto\",\n    \"train_micro_batch_size_per_gpu\": \"auto\",\n    \"wall_clock_breakdown\": false\n}", "{\n    \"fp16\": {\n        \"enabled\": true,\n        \"loss_scale\": 0,\n        \"loss_scale_window\": 1000,\n        \"initial_scale_power\": 16,\n        \"hysteresis\": 2,\n        \"min_loss_scale\": 1\n    },\n    \"optimizer\": {\n        \"type\": \"AdamW\",\n        \"params\": {\n            \"lr\": \"auto\",\n            \"weight_decay\": \"auto\"\n        }\n    },\n    \"scheduler\": {\n        \"type\": \"WarmupDecayLR\",\n        \"params\": {\n            \"warmup_min_lr\": \"auto\",\n            \"warmup_max_lr\": \"auto\",\n            \"warmup_num_steps\": \"auto\",\n            \"total_num_steps\": \"auto\"\n        }\n    },\n    \"zero_optimization\": {\n        \"stage\": 3,\n        \"overlap_comm\": true,\n        \"contiguous_gradients\": true,\n        \"reduce_bucket_size\": \"auto\",\n        \"stage3_prefetch_bucket_size\": \"auto\",\n        \"stage3_param_persistence_threshold\": \"auto\",\n        \"sub_group_size\": 1e9,\n        \"stage3_max_live_parameters\": 1e9,\n        \"stage3_max_reuse_distance\": 1e9,\n        \"stage3_gather_16bit_weights_on_model_save\": \"auto\"\n    },\n    \"gradient_accumulation_steps\": 1,\n    \"gradient_clipping\": \"auto\",\n    \"steps_per_print\": 2000,\n    \"train_batch_size\": \"auto\",\n    \"train_micro_batch_size_per_gpu\": \"auto\",\n    \"wall_clock_breakdown\": false\n}", "{\n    \"fp16\": {\n        \"enabled\": true,\n        \"loss_scale\": 0,\n        \"loss_scale_window\": 1000,\n        \"initial_scale_power\": 16,\n        \"hysteresis\": 2,\n        \"min_loss_scale\": 1\n    },\n    \"optimizer\": {\n        \"type\": \"AdamW\",\n        \"params\": {\n            \"lr\": \"auto\",\n            \"weight_decay\": \"auto\",\n            \"torch_adam\": true,\n            \"adam_w_mode\": true\n        }\n    },\n    \"scheduler\": {\n        \"type\": \"WarmupDecayLR\",\n        \"params\": {\n            \"warmup_min_lr\": \"auto\",\n            \"warmup_max_lr\": \"auto\",\n            \"warmup_num_steps\": \"auto\",\n            \"total_num_steps\": \"auto\"\n        }\n    },\n    \"zero_optimization\": {\n        \"stage\": 2,\n        \"offload_optimizer\": {\n            \"device\": \"cpu\",\n            \"pin_memory\": true\n        },\n        \"allgather_partitions\": true,\n        \"allgather_bucket_size\": 2e8,\n        \"overlap_comm\": true,\n        \"reduce_scatter\": true,\n        \"reduce_bucket_size\": \"auto\",\n        \"contiguous_gradients\": true\n    },\n    \"gradient_accumulation_steps\": 1,\n    \"gradient_clipping\": \"auto\",\n    \"steps_per_print\": 2000,\n    \"train_batch_size\": \"auto\",\n    \"train_micro_batch_size_per_gpu\": \"auto\",\n    \"wall_clock_breakdown\": false\n}", "{\n    \"fp16\": {\n        \"enabled\": true,\n        \"loss_scale\": 0,\n        \"loss_scale_window\": 1000,\n        \"initial_scale_power\": 16,\n        \"hysteresis\": 2,\n        \"min_loss_scale\": 1\n    },\n    \"optimizer\": {\n        \"type\": \"AdamW\",\n        \"params\": {\n            \"lr\": \"auto\",\n            \"weight_decay\": \"auto\",\n            \"torch_adam\": true,\n            \"adam_w_mode\": true\n        }\n    },\n    \"scheduler\": {\n        \"type\": \"WarmupDecayLR\",\n        \"params\": {\n            \"warmup_min_lr\": \"auto\",\n            \"warmup_max_lr\": \"auto\",\n            \"warmup_num_steps\": \"auto\",\n            \"total_num_steps\": \"auto\"\n        }\n    },\n    \"zero_optimization\": {\n        \"stage\": 2,\n        \"allgather_partitions\": true,\n        \"allgather_bucket_size\": 2e8,\n        \"overlap_comm\": true,\n        \"reduce_scatter\": true,\n        \"reduce_bucket_size\": \"auto\",\n        \"contiguous_gradients\": true\n    },\n    \"gradient_accumulation_steps\": 1,\n    \"gradient_clipping\": \"auto\",\n    \"steps_per_print\": 2000,\n    \"train_batch_size\": \"auto\",\n    \"train_micro_batch_size_per_gpu\": \"auto\",\n    \"wall_clock_breakdown\": false\n}", "# Copyright 2022 The HuggingFace Team. All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport ast\nimport os\nimport re\nimport shutil\nimport tempfile\nimport unittest\nfrom unittest import mock\n\nimport torch\n\nfrom accelerate.test_utils.examples import compare_against_test\nfrom accelerate.test_utils.testing import TempDirTestCase, require_trackers, run_command, slow\nfrom accelerate.utils import write_basic_config\n\n\n# DataLoaders built from `test_samples/MRPC` for quick testing\n# Should mock `{script_name}.get_dataloaders` via:\n# @mock.patch(\"{script_name}.get_dataloaders\", mocked_dataloaders)\n\nEXCLUDE_EXAMPLES = [\n    \"cross_validation.py\",\n    \"gradient_accumulation.py\",\n    \"local_sgd.py\",\n    \"multi_process_metrics.py\",\n    \"memory.py\",\n    \"automatic_gradient_accumulation.py\",\n    \"fsdp_with_peak_mem_tracking.py\",\n    \"deepspeed_with_config_support.py\",\n    \"megatron_lm_gpt_pretraining.py\",\n]\n\n\nclass ExampleDifferenceTests(unittest.TestCase):\n    \"\"\"\n    This TestCase checks that all of the `complete_*` scripts contain all of the\n    information found in the `by_feature` scripts, line for line. If one fails,\n    then a complete example does not contain all of the features in the features\n    scripts, and should be updated.\n\n    Each example script should be a single test (such as `test_nlp_example`),\n    and should run `one_complete_example` twice: once with `parser_only=True`,\n    and the other with `parser_only=False`. This is so that when the test\n    failures are returned to the user, they understand if the discrepancy lies in\n    the `main` function, or the `training_loop` function. Otherwise it will be\n    unclear.\n\n    Also, if there are any expected differences between the base script used and\n    `complete_nlp_example.py` (the canonical base script), these should be included in\n    `special_strings`. These would be differences in how something is logged, print statements,\n    etc (such as calls to `Accelerate.log()`)\n    \"\"\"\n\n    def one_complete_example(\n        self, complete_file_name: str, parser_only: bool, secondary_filename: str = None, special_strings: list = None\n    ):\n        \"\"\"\n        Tests a single `complete` example against all of the implemented `by_feature` scripts\n\n        Args:\n            complete_file_name (`str`):\n                The filename of a complete example\n            parser_only (`bool`):\n                Whether to look at the main training function, or the argument parser\n            secondary_filename (`str`, *optional*):\n                A potential secondary base file to strip all script information not relevant for checking,\n                such as \"cv_example.py\" when testing \"complete_cv_example.py\"\n            special_strings (`list`, *optional*):\n                A list of strings to potentially remove before checking no differences are left. These should be\n                diffs that are file specific, such as different logging variations between files.\n        \"\"\"\n        self.maxDiff = None\n        by_feature_path = os.path.abspath(os.path.join(\"examples\", \"by_feature\"))\n        examples_path = os.path.abspath(\"examples\")\n        for item in os.listdir(by_feature_path):\n            if item not in EXCLUDE_EXAMPLES:\n                item_path = os.path.join(by_feature_path, item)\n                if os.path.isfile(item_path) and \".py\" in item_path:\n                    with self.subTest(\n                        tested_script=complete_file_name,\n                        feature_script=item,\n                        tested_section=\"main()\" if parser_only else \"training_function()\",\n                    ):\n                        diff = compare_against_test(\n                            os.path.join(examples_path, complete_file_name), item_path, parser_only, secondary_filename\n                        )\n                        diff = \"\\n\".join(diff)\n                        if special_strings is not None:\n                            for string in special_strings:\n                                diff = diff.replace(string, \"\")\n                        self.assertEqual(diff, \"\")\n\n    def test_nlp_examples(self):\n        self.one_complete_example(\"complete_nlp_example.py\", True)\n        self.one_complete_example(\"complete_nlp_example.py\", False)\n\n    def test_cv_examples(self):\n        cv_path = os.path.abspath(os.path.join(\"examples\", \"cv_example.py\"))\n        special_strings = [\n            \" \" * 16 + \"{\\n\\n\",\n            \" \" * 20 + '\"accuracy\": eval_metric[\"accuracy\"],\\n\\n',\n            \" \" * 20 + '\"f1\": eval_metric[\"f1\"],\\n\\n',\n            \" \" * 20 + '\"train_loss\": total_loss.item() / len(train_dataloader),\\n\\n',\n            \" \" * 20 + '\"epoch\": epoch,\\n\\n',\n            \" \" * 16 + \"},\\n\\n\",\n            \" \" * 16 + \"step=epoch,\\n\",\n            \" \" * 12,\n            \" \" * 8 + \"for step, batch in enumerate(active_dataloader):\\n\",\n        ]\n        self.one_complete_example(\"complete_cv_example.py\", True, cv_path, special_strings)\n        self.one_complete_example(\"complete_cv_example.py\", False, cv_path, special_strings)\n\n\n@mock.patch.dict(os.environ, {\"TESTING_MOCKED_DATALOADERS\": \"1\"})\nclass FeatureExamplesTests(TempDirTestCase):\n    clear_on_setup = False\n\n    @classmethod\n    def setUpClass(cls):\n        super().setUpClass()\n        cls._tmpdir = tempfile.mkdtemp()\n        cls.configPath = os.path.join(cls._tmpdir, \"default_config.yml\")\n\n        write_basic_config(save_location=cls.configPath)\n        cls._launch_args = [\"accelerate\", \"launch\", \"--config_file\", cls.configPath]\n\n    @classmethod\n    def tearDownClass(cls):\n        super().tearDownClass()\n        shutil.rmtree(cls._tmpdir)\n\n    def test_checkpointing_by_epoch(self):\n        testargs = f\"\"\"\n        examples/by_feature/checkpointing.py\n        --checkpointing_steps epoch\n        --output_dir {self.tmpdir}\n        \"\"\".split()\n        run_command(self._launch_args + testargs)\n        self.assertTrue(os.path.exists(os.path.join(self.tmpdir, \"epoch_0\")))\n\n    def test_checkpointing_by_steps(self):\n        testargs = f\"\"\"\n        examples/by_feature/checkpointing.py\n        --checkpointing_steps 1\n        --output_dir {self.tmpdir}\n        \"\"\".split()\n        _ = run_command(self._launch_args + testargs)\n        self.assertTrue(os.path.exists(os.path.join(self.tmpdir, \"step_2\")))\n\n    def test_load_states_by_epoch(self):\n        testargs = f\"\"\"\n        examples/by_feature/checkpointing.py\n        --resume_from_checkpoint {os.path.join(self.tmpdir, \"epoch_0\")}\n        \"\"\".split()\n        output = run_command(self._launch_args + testargs, return_stdout=True)\n        self.assertNotIn(\"epoch 0:\", output)\n        self.assertIn(\"epoch 1:\", output)\n\n    def test_load_states_by_steps(self):\n        testargs = f\"\"\"\n        examples/by_feature/checkpointing.py\n        --resume_from_checkpoint {os.path.join(self.tmpdir, \"step_2\")}\n        \"\"\".split()\n        output = run_command(self._launch_args + testargs, return_stdout=True)\n        if torch.cuda.is_available():\n            num_processes = torch.cuda.device_count()\n        else:\n            num_processes = 1\n        if num_processes > 1:\n            self.assertNotIn(\"epoch 0:\", output)\n            self.assertIn(\"epoch 1:\", output)\n        else:\n            self.assertIn(\"epoch 0:\", output)\n            self.assertIn(\"epoch 1:\", output)\n\n    @slow\n    def test_cross_validation(self):\n        testargs = \"\"\"\n        examples/by_feature/cross_validation.py\n        --num_folds 2\n        \"\"\".split()\n        with mock.patch.dict(os.environ, {\"TESTING_MOCKED_DATALOADERS\": \"0\"}):\n            output = run_command(self._launch_args + testargs, return_stdout=True)\n            results = re.findall(\"({.+})\", output)\n            results = [r for r in results if \"accuracy\" in r][-1]\n            results = ast.literal_eval(results)\n            self.assertGreaterEqual(results[\"accuracy\"], 0.75)\n\n    def test_multi_process_metrics(self):\n        testargs = [\"examples/by_feature/multi_process_metrics.py\"]\n        run_command(self._launch_args + testargs)\n\n    @require_trackers\n    @mock.patch.dict(os.environ, {\"WANDB_MODE\": \"offline\"})\n    def test_tracking(self):\n        with tempfile.TemporaryDirectory() as tmpdir:\n            testargs = f\"\"\"\n            examples/by_feature/tracking.py\n            --with_tracking\n            --project_dir {tmpdir}\n            \"\"\".split()\n            run_command(self._launch_args + testargs)\n            self.assertTrue(os.path.exists(os.path.join(tmpdir, \"tracking\")))\n\n    def test_gradient_accumulation(self):\n        testargs = [\"examples/by_feature/gradient_accumulation.py\"]\n        run_command(self._launch_args + testargs)\n\n    def test_local_sgd(self):\n        testargs = [\"examples/by_feature/local_sgd.py\"]\n        run_command(self._launch_args + testargs)\n", "import unittest\nfrom dataclasses import dataclass\n\nimport pytest\n\nfrom accelerate.commands.config.config_args import SageMakerConfig\nfrom accelerate.utils import ComputeEnvironment\nfrom accelerate.utils.launch import _convert_nargs_to_dict\n\n\n@dataclass\nclass MockLaunchConfig(SageMakerConfig):\n    compute_environment = ComputeEnvironment.AMAZON_SAGEMAKER\n    fp16 = True\n    ec2_instance_type = \"ml.p3.2xlarge\"\n    iam_role_name = \"accelerate_sagemaker_execution_role\"\n    profile = \"hf-sm\"\n    region = \"us-east-1\"\n    num_machines = 1\n    base_job_name = \"accelerate-sagemaker-1\"\n    pytorch_version = \"1.6\"\n    transformers_version = \"4.4\"\n    training_script = \"train.py\"\n    success_training_script_args = [\n        \"--model_name_or_path\",\n        \"bert\",\n        \"--do_train\",\n        \"False\",\n        \"--epochs\",\n        \"3\",\n        \"--learning_rate\",\n        \"5e-5\",\n        \"--max_steps\",\n        \"50.5\",\n    ]\n    fail_training_script_args = [\n        \"--model_name_or_path\",\n        \"bert\",\n        \"--do_train\",\n        \"--do_test\",\n        \"False\",\n        \"--do_predict\",\n        \"--epochs\",\n        \"3\",\n        \"--learning_rate\",\n        \"5e-5\",\n        \"--max_steps\",\n        \"50.5\",\n    ]\n\n\nclass SageMakerLaunch(unittest.TestCase):\n    def test_args_convert(self):\n        # If no defaults are changed, `to_kwargs` returns an empty dict.\n        converted_args = _convert_nargs_to_dict(MockLaunchConfig.success_training_script_args)\n        assert isinstance(converted_args[\"model_name_or_path\"], str)\n        assert isinstance(converted_args[\"do_train\"], bool)\n        assert isinstance(converted_args[\"epochs\"], int)\n        assert isinstance(converted_args[\"learning_rate\"], float)\n        assert isinstance(converted_args[\"max_steps\"], float)\n\n        with pytest.raises(ValueError):\n            _convert_nargs_to_dict(MockLaunchConfig.fail_training_script_args)\n", "# Copyright 2022 The HuggingFace Team. All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport json\nimport os\nimport tempfile\nimport unittest\nfrom collections import OrderedDict\n\nimport torch\nimport torch.nn as nn\n\nfrom accelerate import init_empty_weights\nfrom accelerate.test_utils import require_cuda, require_huggingface_suite, require_multi_gpu, require_safetensors\nfrom accelerate.utils.modeling import (\n    check_device_map,\n    clean_device_map,\n    compute_module_sizes,\n    find_tied_parameters,\n    get_balanced_memory,\n    infer_auto_device_map,\n    load_checkpoint_in_model,\n    load_state_dict,\n    named_module_tensors,\n    retie_parameters,\n    set_module_tensor_to_device,\n)\n\n\nclass ModelForTest(nn.Module):\n    def __init__(self):\n        super().__init__()\n        self.linear1 = nn.Linear(3, 4)\n        self.batchnorm = nn.BatchNorm1d(4)\n        self.linear2 = nn.Linear(4, 5)\n\n    def forward(self, x):\n        return self.linear2(self.batchnorm(self.linear1(x)))\n\n\ndef sequential_model(num_layers):\n    layers = OrderedDict([(f\"linear{i}\", nn.Linear(1000, 1000)) for i in range(1, num_layers + 1)])\n    return nn.Sequential(layers)\n\n\nclass ModelingUtilsTester(unittest.TestCase):\n    def check_set_module_tensor_for_device(self, model, device1, device2):\n        self.assertEqual(model.linear1.weight.device, torch.device(device1))\n\n        with self.subTest(\"Access by submodule and direct name for a parameter\"):\n            set_module_tensor_to_device(model.linear1, \"weight\", device2)\n            self.assertEqual(model.linear1.weight.device, torch.device(device2))\n\n            if torch.device(device2) == torch.device(\"meta\"):\n                with self.assertRaises(ValueError):\n                    # We need a `value` to set the weight back on device1\n                    set_module_tensor_to_device(model.linear1, \"weight\", device1)\n\n                set_module_tensor_to_device(model.linear1, \"weight\", device1, value=torch.randn(4, 3))\n            else:\n                set_module_tensor_to_device(model.linear1, \"weight\", device1)\n            self.assertEqual(model.linear1.weight.device, torch.device(device1))\n\n        with self.subTest(\"Access by module and full name for a parameter\"):\n            set_module_tensor_to_device(model, \"linear1.weight\", device2)\n            self.assertEqual(model.linear1.weight.device, torch.device(device2))\n\n            if torch.device(device2) == torch.device(\"meta\"):\n                with self.assertRaises(ValueError):\n                    # We need a `value` to set the weight back on device1\n                    set_module_tensor_to_device(model, \"linear1.weight\", device1)\n                set_module_tensor_to_device(model, \"linear1.weight\", device1, value=torch.randn(4, 3))\n            else:\n                set_module_tensor_to_device(model, \"linear1.weight\", device1)\n            self.assertEqual(model.linear1.weight.device, torch.device(device1))\n\n        self.assertEqual(model.batchnorm.running_mean.device, torch.device(device1))\n\n        with self.subTest(\"Access by submodule and direct name for a buffer\"):\n            set_module_tensor_to_device(model.batchnorm, \"running_mean\", device2)\n            self.assertEqual(model.batchnorm.running_mean.device, torch.device(device2))\n\n            if torch.device(device2) == torch.device(\"meta\"):\n                with self.assertRaises(ValueError):\n                    # We need a `value` to set the weight back on device1\n                    set_module_tensor_to_device(model.batchnorm, \"running_mean\", device1)\n                set_module_tensor_to_device(model.batchnorm, \"running_mean\", device1, value=torch.randn(4))\n            else:\n                set_module_tensor_to_device(model.batchnorm, \"running_mean\", device1)\n            self.assertEqual(model.batchnorm.running_mean.device, torch.device(device1))\n\n        with self.subTest(\"Access by module and full name for a parameter\"):\n            set_module_tensor_to_device(model, \"batchnorm.running_mean\", device2)\n            self.assertEqual(model.batchnorm.running_mean.device, torch.device(device2))\n\n            if torch.device(device2) == torch.device(\"meta\"):\n                with self.assertRaises(ValueError):\n                    # We need a `value` to set the weight back on CPU\n                    set_module_tensor_to_device(model, \"batchnorm.running_mean\", device1)\n\n                set_module_tensor_to_device(model, \"batchnorm.running_mean\", device1, value=torch.randn(4))\n            else:\n                set_module_tensor_to_device(model, \"batchnorm.running_mean\", device1)\n            self.assertEqual(model.batchnorm.running_mean.device, torch.device(device1))\n\n    def test_set_module_tensor_to_meta_and_cpu(self):\n        model = ModelForTest()\n        self.check_set_module_tensor_for_device(model, \"cpu\", \"meta\")\n\n    @require_cuda\n    def test_set_module_tensor_to_cpu_and_gpu(self):\n        model = ModelForTest()\n        self.check_set_module_tensor_for_device(model, \"cpu\", 0)\n\n    @require_cuda\n    def test_set_module_tensor_to_meta_and_gpu(self):\n        model = ModelForTest().to(0)\n        self.check_set_module_tensor_for_device(model, 0, \"meta\")\n\n    @require_multi_gpu\n    def test_set_module_tensor_between_gpus(self):\n        model = ModelForTest().to(0)\n        self.check_set_module_tensor_for_device(model, 0, 1)\n\n    def test_set_module_tensor_sets_dtype(self):\n        model = ModelForTest()\n        set_module_tensor_to_device(model, \"linear1.weight\", \"cpu\", value=model.linear1.weight, dtype=torch.float16)\n        self.assertEqual(model.linear1.weight.dtype, torch.float16)\n\n    def test_set_module_tensor_checks_shape(self):\n        model = ModelForTest()\n        tensor = torch.zeros((2, 2))\n        with self.assertRaises(ValueError) as cm:\n            set_module_tensor_to_device(model, \"linear1.weight\", \"cpu\", value=tensor)\n        self.assertEqual(\n            str(cm.exception),\n            'Trying to set a tensor of shape torch.Size([2, 2]) in \"weight\" (which has shape torch.Size([4, 3])), this look incorrect.',\n        )\n\n    def test_named_tensors(self):\n        model = nn.BatchNorm1d(4)\n        named_tensors = named_module_tensors(model)\n        self.assertListEqual(\n            [name for name, _ in named_tensors],\n            [\"weight\", \"bias\", \"running_mean\", \"running_var\", \"num_batches_tracked\"],\n        )\n\n        named_tensors = named_module_tensors(model, include_buffers=False)\n        self.assertListEqual([name for name, _ in named_tensors], [\"weight\", \"bias\"])\n\n        model = ModelForTest()\n        named_tensors = named_module_tensors(model)\n        self.assertListEqual([name for name, _ in named_tensors], [])\n\n        named_tensors = named_module_tensors(model, recurse=True)\n        self.assertListEqual(\n            [name for name, _ in named_tensors],\n            [\n                \"linear1.weight\",\n                \"linear1.bias\",\n                \"batchnorm.weight\",\n                \"batchnorm.bias\",\n                \"linear2.weight\",\n                \"linear2.bias\",\n                \"batchnorm.running_mean\",\n                \"batchnorm.running_var\",\n                \"batchnorm.num_batches_tracked\",\n            ],\n        )\n\n        named_tensors = named_module_tensors(model, include_buffers=False, recurse=True)\n        self.assertListEqual(\n            [name for name, _ in named_tensors],\n            [\"linear1.weight\", \"linear1.bias\", \"batchnorm.weight\", \"batchnorm.bias\", \"linear2.weight\", \"linear2.bias\"],\n        )\n\n    def test_find_tied_parameters(self):\n        model = sequential_model(4)\n        self.assertListEqual(find_tied_parameters(model), [])\n\n        model.linear2.weight = model.linear1.weight\n        self.assertListEqual(find_tied_parameters(model), [[\"linear1.weight\", \"linear2.weight\"]])\n\n        model.linear4.weight = model.linear1.weight\n        self.assertListEqual(find_tied_parameters(model), [[\"linear1.weight\", \"linear2.weight\", \"linear4.weight\"]])\n\n        model = sequential_model(5)\n        model.linear1.weight = model.linear4.weight\n        model.linear2.weight = model.linear3.weight\n        model.linear5.weight = model.linear2.weight\n        tied_params = sorted(find_tied_parameters(model), key=lambda x: len(x))\n        self.assertListEqual(\n            tied_params, [[\"linear1.weight\", \"linear4.weight\"], [\"linear2.weight\", \"linear3.weight\", \"linear5.weight\"]]\n        )\n\n        model = nn.Sequential(OrderedDict([(\"block1\", sequential_model(4)), (\"block2\", sequential_model(4))]))\n        model.block1.linear1.weight = model.block2.linear1.weight\n        self.assertListEqual(find_tied_parameters(model), [[\"block1.linear1.weight\", \"block2.linear1.weight\"]])\n\n    def test_retie_parameters(self):\n        model = sequential_model(2)\n        retie_parameters(model, [[\"linear1.weight\", \"linear2.weight\"]])\n        self.assertIs(model.linear1.weight, model.linear2.weight)\n\n        model = sequential_model(3)\n        retie_parameters(model, [[\"linear1.weight\", \"linear2.weight\", \"linear3.weight\"]])\n\n        self.assertIs(model.linear1.weight, model.linear2.weight)\n        self.assertIs(model.linear1.weight, model.linear3.weight)\n\n        model = sequential_model(5)\n        retie_parameters(\n            model, [[\"linear1.weight\", \"linear4.weight\"], [\"linear2.weight\", \"linear3.weight\", \"linear5.weight\"]]\n        )\n\n        self.assertIs(model.linear1.weight, model.linear4.weight)\n        self.assertIs(model.linear2.weight, model.linear3.weight)\n        self.assertIs(model.linear2.weight, model.linear5.weight)\n\n        model = nn.Sequential(OrderedDict([(\"block1\", sequential_model(4)), (\"block2\", sequential_model(4))]))\n        retie_parameters(model, [[\"block1.linear1.weight\", \"block2.linear1.weight\"]])\n\n        self.assertIs(model.block1.linear1.weight, model.block2.linear1.weight)\n\n    def test_compute_module_sizes(self):\n        model = ModelForTest()\n        expected_sizes = {\"\": 236, \"linear1\": 64, \"linear1.weight\": 48, \"linear1.bias\": 16}\n        expected_sizes.update({\"linear2\": 100, \"linear2.weight\": 80, \"linear2.bias\": 20})\n        expected_sizes.update({\"batchnorm\": 72, \"batchnorm.weight\": 16, \"batchnorm.bias\": 16})\n        expected_sizes.update(\n            {\"batchnorm.running_mean\": 16, \"batchnorm.running_var\": 16, \"batchnorm.num_batches_tracked\": 8}\n        )\n\n        module_sizes = compute_module_sizes(model)\n        self.assertDictEqual(module_sizes, expected_sizes)\n\n        model.half()\n        expected_sizes = {k: s // 2 for k, s in expected_sizes.items()}\n        # This one is not converted to half.\n        expected_sizes[\"batchnorm.num_batches_tracked\"] = 8\n        # This impacts batchnorm and total\n        expected_sizes[\"batchnorm\"] += 4\n        expected_sizes[\"\"] += 4\n\n        module_sizes = compute_module_sizes(model)\n        self.assertDictEqual(module_sizes, expected_sizes)\n\n    def test_check_device_map(self):\n        model = ModelForTest()\n        check_device_map(model, {\"\": 0})\n        with self.assertRaises(ValueError):\n            check_device_map(model, {\"linear1\": 0, \"linear2\": 1})\n\n        check_device_map(model, {\"linear1\": 0, \"linear2\": 1, \"batchnorm\": 1})\n\n    def shard_test_model(self, model, tmp_dir):\n        module_index = {\n            \"linear1\": \"checkpoint_part1.bin\",\n            \"batchnorm\": \"checkpoint_part2.bin\",\n            \"linear2\": \"checkpoint_part3.bin\",\n        }\n        index = {}\n        for name, _ in model.state_dict().items():\n            module = name.split(\".\")[0]\n            index[name] = module_index[module]\n\n        with open(os.path.join(tmp_dir, \"weight_map.index.json\"), \"w\") as f:\n            json.dump(index, f)\n\n        for module, fname in module_index.items():\n            state_dict = {k: v for k, v in model.state_dict().items() if k.startswith(module)}\n            full_fname = os.path.join(tmp_dir, fname)\n            torch.save(state_dict, full_fname)\n\n    def test_load_checkpoint_in_model(self):\n        # Check with whole checkpoint\n        model = ModelForTest()\n        with tempfile.TemporaryDirectory() as tmp_dir:\n            fname = os.path.join(tmp_dir, \"pt_model.bin\")\n            torch.save(model.state_dict(), fname)\n            load_checkpoint_in_model(model, fname)\n\n        # Check with sharded index\n        model = ModelForTest()\n        with tempfile.TemporaryDirectory() as tmp_dir:\n            self.shard_test_model(model, tmp_dir)\n            index_file = os.path.join(tmp_dir, \"weight_map.index.json\")\n            load_checkpoint_in_model(model, index_file)\n\n        # Check with sharded checkpoint\n        model = ModelForTest()\n        with tempfile.TemporaryDirectory() as tmp_dir:\n            self.shard_test_model(model, tmp_dir)\n            load_checkpoint_in_model(model, tmp_dir)\n\n    @require_cuda\n    def test_load_checkpoint_in_model_one_gpu(self):\n        device_map = {\"linear1\": 0, \"batchnorm\": \"cpu\", \"linear2\": \"cpu\"}\n\n        # Check with whole checkpoint\n        model = ModelForTest()\n        with tempfile.TemporaryDirectory() as tmp_dir:\n            fname = os.path.join(tmp_dir, \"pt_model.bin\")\n            torch.save(model.state_dict(), fname)\n            load_checkpoint_in_model(model, fname, device_map=device_map)\n        self.assertEqual(model.linear1.weight.device, torch.device(0))\n        self.assertEqual(model.batchnorm.weight.device, torch.device(\"cpu\"))\n        self.assertEqual(model.linear2.weight.device, torch.device(\"cpu\"))\n\n        # Check with sharded index\n        model = ModelForTest()\n        with tempfile.TemporaryDirectory() as tmp_dir:\n            self.shard_test_model(model, tmp_dir)\n            index_file = os.path.join(tmp_dir, \"weight_map.index.json\")\n            load_checkpoint_in_model(model, index_file, device_map=device_map)\n\n        self.assertEqual(model.linear1.weight.device, torch.device(0))\n        self.assertEqual(model.batchnorm.weight.device, torch.device(\"cpu\"))\n        self.assertEqual(model.linear2.weight.device, torch.device(\"cpu\"))\n\n        # Check with sharded checkpoint folder\n        model = ModelForTest()\n        with tempfile.TemporaryDirectory() as tmp_dir:\n            self.shard_test_model(model, tmp_dir)\n            load_checkpoint_in_model(model, tmp_dir, device_map=device_map)\n\n        self.assertEqual(model.linear1.weight.device, torch.device(0))\n        self.assertEqual(model.batchnorm.weight.device, torch.device(\"cpu\"))\n        self.assertEqual(model.linear2.weight.device, torch.device(\"cpu\"))\n\n    @require_cuda\n    def test_load_checkpoint_in_model_disk_offload(self):\n        device_map = {\"linear1\": \"cpu\", \"batchnorm\": \"disk\", \"linear2\": \"cpu\"}\n\n        model = ModelForTest()\n        with tempfile.TemporaryDirectory() as tmp_dir:\n            fname = os.path.join(tmp_dir, \"pt_model.bin\")\n            torch.save(model.state_dict(), fname)\n            load_checkpoint_in_model(model, fname, device_map=device_map, offload_folder=tmp_dir)\n        self.assertEqual(model.linear1.weight.device, torch.device(\"cpu\"))\n        self.assertEqual(model.batchnorm.weight.device, torch.device(\"meta\"))\n        # Buffers are not offloaded by default\n        self.assertEqual(model.batchnorm.running_mean.device, torch.device(\"cpu\"))\n        self.assertEqual(model.linear2.weight.device, torch.device(\"cpu\"))\n\n        model = ModelForTest()\n        with tempfile.TemporaryDirectory() as tmp_dir:\n            fname = os.path.join(tmp_dir, \"pt_model.bin\")\n            torch.save(model.state_dict(), fname)\n            load_checkpoint_in_model(model, fname, device_map=device_map, offload_folder=tmp_dir, offload_buffers=True)\n        self.assertEqual(model.linear1.weight.device, torch.device(\"cpu\"))\n        self.assertEqual(model.batchnorm.weight.device, torch.device(\"meta\"))\n        self.assertEqual(model.batchnorm.running_mean.device, torch.device(\"meta\"))\n        self.assertEqual(model.linear2.weight.device, torch.device(\"cpu\"))\n\n    @require_multi_gpu\n    def test_load_checkpoint_in_model_two_gpu(self):\n        device_map = {\"linear1\": 0, \"batchnorm\": \"cpu\", \"linear2\": 1}\n\n        # Check with whole checkpoint\n        model = ModelForTest()\n        with tempfile.TemporaryDirectory() as tmp_dir:\n            fname = os.path.join(tmp_dir, \"pt_model.bin\")\n            torch.save(model.state_dict(), fname)\n            load_checkpoint_in_model(model, fname, device_map=device_map)\n        self.assertEqual(model.linear1.weight.device, torch.device(0))\n        self.assertEqual(model.batchnorm.weight.device, torch.device(\"cpu\"))\n        self.assertEqual(model.linear2.weight.device, torch.device(1))\n\n        # Check with sharded index\n        model = ModelForTest()\n        with tempfile.TemporaryDirectory() as tmp_dir:\n            self.shard_test_model(model, tmp_dir)\n            index_file = os.path.join(tmp_dir, \"weight_map.index.json\")\n            load_checkpoint_in_model(model, index_file, device_map=device_map)\n\n        self.assertEqual(model.linear1.weight.device, torch.device(0))\n        self.assertEqual(model.batchnorm.weight.device, torch.device(\"cpu\"))\n        self.assertEqual(model.linear2.weight.device, torch.device(1))\n\n        # Check with sharded checkpoint\n        model = ModelForTest()\n        with tempfile.TemporaryDirectory() as tmp_dir:\n            self.shard_test_model(model, tmp_dir)\n            load_checkpoint_in_model(model, tmp_dir, device_map=device_map)\n\n        self.assertEqual(model.linear1.weight.device, torch.device(0))\n        self.assertEqual(model.batchnorm.weight.device, torch.device(\"cpu\"))\n        self.assertEqual(model.linear2.weight.device, torch.device(1))\n\n    def test_clean_device_map(self):\n        # Regroup everything if all is on the same device\n        self.assertDictEqual(clean_device_map({\"a\": 0, \"b\": 0, \"c\": 0}), {\"\": 0})\n        # Regroups children of level 1 on the same device\n        self.assertDictEqual(\n            clean_device_map({\"a.x\": 0, \"a.y\": 0, \"b.x\": 1, \"b.y\": 1, \"c\": 1}), {\"a\": 0, \"b\": 1, \"c\": 1}\n        )\n        # Regroups children of level 2 on the same device\n        self.assertDictEqual(\n            clean_device_map({\"a.x\": 0, \"a.y\": 0, \"b.x.0\": 1, \"b.x.1\": 1, \"b.y.0\": 2, \"b.y.1\": 2, \"c\": 2}),\n            {\"a\": 0, \"b.x\": 1, \"b.y\": 2, \"c\": 2},\n        )\n\n    def test_infer_auto_device_map(self):\n        model = ModelForTest()\n        # model has size 236: linear1 64, batchnorm 72, linear2 100\n\n        device_map = infer_auto_device_map(model, max_memory={0: 200, 1: 200})\n        # only linear1 fits on device 0 as we keep memory available for the maximum layer in case of offload\n        self.assertDictEqual(device_map, {\"linear1\": 0, \"batchnorm\": 1, \"linear2\": 1})\n\n        device_map = infer_auto_device_map(model, max_memory={0: 200, 1: 172, 2: 200})\n        # On device 1, we don't care about keeping size available for the max layer, so even if there is just the\n        # size available for batchnorm + linear2, they fit here.\n        self.assertDictEqual(device_map, {\"linear1\": 0, \"batchnorm\": 1, \"linear2\": 1})\n\n        model.linear1.weight = model.linear2.weight\n        device_map = infer_auto_device_map(model, max_memory={0: 200, 1: 200})\n        # By tying weights, the whole model fits on device 0\n        self.assertDictEqual(device_map, {\"\": 0})\n\n        # When splitting a bigger model, the split is done at the layer level\n        model = nn.Sequential(ModelForTest(), ModelForTest(), ModelForTest())\n        device_map = infer_auto_device_map(model, max_memory={0: 500, 1: 500})\n        self.assertDictEqual(device_map, {\"0\": 0, \"1.linear1\": 0, \"1.batchnorm\": 0, \"1.linear2\": 1, \"2\": 1})\n\n        # With no_split_module_classes, it's done at that module level\n        model = nn.Sequential(ModelForTest(), ModelForTest(), ModelForTest())\n        device_map = infer_auto_device_map(\n            model, max_memory={0: 500, 1: 500}, no_split_module_classes=[\"ModelForTest\"]\n        )\n        self.assertDictEqual(device_map, {\"0\": 0, \"1\": 1, \"2\": 1})\n\n    def test_infer_auto_device_map_with_tied_weights(self):\n        model = nn.Sequential(\n            OrderedDict([(\"layer1\", ModelForTest()), (\"layer2\", ModelForTest()), (\"layer3\", ModelForTest())])\n        )\n        model.layer3.linear2.weight = model.layer1.linear2.weight\n        device_map = infer_auto_device_map(model, max_memory={0: 400, 1: 500})\n        expected = {\"layer1\": 0, \"layer3.linear2\": 0, \"layer2\": 1, \"layer3.linear1\": 1, \"layer3.batchnorm\": 1}\n        self.assertDictEqual(device_map, expected)\n\n        # With three weights tied together\n        model.layer2.linear2.weight = model.layer1.linear2.weight\n        device_map = infer_auto_device_map(model, max_memory={0: 400, 1: 500})\n        expected = {\n            \"layer1\": 0,\n            \"layer2.linear2\": 0,\n            \"layer3.linear2\": 0,\n            \"layer2.linear1\": 1,\n            \"layer2.batchnorm\": 1,\n            \"layer3.linear1\": 1,\n            \"layer3.batchnorm\": 1,\n        }\n        self.assertDictEqual(device_map, expected)\n\n        # With two groups of weights tied together\n        model.layer2.linear1.weight = model.layer1.linear1.weight\n        device_map = infer_auto_device_map(model, max_memory={0: 400, 1: 500})\n        expected = {\n            \"layer1\": 0,\n            \"layer2.linear1\": 0,\n            \"layer2.linear2\": 0,\n            \"layer3.linear2\": 0,\n            \"layer2.batchnorm\": 1,\n            \"layer3.linear1\": 1,\n            \"layer3.batchnorm\": 1,\n        }\n        self.assertDictEqual(device_map, expected)\n\n        # With weights ties in the same module\n        model = nn.Sequential(\n            OrderedDict(\n                [\n                    (\"linear1\", nn.Linear(4, 4)),\n                    (\"linear2\", nn.Linear(6, 6)),\n                    (\"linear3\", nn.Linear(4, 4)),\n                    (\"linear4\", nn.Linear(6, 6)),\n                ]\n            )\n        )\n        model.linear3.weight = model.linear1.weight\n        model.linear3.bias = model.linear1.bias\n        device_map = infer_auto_device_map(model, max_memory={0: 250, 1: 400})\n        expected = {\"linear1\": 0, \"linear2\": 1, \"linear3\": 0, \"linear4\": 1}\n        self.assertDictEqual(device_map, expected)\n\n    @require_huggingface_suite\n    def test_infer_auto_device_map_on_t0pp(self):\n        from transformers import AutoConfig, AutoModelForSeq2SeqLM\n\n        config = AutoConfig.from_pretrained(\"bigscience/T0pp\")\n        with init_empty_weights():\n            model = AutoModelForSeq2SeqLM.from_config(config)\n        model.tie_weights()\n\n        special_dtypes = {n: torch.float32 for n, _ in model.named_parameters() if \"wo\" in n}\n        max_memory = {0: 10**10, 1: 10**10, \"cpu\": 10**10}\n        device_map = infer_auto_device_map(\n            model,\n            no_split_module_classes=[\"T5Block\"],\n            dtype=torch.float16,\n            max_memory=max_memory,\n            special_dtypes=special_dtypes,\n        )\n\n        # The 3 tied weights should all be on device 0\n        self.assertEqual(device_map[\"shared\"], 0)\n        self.assertEqual(device_map[\"encoder.embed_tokens\"], 0)\n        self.assertEqual(device_map[\"decoder.embed_tokens\"], 0)\n\n    @require_cuda\n    def test_get_balanced_memory(self):\n        model = ModelForTest()\n        # model has size 236: linear1 64, batchnorm 72, linear2 100\n        max_memory = get_balanced_memory(model, max_memory={0: 200, 1: 200})\n        self.assertDictEqual({0: 200, 1: 200}, max_memory)\n\n        # We should be able to set models on a non-contiguous sub-set of\n        max_memory = get_balanced_memory(model, max_memory={0: 200, 2: 200})\n        self.assertDictEqual({0: 200, 2: 200}, max_memory)\n\n        max_memory = get_balanced_memory(model, max_memory={0: 300, 1: 300})\n        self.assertDictEqual({0: 215, 1: 300}, max_memory)\n\n        # Last device always get max memory to give more buffer and avoid accidental CPU offload\n        max_memory = get_balanced_memory(model, max_memory={0: 300, 1: 500})\n        self.assertDictEqual({0: 215, 1: 500}, max_memory)\n\n        # Last device always get max memory to give more buffer, even if CPU is provided\n        max_memory = get_balanced_memory(model, max_memory={0: 300, \"cpu\": 1000})\n        self.assertDictEqual({0: 300, \"cpu\": 1000}, max_memory)\n\n        # If we set a device to 0, it's not counted.\n        max_memory = get_balanced_memory(model, max_memory={0: 0, 1: 300, 2: 300})\n        self.assertDictEqual({0: 0, 1: 215, 2: 300}, max_memory)\n\n    @require_cuda\n    @require_safetensors\n    def test_load_state_dict(self):\n        from safetensors.torch import save_file\n\n        state_dict = {k: torch.randn(4, 5) for k in [\"a\", \"b\", \"c\"]}\n        device_maps = [{\"a\": \"cpu\", \"b\": 0, \"c\": \"disk\"}, {\"a\": 0, \"b\": 0, \"c\": \"disk\"}, {\"a\": 0, \"b\": 0, \"c\": 0}]\n\n        for device_map in device_maps:\n            with tempfile.TemporaryDirectory() as tmp_dir:\n                checkpoint_file = os.path.join(tmp_dir, \"model.safetensors\")\n                save_file(state_dict, checkpoint_file, metadata={\"format\": \"pt\"})\n\n                loaded_state_dict = load_state_dict(checkpoint_file, device_map=device_map)\n\n            for param, device in device_map.items():\n                device = device if device != \"disk\" else \"cpu\"\n                self.assertEqual(loaded_state_dict[param].device, torch.device(device))\n", "import json\nimport os\nimport tempfile\nfrom unittest.mock import patch\n\nimport torch\nfrom torch.utils.data import DataLoader, TensorDataset\n\nfrom accelerate import DistributedType, infer_auto_device_map, init_empty_weights\nfrom accelerate.accelerator import Accelerator\nfrom accelerate.state import GradientState, PartialState\nfrom accelerate.test_utils import require_bnb, require_multi_gpu, slow\nfrom accelerate.test_utils.testing import AccelerateTestCase, require_cuda\nfrom accelerate.utils import patch_environment\n\n\ndef create_components():\n    model = torch.nn.Linear(2, 4)\n    optimizer = torch.optim.AdamW(model.parameters(), lr=1.0)\n    scheduler = torch.optim.lr_scheduler.OneCycleLR(optimizer, max_lr=0.01, steps_per_epoch=2, epochs=1)\n    train_dl = DataLoader(TensorDataset(torch.tensor([1, 2, 3])))\n    valid_dl = DataLoader(TensorDataset(torch.tensor([4, 5, 6])))\n\n    return model, optimizer, scheduler, train_dl, valid_dl\n\n\ndef get_signature(model):\n    return (model.weight.abs().sum() + model.bias.abs().sum()).item()\n\n\ndef load_random_weights(model):\n    state = torch.nn.Linear(*tuple(model.weight.T.shape)).state_dict()\n    model.load_state_dict(state)\n\n\nclass AcceleratorTester(AccelerateTestCase):\n    @require_cuda\n    def test_accelerator_can_be_reinstantiated(self):\n        _ = Accelerator()\n        assert PartialState._shared_state[\"_cpu\"] is False\n        assert PartialState._shared_state[\"device\"].type == \"cuda\"\n        with self.assertRaises(ValueError):\n            _ = Accelerator(cpu=True)\n\n    def test_mutable_states(self):\n        accelerator = Accelerator()\n        state = GradientState()\n        assert state.num_steps == 1\n        accelerator.gradient_accumulation_steps = 4\n        assert state.num_steps == 4\n\n        assert state.sync_gradients is True\n        accelerator.sync_gradients = False\n        assert state.sync_gradients is False\n        GradientState._reset_state()\n\n    def test_prepared_objects_are_referenced(self):\n        accelerator = Accelerator()\n        model, optimizer, scheduler, train_dl, valid_dl = create_components()\n\n        (\n            prepared_model,\n            prepared_optimizer,\n            prepared_scheduler,\n            prepared_train_dl,\n            prepared_valid_dl,\n        ) = accelerator.prepare(model, optimizer, scheduler, train_dl, valid_dl)\n\n        self.assertTrue(prepared_model in accelerator._models)\n        self.assertTrue(prepared_optimizer in accelerator._optimizers)\n        self.assertTrue(prepared_scheduler in accelerator._schedulers)\n        self.assertTrue(prepared_train_dl in accelerator._dataloaders)\n        self.assertTrue(prepared_valid_dl in accelerator._dataloaders)\n\n    def test_free_memory_dereferences_prepared_components(self):\n        accelerator = Accelerator()\n        model, optimizer, scheduler, train_dl, valid_dl = create_components()\n        accelerator.prepare(model, optimizer, scheduler, train_dl, valid_dl)\n        accelerator.free_memory()\n\n        self.assertTrue(len(accelerator._models) == 0)\n        self.assertTrue(len(accelerator._optimizers) == 0)\n        self.assertTrue(len(accelerator._schedulers) == 0)\n        self.assertTrue(len(accelerator._dataloaders) == 0)\n\n    def test_env_var_device(self):\n        \"\"\"Tests that setting the torch device with ACCELERATE_TORCH_DEVICE overrides default device.\"\"\"\n        PartialState._reset_state()\n\n        # Mock torch.cuda.set_device to avoid an exception as the device doesn't exist\n        def noop(*args, **kwargs):\n            pass\n\n        with patch(\"torch.cuda.set_device\", noop), patch_environment(ACCELERATE_TORCH_DEVICE=\"cuda:64\"):\n            accelerator = Accelerator()\n            self.assertEqual(str(accelerator.state.device), \"cuda:64\")\n\n    def test_save_load_model(self):\n        accelerator = Accelerator()\n        model, optimizer, scheduler, train_dl, valid_dl = create_components()\n        accelerator.prepare(model, optimizer, scheduler, train_dl, valid_dl)\n\n        model_signature = get_signature(model)\n\n        with tempfile.TemporaryDirectory() as tmpdirname:\n            accelerator.save_state(tmpdirname)\n\n            # make sure random weights don't match\n            load_random_weights(model)\n            self.assertTrue(abs(model_signature - get_signature(model)) > 1e-3)\n\n            # make sure loaded weights match\n            accelerator.load_state(tmpdirname)\n            self.assertTrue(abs(model_signature - get_signature(model)) < 1e-3)\n\n    def test_save_load_model_with_hooks(self):\n        accelerator = Accelerator()\n        model, optimizer, scheduler, train_dl, valid_dl = create_components()\n        accelerator.prepare(model, optimizer, scheduler, train_dl, valid_dl)\n\n        model_signature = get_signature(model)\n\n        # saving hook\n        def save_config(models, weights, output_dir):\n            config = {\"class_name\": models[0].__class__.__name__}\n\n            with open(os.path.join(output_dir, \"data.json\"), \"w\") as f:\n                json.dump(config, f)\n\n        # loading hook\n        def load_config(models, input_dir):\n            with open(os.path.join(input_dir, \"data.json\"), \"r\") as f:\n                config = json.load(f)\n\n            models[0].class_name = config[\"class_name\"]\n\n        save_hook = accelerator.register_save_state_pre_hook(save_config)\n        load_hook = accelerator.register_load_state_pre_hook(load_config)\n\n        with tempfile.TemporaryDirectory() as tmpdirname:\n            accelerator.save_state(tmpdirname)\n\n            # make sure random weights don't match with hooks\n            load_random_weights(model)\n            self.assertTrue(abs(model_signature - get_signature(model)) > 1e-3)\n\n            # random class name to verify correct one is loaded\n            model.class_name = \"random\"\n\n            # make sure loaded weights match with hooks\n            accelerator.load_state(tmpdirname)\n            self.assertTrue(abs(model_signature - get_signature(model)) < 1e-3)\n\n            # mode.class_name is loaded from config\n            self.assertTrue(model.class_name == model.__class__.__name__)\n\n        # remove hooks\n        save_hook.remove()\n        load_hook.remove()\n\n        with tempfile.TemporaryDirectory() as tmpdirname:\n            accelerator.save_state(tmpdirname)\n\n            # make sure random weights don't match with hooks removed\n            load_random_weights(model)\n            self.assertTrue(abs(model_signature - get_signature(model)) > 1e-3)\n\n            # random class name to verify correct one is loaded\n            model.class_name = \"random\"\n\n            # make sure loaded weights match with hooks removed\n            accelerator.load_state(tmpdirname)\n            self.assertTrue(abs(model_signature - get_signature(model)) < 1e-3)\n\n            # mode.class_name is NOT loaded from config\n            self.assertTrue(model.class_name != model.__class__.__name__)\n\n    def test_accelerator_none(self):\n        \"\"\"Just test that passing None to accelerator.prepare() works.\"\"\"\n        accelerator = Accelerator()\n        model, optimizer, scheduler, train_dl, valid_dl = create_components()\n        dummy_obj = None\n\n        # This should work\n        model, optimizer, scheduler, train_dl, valid_dl, dummy_obj = accelerator.prepare(\n            model, optimizer, scheduler, train_dl, valid_dl, dummy_obj\n        )\n        self.assertTrue(dummy_obj is None)\n\n    def test_is_accelerator_prepared(self):\n        \"\"\"Checks that `_is_accelerator_prepared` is set properly\"\"\"\n        accelerator = Accelerator()\n        model, optimizer, scheduler, train_dl, valid_dl = create_components()\n        dummy_obj = [1, 2, 3]\n\n        # This should work\n        model, optimizer, scheduler, train_dl, valid_dl, dummy_obj = accelerator.prepare(\n            model, optimizer, scheduler, train_dl, valid_dl, dummy_obj\n        )\n        self.assertEqual(\n            getattr(dummy_obj, \"_is_accelerate_prepared\", False),\n            False,\n            \"Dummy object should have `_is_accelerate_prepared` set to `True`\",\n        )\n        self.assertEqual(\n            getattr(model, \"_is_accelerate_prepared\", False),\n            True,\n            \"Model is missing `_is_accelerator_prepared` or is set to `False`\",\n        )\n        self.assertEqual(\n            getattr(optimizer, \"_is_accelerate_prepared\", False),\n            True,\n            \"Optimizer is missing `_is_accelerator_prepared` or is set to `False`\",\n        )\n        self.assertEqual(\n            getattr(scheduler, \"_is_accelerate_prepared\", False),\n            True,\n            \"Scheduler is missing `_is_accelerator_prepared` or is set to `False`\",\n        )\n        self.assertEqual(\n            getattr(train_dl, \"_is_accelerate_prepared\", False),\n            True,\n            \"Train Dataloader is missing `_is_accelerator_prepared` or is set to `False`\",\n        )\n        self.assertEqual(\n            getattr(valid_dl, \"_is_accelerate_prepared\", False),\n            True,\n            \"Valid Dataloader is missing `_is_accelerator_prepared` or is set to `False`\",\n        )\n\n    @slow\n    @require_bnb\n    def test_accelerator_bnb(self):\n        \"\"\"Tests that the accelerator can be used with the BNB library.\"\"\"\n        from transformers import AutoModelForCausalLM\n\n        model = AutoModelForCausalLM.from_pretrained(\n            \"EleutherAI/gpt-neo-125m\",\n            load_in_8bit=True,\n            device_map={\"\": 0},\n        )\n        accelerator = Accelerator()\n\n        # This should work\n        model = accelerator.prepare(model)\n\n    @slow\n    @require_bnb\n    def test_accelerator_bnb_cpu_error(self):\n        \"\"\"Tests that the accelerator can be used with the BNB library. This should fail as we are trying to load a model\n        that is loaded between cpu and gpu\"\"\"\n        from transformers import AutoModelForCausalLM\n\n        accelerator = Accelerator()\n\n        with init_empty_weights():\n            model = AutoModelForCausalLM.from_pretrained(\n                \"EleutherAI/gpt-neo-125m\",\n            )\n            model.tie_weights()\n            device_map = infer_auto_device_map(model)\n            device_map[\"lm_head\"] = \"cpu\"\n\n        model = AutoModelForCausalLM.from_pretrained(\n            \"EleutherAI/gpt-neo-125m\", device_map=device_map, load_in_8bit=True, llm_int8_enable_fp32_cpu_offload=True\n        )\n\n        # This should not work and get value error\n        with self.assertRaises(ValueError):\n            model = accelerator.prepare(model)\n\n    @slow\n    @require_bnb\n    @require_multi_gpu\n    def test_accelerator_bnb_multi_gpu(self):\n        \"\"\"Tests that the accelerator can be used with the BNB library.\"\"\"\n        from transformers import AutoModelForCausalLM\n\n        PartialState._shared_state = {\"distributed_type\": DistributedType.MULTI_GPU}\n\n        with init_empty_weights():\n            model = AutoModelForCausalLM.from_pretrained(\n                \"EleutherAI/gpt-neo-125m\",\n            )\n            model.tie_weights()\n            device_map = infer_auto_device_map(model)\n            device_map[\"lm_head\"] = 1\n\n        model = AutoModelForCausalLM.from_pretrained(\n            \"EleutherAI/gpt-neo-125m\",\n            load_in_8bit=True,\n            device_map=device_map,\n        )\n        accelerator = Accelerator()\n\n        # This should not work and get value error\n        with self.assertRaises(ValueError):\n            _ = accelerator.prepare(model)\n\n        PartialState._reset_state()\n\n    @slow\n    @require_bnb\n    @require_multi_gpu\n    def test_accelerator_bnb_multi_gpu_no_distributed(self):\n        \"\"\"Tests that the accelerator can be used with the BNB library.\"\"\"\n        from transformers import AutoModelForCausalLM\n\n        with init_empty_weights():\n            model = AutoModelForCausalLM.from_pretrained(\n                \"EleutherAI/gpt-neo-125m\",\n            )\n            device_map = infer_auto_device_map(model)\n            device_map[\"lm_head\"] = 1\n\n        model = AutoModelForCausalLM.from_pretrained(\n            \"EleutherAI/gpt-neo-125m\",\n            load_in_8bit=True,\n            device_map=device_map,\n        )\n        accelerator = Accelerator()\n\n        # This should work\n        _ = accelerator.prepare(model)\n\n    @require_cuda\n    def test_accelerator_cpu_flag_prepare(self):\n        model = torch.nn.Linear(10, 10)\n        sgd = torch.optim.SGD(model.parameters(), lr=0.01)\n        accelerator = Accelerator(cpu=True)\n        _ = accelerator.prepare(sgd)\n", "# Copyright 2021 The HuggingFace Team. All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport inspect\nimport os\nimport unittest\n\nimport torch\n\nimport accelerate\nfrom accelerate import debug_launcher\nfrom accelerate.test_utils import (\n    execute_subprocess_async,\n    require_cpu,\n    require_multi_gpu,\n    require_single_gpu,\n    test_sync,\n)\nfrom accelerate.utils import patch_environment\n\n\nclass SyncScheduler(unittest.TestCase):\n    def setUp(self):\n        mod_file = inspect.getfile(accelerate.test_utils)\n        self.test_file_path = os.path.sep.join(mod_file.split(os.path.sep)[:-1] + [\"scripts\", \"test_sync.py\"])\n\n    @require_cpu\n    def test_gradient_sync_cpu_noop(self):\n        debug_launcher(test_sync.main, num_processes=1)\n\n    @require_cpu\n    def test_gradient_sync_cpu_multi(self):\n        debug_launcher(test_sync.main)\n\n    @require_single_gpu\n    def test_gradient_sync_gpu(self):\n        test_sync.main()\n\n    @require_multi_gpu\n    def test_gradient_sync_gpu_multi(self):\n        print(f\"Found {torch.cuda.device_count()} devices.\")\n        cmd = [\"torchrun\", f\"--nproc_per_node={torch.cuda.device_count()}\", self.test_file_path]\n        with patch_environment(omp_num_threads=1):\n            execute_subprocess_async(cmd, env=os.environ.copy())\n", "# Copyright 2022 The HuggingFace Team. All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport unittest\n\nfrom accelerate import debug_launcher\nfrom accelerate.test_utils import require_cpu, test_ops, test_script\n\n\n@require_cpu\nclass MultiCPUTester(unittest.TestCase):\n    def test_cpu(self):\n        debug_launcher(test_script.main)\n\n    def test_ops(self):\n        debug_launcher(test_ops.main)\n", "# Copyright 2021 The HuggingFace Team. All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport inspect\nimport os\nimport unittest\n\nimport torch\n\nimport accelerate\nfrom accelerate import Accelerator\nfrom accelerate.test_utils import execute_subprocess_async, require_multi_gpu\nfrom accelerate.utils import patch_environment\n\n\nclass MultiGPUTester(unittest.TestCase):\n    def setUp(self):\n        mod_file = inspect.getfile(accelerate.test_utils)\n        self.test_file_path = os.path.sep.join(mod_file.split(os.path.sep)[:-1] + [\"scripts\", \"test_script.py\"])\n        self.data_loop_file_path = os.path.sep.join(\n            mod_file.split(os.path.sep)[:-1] + [\"scripts\", \"test_distributed_data_loop.py\"]\n        )\n        self.operation_file_path = os.path.sep.join(mod_file.split(os.path.sep)[:-1] + [\"scripts\", \"test_ops.py\"])\n\n    @require_multi_gpu\n    def test_multi_gpu(self):\n        print(f\"Found {torch.cuda.device_count()} devices.\")\n        cmd = [\"torchrun\", f\"--nproc_per_node={torch.cuda.device_count()}\", self.test_file_path]\n        with patch_environment(omp_num_threads=1):\n            execute_subprocess_async(cmd, env=os.environ.copy())\n\n    @require_multi_gpu\n    def test_multi_gpu_ops(self):\n        print(f\"Found {torch.cuda.device_count()} devices.\")\n        cmd = [\"torchrun\", f\"--nproc_per_node={torch.cuda.device_count()}\", self.operation_file_path]\n        print(f\"Command: {cmd}\")\n        with patch_environment(omp_num_threads=1):\n            execute_subprocess_async(cmd, env=os.environ.copy())\n\n    @require_multi_gpu\n    def test_pad_across_processes(self):\n        cmd = [\"torchrun\", f\"--nproc_per_node={torch.cuda.device_count()}\", inspect.getfile(self.__class__)]\n        with patch_environment(omp_num_threads=1):\n            execute_subprocess_async(cmd, env=os.environ.copy())\n\n    @require_multi_gpu\n    def test_distributed_data_loop(self):\n        \"\"\"\n        This TestCase checks the behaviour that occurs during distributed training or evaluation,\n        when the batch size does not evenly divide the dataset size.\n        \"\"\"\n        print(f\"Found {torch.cuda.device_count()} devices, using 2 devices only\")\n        cmd = [\"torchrun\", f\"--nproc_per_node={torch.cuda.device_count()}\", self.data_loop_file_path]\n        with patch_environment(omp_num_threads=1, cuda_visible_devices=\"0,1\"):\n            execute_subprocess_async(cmd, env=os.environ.copy())\n\n\nif __name__ == \"__main__\":\n    accelerator = Accelerator()\n    shape = (accelerator.state.process_index + 2, 10)\n    tensor = torch.randint(0, 10, shape).to(accelerator.device)\n\n    error_msg = \"\"\n\n    tensor1 = accelerator.pad_across_processes(tensor)\n    if tensor1.shape[0] != accelerator.state.num_processes + 1:\n        error_msg += f\"Found shape {tensor1.shape} but should have {accelerator.state.num_processes + 1} at dim 0.\"\n    if not torch.equal(tensor1[: accelerator.state.process_index + 2], tensor):\n        error_msg += \"Tensors have different values.\"\n    if not torch.all(tensor1[accelerator.state.process_index + 2 :] == 0):\n        error_msg += \"Padding was not done with the right value (0).\"\n\n    tensor2 = accelerator.pad_across_processes(tensor, pad_first=True)\n    if tensor2.shape[0] != accelerator.state.num_processes + 1:\n        error_msg += f\"Found shape {tensor2.shape} but should have {accelerator.state.num_processes + 1} at dim 0.\"\n    index = accelerator.state.num_processes - accelerator.state.process_index - 1\n    if not torch.equal(tensor2[index:], tensor):\n        error_msg += \"Tensors have different values.\"\n    if not torch.all(tensor2[:index] == 0):\n        error_msg += \"Padding was not done with the right value (0).\"\n\n    # Raise error at the end to make sure we don't stop at the first failure.\n    if len(error_msg) > 0:\n        raise ValueError(error_msg)\n", "# Copyright 2022 The HuggingFace Team. All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport pickle\nimport unittest\n\nimport torch\n\nfrom accelerate import Accelerator\nfrom accelerate.state import AcceleratorState\nfrom accelerate.test_utils import require_cpu, require_cuda\n\n\n@require_cpu\nclass OptimizerTester(unittest.TestCase):\n    def test_accelerated_optimizer_pickling(self):\n        model = torch.nn.Linear(10, 10)\n        optimizer = torch.optim.SGD(model.parameters(), 0.1)\n        accelerator = Accelerator()\n        optimizer = accelerator.prepare(optimizer)\n        try:\n            pickle.loads(pickle.dumps(optimizer))\n        except Exception as e:\n            self.fail(f\"Accelerated optimizer pickling failed with {e}\")\n        AcceleratorState._reset_state()\n\n\n@require_cuda\nclass CudaOptimizerTester(unittest.TestCase):\n    def test_accelerated_optimizer_step_was_skipped(self):\n        model = torch.nn.Linear(5, 5)\n        optimizer = torch.optim.SGD(model.parameters(), 0.1)\n        accelerator = Accelerator(mixed_precision=\"fp16\")\n        model, optimizer = accelerator.prepare(model, optimizer)\n\n        loss = model(torch.randn(2, 5, device=accelerator.device)).sum()\n        accelerator.backward(loss)\n        for p in model.parameters():\n            # Fake the gradients, as if there's no overflow\n            p.grad.fill_(0.01)\n\n        optimizer.step()\n        self.assertTrue(optimizer.step_was_skipped is False)\n\n        loss = model(torch.randn(2, 5, device=accelerator.device)).sum()\n        accelerator.backward(loss)\n        for p in model.parameters():\n            p.grad.fill_(0.01)\n        # Manually set the gradients to be NaN, as if there's an overflow\n        p.grad[0] = torch.tensor(float(\"nan\"))\n\n        optimizer.step()\n        self.assertTrue(optimizer.step_was_skipped is True)\n\n        loss = model(torch.randn(2, 5, device=accelerator.device)).sum()\n        accelerator.backward(loss)\n        for p in model.parameters():\n            p.grad.fill_(0.01)\n        # Manually set the gradients to be NaN, as if there's an overflow\n        p.grad[0] = torch.tensor(float(\"nan\"))\n\n        optimizer.step()\n        self.assertTrue(optimizer.step_was_skipped is True)\n\n        loss = model(torch.randn(2, 5, device=accelerator.device)).sum()\n        accelerator.backward(loss)\n        for p in model.parameters():\n            # Fake the gradients, as if there's no overflow\n            p.grad.fill_(0.01)\n\n        optimizer.step()\n        self.assertTrue(optimizer.step_was_skipped is False)\n\n        AcceleratorState._reset_state()\n", "# Copyright 2022 The HuggingFace Team. All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport inspect\nimport unittest\n\nimport torch\nimport torch.nn as nn\n\nfrom accelerate.hooks import (\n    AlignDevicesHook,\n    ModelHook,\n    SequentialHook,\n    add_hook_to_module,\n    attach_align_device_hook,\n    remove_hook_from_module,\n    remove_hook_from_submodules,\n)\nfrom accelerate.test_utils import require_multi_gpu\n\n\nclass ModelForTest(nn.Module):\n    def __init__(self):\n        super().__init__()\n        self.linear1 = nn.Linear(3, 4)\n        self.batchnorm = nn.BatchNorm1d(4)\n        self.linear2 = nn.Linear(4, 5)\n\n    def forward(self, x):\n        return self.linear2(self.batchnorm(self.linear1(x)))\n\n\nclass PreForwardHook(ModelHook):\n    def pre_forward(self, module, *args, **kwargs):\n        return (args[0] + 1,) + args[1:], kwargs\n\n\nclass PostForwardHook(ModelHook):\n    def post_forward(self, module, output):\n        return output + 1\n\n\nclass HooksModelTester(unittest.TestCase):\n    def test_add_and_remove_hooks(self):\n        test_model = ModelForTest()\n        test_hook = ModelHook()\n\n        add_hook_to_module(test_model, test_hook)\n        self.assertEqual(test_model._hf_hook, test_hook)\n        self.assertTrue(hasattr(test_model, \"_old_forward\"))\n\n        # Check adding the hook did not change the name or the signature\n        self.assertEqual(test_model.forward.__name__, \"forward\")\n        self.assertListEqual(list(inspect.signature(test_model.forward).parameters), [\"x\"])\n\n        remove_hook_from_module(test_model)\n        self.assertFalse(hasattr(test_model, \"_hf_hook\"))\n        self.assertFalse(hasattr(test_model, \"_old_forward\"))\n\n    def test_append_and_remove_hooks(self):\n        test_model = ModelForTest()\n        test_hook = ModelHook()\n\n        add_hook_to_module(test_model, test_hook)\n        add_hook_to_module(test_model, test_hook, append=True)\n\n        self.assertEqual(isinstance(test_model._hf_hook, SequentialHook), True)\n        self.assertEqual(len(test_model._hf_hook.hooks), 2)\n        self.assertTrue(hasattr(test_model, \"_old_forward\"))\n\n        # Check adding the hook did not change the name or the signature\n        self.assertEqual(test_model.forward.__name__, \"forward\")\n        self.assertListEqual(list(inspect.signature(test_model.forward).parameters), [\"x\"])\n\n        remove_hook_from_module(test_model)\n        self.assertFalse(hasattr(test_model, \"_hf_hook\"))\n        self.assertFalse(hasattr(test_model, \"_old_forward\"))\n\n    def test_pre_forward_hook_is_executed(self):\n        test_model = ModelForTest()\n        x = torch.randn(2, 3)\n        expected = test_model(x + 1)\n        expected2 = test_model(x + 2)\n\n        test_hook = PreForwardHook()\n        add_hook_to_module(test_model, test_hook)\n        output1 = test_model(x)\n        self.assertTrue(torch.allclose(output1, expected, atol=1e-5))\n\n        # Attaching a hook to a model when it already has one replaces, does not chain\n        test_hook = PreForwardHook()\n        add_hook_to_module(test_model, test_hook)\n        output1 = test_model(x)\n        self.assertTrue(torch.allclose(output1, expected, atol=1e-5))\n\n        # You need to use the sequential hook to chain two or more hooks\n        test_hook = SequentialHook(PreForwardHook(), PreForwardHook())\n        add_hook_to_module(test_model, test_hook)\n\n        output2 = test_model(x)\n        assert torch.allclose(output2, expected2, atol=1e-5)\n\n    def test_post_forward_hook_is_executed(self):\n        test_model = ModelForTest()\n        x = torch.randn(2, 3)\n        output = test_model(x)\n\n        test_hook = PostForwardHook()\n        add_hook_to_module(test_model, test_hook)\n        output1 = test_model(x)\n        self.assertTrue(torch.allclose(output1, output + 1, atol=1e-5))\n\n        # Attaching a hook to a model when it already has one replaces, does not chain\n        test_hook = PostForwardHook()\n        add_hook_to_module(test_model, test_hook)\n        output1 = test_model(x)\n        self.assertTrue(torch.allclose(output1, output + 1, atol=1e-5))\n\n        # You need to use the sequential hook to chain two or more hooks\n        test_hook = SequentialHook(PostForwardHook(), PostForwardHook())\n        add_hook_to_module(test_model, test_hook)\n\n        output2 = test_model(x)\n        assert torch.allclose(output2, output + 2, atol=1e-5)\n\n    def test_no_grad_in_hook(self):\n        test_model = ModelForTest()\n        x = torch.randn(2, 3)\n        output = test_model(x)\n\n        test_hook = PostForwardHook()\n        add_hook_to_module(test_model, test_hook)\n        output1 = test_model(x)\n        self.assertTrue(torch.allclose(output1, output + 1))\n        self.assertTrue(output1.requires_grad)\n\n        test_hook.no_grad = True\n        output1 = test_model(x)\n        self.assertFalse(output1.requires_grad)\n\n    @require_multi_gpu\n    def test_align_devices_as_model_parallelism(self):\n        model = ModelForTest()\n        # Everything is on CPU\n        self.assertEqual(model.linear1.weight.device, torch.device(\"cpu\"))\n        self.assertEqual(model.batchnorm.weight.device, torch.device(\"cpu\"))\n        self.assertEqual(model.linear2.weight.device, torch.device(\"cpu\"))\n\n        # This will move each submodule on different devices\n        add_hook_to_module(model.linear1, AlignDevicesHook(execution_device=0))\n        add_hook_to_module(model.batchnorm, AlignDevicesHook(execution_device=0))\n        add_hook_to_module(model.linear2, AlignDevicesHook(execution_device=1))\n\n        self.assertEqual(model.linear1.weight.device, torch.device(0))\n        self.assertEqual(model.batchnorm.weight.device, torch.device(0))\n        self.assertEqual(model.batchnorm.running_mean.device, torch.device(0))\n        self.assertEqual(model.linear2.weight.device, torch.device(1))\n\n        # We can still make a forward pass. The input does not need to be on any particular device\n        x = torch.randn(2, 3)\n        output = model(x)\n        self.assertEqual(output.device, torch.device(1))\n\n        # We can add a general hook to put back output on same device as input.\n        add_hook_to_module(model, AlignDevicesHook(io_same_device=True))\n        x = torch.randn(2, 3).to(0)\n        output = model(x)\n        self.assertEqual(output.device, torch.device(0))\n\n    def test_align_devices_as_cpu_offload(self):\n        model = ModelForTest()\n\n        # Everything is on CPU\n        self.assertEqual(model.linear1.weight.device, torch.device(\"cpu\"))\n        self.assertEqual(model.batchnorm.weight.device, torch.device(\"cpu\"))\n        self.assertEqual(model.linear2.weight.device, torch.device(\"cpu\"))\n\n        # This will move each submodule on different devices\n        hook_kwargs = {\"execution_device\": 0 if torch.cuda.is_available() else \"cpu\", \"offload\": True}\n\n        add_hook_to_module(model.linear1, AlignDevicesHook(**hook_kwargs))\n        add_hook_to_module(model.batchnorm, AlignDevicesHook(**hook_kwargs))\n        add_hook_to_module(model.linear2, AlignDevicesHook(**hook_kwargs))\n\n        # Parameters have been offloaded, so on the meta device\n        self.assertEqual(model.linear1.weight.device, torch.device(\"meta\"))\n        self.assertEqual(model.batchnorm.weight.device, torch.device(\"meta\"))\n        self.assertEqual(model.linear2.weight.device, torch.device(\"meta\"))\n        # Buffers are not included in the offload by default, so are on the execution device\n        device = torch.device(hook_kwargs[\"execution_device\"])\n        self.assertEqual(model.batchnorm.running_mean.device, device)\n\n        x = torch.randn(2, 3)\n        output = model(x)\n        self.assertEqual(output.device, device)\n\n        # Removing hooks loads back the weights in the model.\n        remove_hook_from_module(model.linear1)\n        remove_hook_from_module(model.batchnorm)\n        remove_hook_from_module(model.linear2)\n        self.assertEqual(model.linear1.weight.device, torch.device(\"cpu\"))\n        self.assertEqual(model.batchnorm.weight.device, torch.device(\"cpu\"))\n        self.assertEqual(model.linear2.weight.device, torch.device(\"cpu\"))\n\n        # Now test with buffers included in the offload\n        hook_kwargs = {\n            \"execution_device\": 0 if torch.cuda.is_available() else \"cpu\",\n            \"offload\": True,\n            \"offload_buffers\": True,\n        }\n\n        add_hook_to_module(model.linear1, AlignDevicesHook(**hook_kwargs))\n        add_hook_to_module(model.batchnorm, AlignDevicesHook(**hook_kwargs))\n        add_hook_to_module(model.linear2, AlignDevicesHook(**hook_kwargs))\n\n        # Parameters have been offloaded, so on the meta device, buffers included\n        self.assertEqual(model.linear1.weight.device, torch.device(\"meta\"))\n        self.assertEqual(model.batchnorm.weight.device, torch.device(\"meta\"))\n        self.assertEqual(model.linear2.weight.device, torch.device(\"meta\"))\n        self.assertEqual(model.batchnorm.running_mean.device, torch.device(\"meta\"))\n\n        x = torch.randn(2, 3)\n        output = model(x)\n        self.assertEqual(output.device, device)\n\n        # Removing hooks loads back the weights in the model.\n        remove_hook_from_module(model.linear1)\n        remove_hook_from_module(model.batchnorm)\n        remove_hook_from_module(model.linear2)\n        self.assertEqual(model.linear1.weight.device, torch.device(\"cpu\"))\n        self.assertEqual(model.batchnorm.weight.device, torch.device(\"cpu\"))\n        self.assertEqual(model.linear2.weight.device, torch.device(\"cpu\"))\n\n    def test_attach_align_device_hook_as_cpu_offload(self):\n        model = ModelForTest()\n\n        # Everything is on CPU\n        self.assertEqual(model.linear1.weight.device, torch.device(\"cpu\"))\n        self.assertEqual(model.batchnorm.weight.device, torch.device(\"cpu\"))\n        self.assertEqual(model.linear2.weight.device, torch.device(\"cpu\"))\n\n        # This will move each submodule on different devices\n        execution_device = 0 if torch.cuda.is_available() else \"cpu\"\n        attach_align_device_hook(model, execution_device=execution_device, offload=True)\n\n        # Parameters have been offloaded, so on the meta device\n        self.assertEqual(model.linear1.weight.device, torch.device(\"meta\"))\n        self.assertEqual(model.batchnorm.weight.device, torch.device(\"meta\"))\n        self.assertEqual(model.linear2.weight.device, torch.device(\"meta\"))\n        # Buffers are not included in the offload by default, so are on the execution device\n        device = torch.device(execution_device)\n        self.assertEqual(model.batchnorm.running_mean.device, device)\n\n        x = torch.randn(2, 3)\n        output = model(x)\n        self.assertEqual(output.device, device)\n\n        # Removing hooks loads back the weights in the model.\n        remove_hook_from_submodules(model)\n        self.assertEqual(model.linear1.weight.device, torch.device(\"cpu\"))\n        self.assertEqual(model.batchnorm.weight.device, torch.device(\"cpu\"))\n        self.assertEqual(model.linear2.weight.device, torch.device(\"cpu\"))\n\n        # Now test with buffers included in the offload\n        attach_align_device_hook(model, execution_device=execution_device, offload=True, offload_buffers=True)\n\n        # Parameters have been offloaded, so on the meta device, buffers included\n        self.assertEqual(model.linear1.weight.device, torch.device(\"meta\"))\n        self.assertEqual(model.batchnorm.weight.device, torch.device(\"meta\"))\n        self.assertEqual(model.linear2.weight.device, torch.device(\"meta\"))\n        self.assertEqual(model.batchnorm.running_mean.device, torch.device(\"meta\"))\n\n        x = torch.randn(2, 3)\n        output = model(x)\n        self.assertEqual(output.device, device)\n\n        # Removing hooks loads back the weights in the model.\n        remove_hook_from_submodules(model)\n        self.assertEqual(model.linear1.weight.device, torch.device(\"cpu\"))\n        self.assertEqual(model.batchnorm.weight.device, torch.device(\"cpu\"))\n        self.assertEqual(model.linear2.weight.device, torch.device(\"cpu\"))\n\n    def test_attach_align_device_hook_as_cpu_offload_with_weight_map(self):\n        model = ModelForTest()\n\n        # Everything is on CPU\n        self.assertEqual(model.linear1.weight.device, torch.device(\"cpu\"))\n        self.assertEqual(model.batchnorm.weight.device, torch.device(\"cpu\"))\n        self.assertEqual(model.linear2.weight.device, torch.device(\"cpu\"))\n\n        # This will move each submodule on different devices\n        execution_device = 0 if torch.cuda.is_available() else \"cpu\"\n        attach_align_device_hook(\n            model, execution_device=execution_device, offload=True, weights_map=model.state_dict()\n        )\n\n        # Parameters have been offloaded, so on the meta device\n        self.assertEqual(model.linear1.weight.device, torch.device(\"meta\"))\n        self.assertEqual(model.batchnorm.weight.device, torch.device(\"meta\"))\n        self.assertEqual(model.linear2.weight.device, torch.device(\"meta\"))\n        # Buffers are not included in the offload by default, so are on the execution device\n        device = torch.device(execution_device)\n        self.assertEqual(model.batchnorm.running_mean.device, device)\n\n        x = torch.randn(2, 3)\n        output = model(x)\n        self.assertEqual(output.device, device)\n\n        # Removing hooks loads back the weights in the model.\n        remove_hook_from_submodules(model)\n        self.assertEqual(model.linear1.weight.device, torch.device(\"cpu\"))\n        self.assertEqual(model.batchnorm.weight.device, torch.device(\"cpu\"))\n        self.assertEqual(model.linear2.weight.device, torch.device(\"cpu\"))\n\n        # Now test with buffers included in the offload\n        attach_align_device_hook(\n            model,\n            execution_device=execution_device,\n            offload=True,\n            weights_map=model.state_dict(),\n            offload_buffers=True,\n        )\n\n        # Parameters have been offloaded, so on the meta device, buffers included\n        self.assertEqual(model.linear1.weight.device, torch.device(\"meta\"))\n        self.assertEqual(model.batchnorm.weight.device, torch.device(\"meta\"))\n        self.assertEqual(model.linear2.weight.device, torch.device(\"meta\"))\n        self.assertEqual(model.batchnorm.running_mean.device, torch.device(\"meta\"))\n\n        x = torch.randn(2, 3)\n        output = model(x)\n        self.assertEqual(output.device, device)\n\n        # Removing hooks loads back the weights in the model.\n        remove_hook_from_submodules(model)\n        self.assertEqual(model.linear1.weight.device, torch.device(\"cpu\"))\n        self.assertEqual(model.batchnorm.weight.device, torch.device(\"cpu\"))\n        self.assertEqual(model.linear2.weight.device, torch.device(\"cpu\"))\n", "# Copyright 2023 The HuggingFace Team. All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport gc\nimport tempfile\nimport unittest\n\nimport torch\nimport torch.nn as nn\n\nfrom accelerate import Accelerator, init_empty_weights\nfrom accelerate.test_utils import require_bnb, require_cuda, require_huggingface_suite, require_multi_gpu, slow\nfrom accelerate.utils.bnb import load_and_quantize_model\nfrom accelerate.utils.dataclasses import BnbQuantizationConfig\n\n\nclass BitsAndBytesConfigIntegration(unittest.TestCase):\n    def test_BnbQuantizationConfig(self):\n        with self.assertRaises(ValueError):\n            BnbQuantizationConfig(load_in_8bit=True, load_in_4bit=True)\n\n\n@slow\n@require_cuda\n@require_bnb\n@require_huggingface_suite\nclass MixedInt8EmptyModelTest(unittest.TestCase):\n    # We keep the constants inside the init function and model loading inside setUp function\n\n    # We need to test on relatively large models (aka >1b parameters otherwise the quantiztion may not work as expected)\n    # Therefore here we use only bloom-1b3 to test our module\n    model_name = \"marcsun13/bloom-1b7_with_lm_head\"\n\n    # Constant values\n    # This was obtained on a Quadro RTX 8000 so the number might slightly change\n    EXPECTED_RELATIVE_DIFFERENCE = 1.540025\n\n    input_text = \"Hello my name is\"\n    EXPECTED_OUTPUT = \"Hello my name is John.\\nI am a friend of the family.\\n\"\n    MAX_NEW_TOKENS = 10\n\n    def setUp(self):\n        \"\"\"\n        Setup quantized model from empty model\n        \"\"\"\n        from huggingface_hub import hf_hub_download\n        from transformers import AutoConfig, AutoModelForCausalLM, AutoTokenizer\n\n        # Models and tokenizer\n        self.model_fp16 = AutoModelForCausalLM.from_pretrained(\n            self.model_name, torch_dtype=torch.float16, device_map=\"auto\"\n        )\n\n        # create model on meta device\n        with init_empty_weights():\n            self.model_8bit = AutoModelForCausalLM.from_config(AutoConfig.from_pretrained(self.model_name))\n        self.model_8bit.tie_weights()\n\n        self.weights_location = hf_hub_download(self.model_name, \"pytorch_model.bin\")\n        self.bnb_quantization_config = BnbQuantizationConfig(load_in_8bit=True)\n\n        self.model_8bit = load_and_quantize_model(\n            self.model_8bit,\n            self.bnb_quantization_config,\n            weights_location=self.weights_location,\n            device_map={\"\": 0},\n            no_split_module_classes=[\"BloomBlock\"],\n        )\n\n        self.tokenizer = AutoTokenizer.from_pretrained(\"bigscience/bloom-1b7\")\n        self.accelerate = Accelerator()\n\n    def tearDown(self):\n        r\"\"\"\n        TearDown function needs to be called at the end of each test to free the GPU memory and cache, also to\n        avoid unexpected behaviors. Please see: https://discuss.pytorch.org/t/how-can-we-release-gpu-memory-cache/14530/27\n        \"\"\"\n        del self.model_fp16\n        del self.model_8bit\n\n        gc.collect()\n        torch.cuda.empty_cache()\n\n    def test_memory_footprint(self):\n        r\"\"\"\n        A simple test to check if the model conversion has been done correctly by checking on the\n        memory footprint of the converted model and the class type of the linear layers of the converted models\n        \"\"\"\n        from bitsandbytes.nn import Int8Params\n\n        mem_fp16 = self.model_fp16.get_memory_footprint()\n        mem_8bit = self.model_8bit.get_memory_footprint()\n\n        self.assertAlmostEqual(mem_fp16 / mem_8bit, self.EXPECTED_RELATIVE_DIFFERENCE)\n        self.assertTrue(self.model_8bit.transformer.h[0].mlp.dense_4h_to_h.weight.__class__ == Int8Params)\n\n    def test_linear_are_8bit(self):\n        r\"\"\"\n        A simple test to check if the model conversion has been done correctly by checking on the\n        memory footprint of the converted model and the class type of the linear layers of the converted models\n        \"\"\"\n\n        self.model_fp16.get_memory_footprint()\n        self.model_8bit.get_memory_footprint()\n\n        for name, module in self.model_8bit.named_modules():\n            if isinstance(module, torch.nn.Linear):\n                modules_not_converted = (\n                    self.bnb_quantization_config.keep_in_fp32_modules + self.bnb_quantization_config.skip_modules\n                )\n                if name not in modules_not_converted:\n                    self.assertTrue(module.weight.dtype == torch.int8)\n\n    def test_llm_skip(self):\n        r\"\"\"\n        A simple test to check if `llm_int8_skip_modules` works as expected\n        \"\"\"\n        import bitsandbytes as bnb\n        from transformers import AutoConfig, AutoModelForCausalLM\n\n        bnb_quantization_config = BnbQuantizationConfig(\n            load_in_8bit=True, skip_modules=[\"lm_head\", \"transformer.word_embeddings\"]\n        )\n\n        with init_empty_weights():\n            model = AutoModelForCausalLM.from_config(AutoConfig.from_pretrained(self.model_name))\n\n        model.tie_weights()\n        model = load_and_quantize_model(\n            model,\n            bnb_quantization_config,\n            weights_location=self.weights_location,\n            device_map=\"auto\",\n            no_split_module_classes=[\"BloomBlock\"],\n        )\n\n        self.assertTrue(model.transformer.h[1].mlp.dense_4h_to_h.weight.dtype == torch.int8)\n        self.assertTrue(isinstance(model.transformer.h[1].mlp.dense_4h_to_h, bnb.nn.Linear8bitLt))\n        self.assertTrue(isinstance(model.lm_head, nn.Linear))\n        self.assertTrue(model.lm_head.weight.dtype != torch.int8)\n\n    def check_inference_correctness(self, model):\n        r\"\"\"\n        Test the generation quality of the quantized model and see that we are matching the expected output.\n        Given that we are operating on small numbers + the testing model is relatively small, we might not get\n        the same output across GPUs. So we'll generate few tokens (5-10) and check their output.\n        \"\"\"\n        # Check that inference pass works on the model\n        encoded_input = self.tokenizer(self.input_text, return_tensors=\"pt\")\n\n        # Check the exactness of the results\n        output_parallel = model.generate(input_ids=encoded_input[\"input_ids\"].to(0), max_new_tokens=10)\n\n        # Get the generation\n        output_text = self.tokenizer.decode(output_parallel[0], skip_special_tokens=True)\n        self.assertEqual(output_text, self.EXPECTED_OUTPUT)\n\n    def test_generate_quality(self):\n        self.check_inference_correctness(self.model_8bit)\n\n    def test_fp32_8bit_conversion(self):\n        r\"\"\"\n        Test whether it is possible to mix both `8bit` and `fp32` weights when using `keep_in_fp32_modules` correctly.\n        \"\"\"\n        from transformers import AutoConfig, AutoModelForCausalLM\n\n        bnb_quantization_config = BnbQuantizationConfig(load_in_8bit=True, keep_in_fp32_modules=[\"lm_head\"])\n\n        with init_empty_weights():\n            model = AutoModelForCausalLM.from_config(AutoConfig.from_pretrained(self.model_name))\n\n        model.tie_weights()\n        model = load_and_quantize_model(\n            model,\n            bnb_quantization_config,\n            weights_location=self.weights_location,\n            device_map=\"auto\",\n            no_split_module_classes=[\"BloomBlock\"],\n        )\n        self.assertTrue(model.lm_head.weight.dtype == torch.float32)\n\n    @require_multi_gpu\n    def test_cpu_gpu_loading_custom_device_map(self):\n        from bitsandbytes.nn import Int8Params\n        from transformers import AutoConfig, AutoModelForCausalLM\n\n        r\"\"\"\n        A test to check is dispatching a model on cpu & gpu works correctly using a custom `device_map`.\n        \"\"\"\n        device_map = {\n            \"transformer.word_embeddings\": \"cpu\",\n            \"transformer.word_embeddings_layernorm\": 0,\n            \"lm_head\": \"cpu\",\n            \"transformer.h.0\": \"cpu\",\n            \"transformer.h.1\": \"cpu\",\n            \"transformer.h.2\": \"cpu\",\n            \"transformer.h.3\": 0,\n            \"transformer.h.4\": 0,\n            \"transformer.h.5\": 0,\n            \"transformer.h.6\": 0,\n            \"transformer.h.7\": 0,\n            \"transformer.h.8\": 0,\n            \"transformer.h.9\": 1,\n            \"transformer.h.10\": 0,\n            \"transformer.h.11\": 1,\n            \"transformer.h.12\": 0,\n            \"transformer.h.13\": 0,\n            \"transformer.h.14\": 1,\n            \"transformer.h.15\": 0,\n            \"transformer.h.16\": 0,\n            \"transformer.h.17\": 1,\n            \"transformer.h.18\": 1,\n            \"transformer.h.19\": 0,\n            \"transformer.h.20\": 1,\n            \"transformer.h.21\": 1,\n            \"transformer.h.22\": 0,\n            \"transformer.h.23\": 0,\n            \"transformer.ln_f\": 1,\n        }\n        bnb_quantization_config = BnbQuantizationConfig(load_in_8bit=True)\n\n        with init_empty_weights():\n            model_8bit = AutoModelForCausalLM.from_config(AutoConfig.from_pretrained(self.model_name))\n\n        model_8bit.tie_weights()\n        model_8bit = load_and_quantize_model(\n            model_8bit,\n            bnb_quantization_config,\n            weights_location=self.weights_location,\n            device_map=device_map,\n            no_split_module_classes=[\"BloomBlock\"],\n        )\n        self.assertTrue(model_8bit.transformer.h[0].mlp.dense_4h_to_h.weight.__class__ == Int8Params)\n        self.assertTrue(model_8bit.transformer.h[1].mlp.dense_4h_to_h.weight.__class__ == Int8Params)\n        self.check_inference_correctness(model_8bit)\n\n    @require_multi_gpu\n    def test_cpu_gpu_loading_custom_device_map_offload_state_dict(self):\n        from bitsandbytes.nn import Int8Params\n        from transformers import AutoConfig, AutoModelForCausalLM\n\n        r\"\"\"\n        A test to check is dispatching a model on cpu & gpu works correctly using a custom `device_map` and offload_state_dict=True.\n        \"\"\"\n        device_map = {\n            \"transformer.word_embeddings\": \"cpu\",\n            \"transformer.word_embeddings_layernorm\": 0,\n            \"lm_head\": \"cpu\",\n            \"transformer.h.0\": \"cpu\",\n            \"transformer.h.1\": \"cpu\",\n            \"transformer.h.2\": \"cpu\",\n            \"transformer.h.3\": 0,\n            \"transformer.h.4\": 0,\n            \"transformer.h.5\": 0,\n            \"transformer.h.6\": 0,\n            \"transformer.h.7\": 0,\n            \"transformer.h.8\": 0,\n            \"transformer.h.9\": 1,\n            \"transformer.h.10\": 0,\n            \"transformer.h.11\": 1,\n            \"transformer.h.12\": 0,\n            \"transformer.h.13\": 0,\n            \"transformer.h.14\": 1,\n            \"transformer.h.15\": 0,\n            \"transformer.h.16\": 0,\n            \"transformer.h.17\": 1,\n            \"transformer.h.18\": 1,\n            \"transformer.h.19\": 0,\n            \"transformer.h.20\": 1,\n            \"transformer.h.21\": 1,\n            \"transformer.h.22\": 0,\n            \"transformer.h.23\": 0,\n            \"transformer.ln_f\": 1,\n        }\n\n        bnb_quantization_config = BnbQuantizationConfig(load_in_8bit=True)\n\n        with init_empty_weights():\n            model_8bit = AutoModelForCausalLM.from_config(AutoConfig.from_pretrained(self.model_name))\n\n        model_8bit.tie_weights()\n        model_8bit = load_and_quantize_model(\n            model_8bit,\n            bnb_quantization_config,\n            weights_location=self.weights_location,\n            device_map=device_map,\n            no_split_module_classes=[\"BloomBlock\"],\n            offload_state_dict=True,\n        )\n        self.assertTrue(model_8bit.transformer.h[0].mlp.dense_4h_to_h.weight.__class__ == Int8Params)\n        self.assertTrue(model_8bit.transformer.h[1].mlp.dense_4h_to_h.weight.__class__ == Int8Params)\n        self.check_inference_correctness(model_8bit)\n\n    @require_multi_gpu\n    def test_cpu_gpu_disk_loading_custom_device_map_kwargs(self):\n        from bitsandbytes.nn import Int8Params\n        from transformers import AutoConfig, AutoModelForCausalLM\n\n        r\"\"\"\n        A test to check is dispatching a model on cpu & gpu works correctly using a custom `device_map`.\n        This time we also add `disk` on the device_map - using the kwargs directly instead of the quantization config\n        \"\"\"\n        device_map = {\n            \"transformer.word_embeddings\": \"cpu\",\n            \"transformer.word_embeddings_layernorm\": 0,\n            \"lm_head\": \"cpu\",\n            \"transformer.h.0\": \"cpu\",\n            \"transformer.h.1\": \"cpu\",\n            \"transformer.h.2\": \"cpu\",\n            \"transformer.h.3\": \"disk\",\n            \"transformer.h.4\": \"disk\",\n            \"transformer.h.5\": \"disk\",\n            \"transformer.h.6\": 0,\n            \"transformer.h.7\": 0,\n            \"transformer.h.8\": 0,\n            \"transformer.h.9\": 1,\n            \"transformer.h.10\": 0,\n            \"transformer.h.11\": 1,\n            \"transformer.h.12\": 0,\n            \"transformer.h.13\": 0,\n            \"transformer.h.14\": 1,\n            \"transformer.h.15\": 0,\n            \"transformer.h.16\": 0,\n            \"transformer.h.17\": 1,\n            \"transformer.h.18\": 1,\n            \"transformer.h.19\": 0,\n            \"transformer.h.20\": 1,\n            \"transformer.h.21\": 1,\n            \"transformer.h.22\": 0,\n            \"transformer.h.23\": 0,\n            \"transformer.ln_f\": 1,\n        }\n        bnb_quantization_config = BnbQuantizationConfig(load_in_8bit=True)\n\n        with init_empty_weights():\n            model_8bit = AutoModelForCausalLM.from_config(AutoConfig.from_pretrained(self.model_name))\n        model_8bit.tie_weights()\n\n        with tempfile.TemporaryDirectory() as tmpdirname:\n            model_8bit = load_and_quantize_model(\n                model_8bit,\n                bnb_quantization_config,\n                weights_location=self.weights_location,\n                device_map=device_map,\n                no_split_module_classes=[\"BloomBlock\"],\n                offload_folder=tmpdirname,\n                offload_state_dict=True,\n            )\n            self.assertTrue(model_8bit.transformer.h[4].mlp.dense_4h_to_h.weight.__class__ == Int8Params)\n            self.assertTrue(model_8bit.transformer.h[5].mlp.dense_4h_to_h.weight.__class__ == Int8Params)\n            self.check_inference_correctness(model_8bit)\n\n    def test_int8_serialization(self):\n        r\"\"\"\n        Test whether it is possible to serialize a model in 8-bit.\n        \"\"\"\n        from bitsandbytes.nn import Int8Params\n        from transformers import AutoConfig, AutoModelForCausalLM\n\n        with tempfile.TemporaryDirectory() as tmpdirname:\n            # saving state dict for now but will save config and other in the future\n            self.accelerate.save_model(self.model_8bit, tmpdirname)\n\n            with init_empty_weights():\n                # let's suppose that we can get the right config\n                model_8bit_from_saved = AutoModelForCausalLM.from_config(AutoConfig.from_pretrained(self.model_name))\n            model_8bit_from_saved.tie_weights()\n\n            bnb_quantization_config = BnbQuantizationConfig(load_in_8bit=True)\n\n            model_8bit_from_saved = load_and_quantize_model(\n                model_8bit_from_saved,\n                bnb_quantization_config,\n                weights_location=tmpdirname,\n                device_map=\"auto\",\n                no_split_module_classes=[\"BloomBlock\"],\n            )\n\n            self.assertTrue(model_8bit_from_saved.transformer.h[0].mlp.dense_4h_to_h.weight.__class__ == Int8Params)\n            self.assertTrue(hasattr(model_8bit_from_saved.transformer.h[0].mlp.dense_4h_to_h.weight, \"SCB\"))\n            self.assertTrue(hasattr(model_8bit_from_saved.transformer.h[0].mlp.dense_4h_to_h.weight, \"CB\"))\n\n            self.check_inference_correctness(model_8bit_from_saved)\n\n    @require_multi_gpu\n    def test_int8_serialization_offload(self):\n        r\"\"\"\n        Test whether it is possible to serialize a model in 8-bit and offload weights to cpu/disk\n        \"\"\"\n\n        from bitsandbytes.nn import Int8Params\n        from transformers import AutoConfig, AutoModelForCausalLM\n\n        with tempfile.TemporaryDirectory() as tmpdirname:\n            # saving state dict for now but will save config and other in the future\n            self.accelerate.save_model(self.model_8bit, tmpdirname)\n\n            with init_empty_weights():\n                # let's suppose that we can get the right config\n                model_8bit_from_saved = AutoModelForCausalLM.from_config(AutoConfig.from_pretrained(self.model_name))\n            model_8bit_from_saved.tie_weights()\n            bnb_quantization_config = BnbQuantizationConfig(load_in_8bit=True)\n            device_map = {\n                \"transformer.word_embeddings\": \"cpu\",\n                \"transformer.word_embeddings_layernorm\": 0,\n                \"lm_head\": \"cpu\",\n                \"transformer.h.0\": \"cpu\",\n                \"transformer.h.1\": \"cpu\",\n                \"transformer.h.2\": \"cpu\",\n                \"transformer.h.3\": \"disk\",\n                \"transformer.h.4\": \"disk\",\n                \"transformer.h.5\": \"disk\",\n                \"transformer.h.6\": 0,\n                \"transformer.h.7\": 0,\n                \"transformer.h.8\": 0,\n                \"transformer.h.9\": 1,\n                \"transformer.h.10\": 0,\n                \"transformer.h.11\": 1,\n                \"transformer.h.12\": 0,\n                \"transformer.h.13\": 0,\n                \"transformer.h.14\": 1,\n                \"transformer.h.15\": 0,\n                \"transformer.h.16\": 0,\n                \"transformer.h.17\": 1,\n                \"transformer.h.18\": 1,\n                \"transformer.h.19\": 0,\n                \"transformer.h.20\": 1,\n                \"transformer.h.21\": 1,\n                \"transformer.h.22\": 0,\n                \"transformer.h.23\": 0,\n                \"transformer.ln_f\": 1,\n            }\n            model_8bit_from_saved = load_and_quantize_model(\n                model_8bit_from_saved,\n                bnb_quantization_config,\n                weights_location=tmpdirname + \"/pytorch_model.bin\",\n                device_map=device_map,\n                no_split_module_classes=[\"BloomBlock\"],\n                offload_folder=tmpdirname + \"/tmp\",\n                offload_state_dict=True,\n            )\n\n            self.assertTrue(model_8bit_from_saved.transformer.h[4].mlp.dense_4h_to_h.weight.__class__ == Int8Params)\n            self.assertTrue(model_8bit_from_saved.transformer.h[5].mlp.dense_4h_to_h.weight.__class__ == Int8Params)\n            self.check_inference_correctness(model_8bit_from_saved)\n\n    def test_int8_serialization_shard(self):\n        r\"\"\"\n        Test whether it is possible to serialize a model in 8-bit.\n        \"\"\"\n        from bitsandbytes.nn import Int8Params\n        from transformers import AutoConfig, AutoModelForCausalLM\n\n        with tempfile.TemporaryDirectory() as tmpdirname:\n            # saving state dict for now but will save config and other in the future\n            self.accelerate.save_model(self.model_8bit, tmpdirname, max_shard_size=\"1GB\")\n\n            with init_empty_weights():\n                # let's suppose that we can get the right config\n                model_8bit_from_saved = AutoModelForCausalLM.from_config(AutoConfig.from_pretrained(self.model_name))\n\n            model_8bit_from_saved.tie_weights()\n\n            bnb_quantization_config = BnbQuantizationConfig(load_in_8bit=True)\n\n            model_8bit_from_saved = load_and_quantize_model(\n                model_8bit_from_saved,\n                bnb_quantization_config,\n                weights_location=tmpdirname,\n                device_map=\"auto\",\n                no_split_module_classes=[\"BloomBlock\"],\n            )\n\n            self.assertTrue(model_8bit_from_saved.transformer.h[0].mlp.dense_4h_to_h.weight.__class__ == Int8Params)\n            self.assertTrue(hasattr(model_8bit_from_saved.transformer.h[0].mlp.dense_4h_to_h.weight, \"SCB\"))\n            self.assertTrue(hasattr(model_8bit_from_saved.transformer.h[0].mlp.dense_4h_to_h.weight, \"CB\"))\n\n            self.check_inference_correctness(model_8bit_from_saved)\n\n\n@slow\n@require_cuda\n@require_bnb\n@require_huggingface_suite\nclass MixedInt8LoaddedModelTest(unittest.TestCase):\n    # We keep the constants inside the init function and model loading inside setUp function\n\n    # We need to test on relatively large models (aka >1b parameters otherwise the quantiztion may not work as expected)\n    # Therefore here we use only bloom-1b3 to test our module\n    model_name = \"marcsun13/bloom-1b7_with_lm_head\"\n\n    # Constant values\n    # This was obtained on a Quadro RTX 8000 so the number might slightly change\n    EXPECTED_RELATIVE_DIFFERENCE = 1.540025\n\n    input_text = \"Hello my name is\"\n    EXPECTED_OUTPUT = \"Hello my name is John.\\nI am a friend of the family.\\n\"\n    MAX_NEW_TOKENS = 10\n\n    def setUp(self):\n        \"\"\"\n        Setup quantized model from loaded model\n        \"\"\"\n        from transformers import AutoModelForCausalLM, AutoTokenizer\n\n        # Models and tokenizer\n        self.model_fp16 = AutoModelForCausalLM.from_pretrained(\n            self.model_name, torch_dtype=torch.float16, device_map=\"auto\"\n        )\n\n        self.bnb_quantization_config = BnbQuantizationConfig(load_in_8bit=True)\n\n        self.model_8bit = AutoModelForCausalLM.from_pretrained(self.model_name, torch_dtype=torch.float16)\n        self.model_8bit = load_and_quantize_model(self.model_8bit, self.bnb_quantization_config)\n\n        self.tokenizer = AutoTokenizer.from_pretrained(\"bigscience/bloom-1b7\")\n\n    def tearDown(self):\n        r\"\"\"\n        TearDown function needs to be called at the end of each test to free the GPU memory and cache, also to\n        avoid unexpected behaviors. Please see: https://discuss.pytorch.org/t/how-can-we-release-gpu-memory-cache/14530/27\n        \"\"\"\n        del self.model_fp16\n        del self.model_8bit\n\n        gc.collect()\n        torch.cuda.empty_cache()\n\n    def test_memory_footprint(self):\n        r\"\"\"\n        A simple test to check if the model conversion has been done correctly by checking on the\n        memory footprint of the converted model and the class type of the linear layers of the converted models\n        \"\"\"\n        from bitsandbytes.nn import Int8Params\n\n        mem_fp16 = self.model_fp16.get_memory_footprint()\n        mem_8bit = self.model_8bit.get_memory_footprint()\n\n        self.assertAlmostEqual(mem_fp16 / mem_8bit, self.EXPECTED_RELATIVE_DIFFERENCE)\n        self.assertTrue(self.model_8bit.transformer.h[0].mlp.dense_4h_to_h.weight.__class__ == Int8Params)\n\n    def test_linear_are_8bit(self):\n        r\"\"\"\n        A simple test to check if the model conversion has been done correctly by checking on the\n        memory footprint of the converted model and the class type of the linear layers of the converted models\n        \"\"\"\n\n        self.model_fp16.get_memory_footprint()\n        self.model_8bit.get_memory_footprint()\n\n        for name, module in self.model_8bit.named_modules():\n            if isinstance(module, torch.nn.Linear):\n                modules_not_converted = (\n                    self.bnb_quantization_config.keep_in_fp32_modules + self.bnb_quantization_config.skip_modules\n                )\n                if name not in modules_not_converted:\n                    self.assertTrue(module.weight.dtype == torch.int8)\n\n    def test_generate_quality(self):\n        r\"\"\"\n        Test the generation quality of the quantized model and see that we are matching the expected output.\n        Given that we are operating on small numbers + the testing model is relatively small, we might not get\n        the same output across GPUs. So we'll generate few tokens (5-10) and check their output.\n        \"\"\"\n        encoded_input = self.tokenizer(self.input_text, return_tensors=\"pt\")\n\n        output_sequences = self.model_8bit.generate(\n            input_ids=encoded_input[\"input_ids\"].to(self.model_8bit.device), max_new_tokens=10\n        )\n\n        self.assertEqual(self.tokenizer.decode(output_sequences[0], skip_special_tokens=True), self.EXPECTED_OUTPUT)\n\n    def test_fp32_8bit_conversion(self):\n        r\"\"\"\n        Test whether it is possible to mix both `8bit` and `fp32` weights when using `keep_in_fp32_modules` correctly.\n        \"\"\"\n        from transformers import AutoModelForCausalLM\n\n        bnb_quantization_config = BnbQuantizationConfig(load_in_8bit=True, keep_in_fp32_modules=[\"lm_head\"])\n\n        model = AutoModelForCausalLM.from_pretrained(self.model_name, torch_dtype=torch.float16)\n        model = load_and_quantize_model(model, bnb_quantization_config)\n        self.assertTrue(model.lm_head.weight.dtype == torch.float32)\n\n\n@slow\n@require_cuda\n@require_bnb\n@require_huggingface_suite\nclass Bnb4BitEmptyModelTest(unittest.TestCase):\n    # We keep the constants inside the init function and model loading inside setUp function\n\n    # We need to test on relatively large models (aka >1b parameters otherwise the quantiztion may not work as expected)\n    # Therefore here we use only bloom-1b3 to test our module\n    model_name = \"marcsun13/bloom-1b7_with_lm_head\"\n\n    # Constant values\n    # This was obtained on a RTX Titan so the number might slightly change\n    EXPECTED_RELATIVE_DIFFERENCE = 2.109659552692574\n\n    input_text = \"Hello my name is\"\n    EXPECTED_OUTPUTS = set()\n    EXPECTED_OUTPUTS.add(\"Hello my name is John and I am a professional photographer. I\")\n    EXPECTED_OUTPUTS.add(\"Hello my name is John.\\nI am a friend of your father.\\n\")\n    MAX_NEW_TOKENS = 10\n\n    def setUp(self):\n        from huggingface_hub import hf_hub_download\n        from transformers import AutoConfig, AutoModelForCausalLM, AutoTokenizer\n\n        super().setUp()\n\n        # Models and tokenizer\n        self.model_fp16 = AutoModelForCausalLM.from_pretrained(\n            self.model_name, torch_dtype=torch.float16, device_map=\"auto\"\n        )\n\n        # create model on meta device\n        with init_empty_weights():\n            self.model_4bit = AutoModelForCausalLM.from_config(AutoConfig.from_pretrained(self.model_name))\n\n        self.model_4bit.tie_weights()\n        self.weights_location = hf_hub_download(self.model_name, \"pytorch_model.bin\")\n        self.bnb_quantization_config = BnbQuantizationConfig(load_in_4bit=True)\n\n        self.model_4bit = load_and_quantize_model(\n            self.model_4bit,\n            self.bnb_quantization_config,\n            weights_location=self.weights_location,\n            device_map={\"\": 0},\n            no_split_module_classes=[\"BloomBlock\"],\n        )\n\n        self.tokenizer = AutoTokenizer.from_pretrained(\"bigscience/bloom-1b7\")\n\n    def tearDown(self):\n        \"\"\"\n        TearDown function needs to be called at the end of each test to free the GPU memory and cache, also to\n        avoid unexpected behaviors. Please see: https://discuss.pytorch.org/t/how-can-we-release-gpu-memory-cache/14530/27\n        \"\"\"\n        super().tearDown()\n        del self.model_fp16\n        del self.model_4bit\n\n        gc.collect()\n        torch.cuda.empty_cache()\n\n    def test_memory_footprint(self):\n        r\"\"\"\n        A simple test to check if the model conversion has been done correctly by checking on the\n        memory footprint of the converted model and the class type of the linear layers of the converted models\n        \"\"\"\n        from bitsandbytes.nn import Params4bit\n\n        mem_fp16 = self.model_fp16.get_memory_footprint()\n        mem_4bit = self.model_4bit.get_memory_footprint()\n\n        self.assertAlmostEqual(mem_fp16 / mem_4bit, self.EXPECTED_RELATIVE_DIFFERENCE)\n        self.assertTrue(self.model_4bit.transformer.h[0].mlp.dense_4h_to_h.weight.__class__ == Params4bit)\n\n    def check_inference_correctness(self, model):\n        r\"\"\"\n        Test the generation quality of the quantized model and see that we are matching the expected output.\n        Given that we are operating on small numbers + the testing model is relatively small, we might not get\n        the same output across GPUs. So we'll generate few tokens (5-10) and check their output.\n        \"\"\"\n        # Check that inference pass works on the model\n        encoded_input = self.tokenizer(self.input_text, return_tensors=\"pt\")\n\n        # Check the exactness of the results\n        output_sequences = model.generate(input_ids=encoded_input[\"input_ids\"].to(0), max_new_tokens=10)\n\n        self.assertIn(self.tokenizer.decode(output_sequences[0], skip_special_tokens=True), self.EXPECTED_OUTPUTS)\n\n    def test_generate_quality(self):\n        self.check_inference_correctness(self.model_4bit)\n\n    def test_linear_are_4bit(self):\n        r\"\"\"\n        A simple test to check if the model conversion has been done correctly by checking on the\n        memory footprint of the converted model and the class type of the linear layers of the converted models\n        \"\"\"\n\n        self.model_fp16.get_memory_footprint()\n        self.model_4bit.get_memory_footprint()\n\n        for name, module in self.model_4bit.named_modules():\n            if isinstance(module, torch.nn.Linear):\n                if (\n                    name\n                    not in self.bnb_quantization_config.keep_in_fp32_modules\n                    + self.bnb_quantization_config.skip_modules\n                ):\n                    # 4-bit parameters are packed in uint8 variables\n                    self.assertTrue(module.weight.dtype == torch.uint8)\n\n    def test_fp32_4bit_conversion(self):\n        r\"\"\"\n        Test whether it is possible to mix both `4bit` and `fp32` weights when using `keep_in_fp32_modules` correctly.\n        \"\"\"\n        from transformers import AutoConfig, AutoModelForCausalLM\n\n        bnb_quantization_config = BnbQuantizationConfig(load_in_4bit=True, keep_in_fp32_modules=[\"lm_head\"])\n\n        with init_empty_weights():\n            model = AutoModelForCausalLM.from_config(AutoConfig.from_pretrained(self.model_name))\n\n        model.tie_weights()\n        model = load_and_quantize_model(\n            model,\n            bnb_quantization_config,\n            weights_location=self.weights_location,\n            device_map=\"auto\",\n            no_split_module_classes=[\"BloomBlock\"],\n        )\n        self.assertTrue(model.lm_head.weight.dtype == torch.float32)\n\n    @require_multi_gpu\n    def test_cpu_gpu_loading_random_device_map(self):\n        from transformers import AutoConfig, AutoModelForCausalLM\n\n        r\"\"\"\n        A test to check is dispatching a model on cpu & gpu works correctly using a random `device_map`.\n        \"\"\"\n        device_map = {\n            \"transformer.word_embeddings\": \"cpu\",\n            \"transformer.word_embeddings_layernorm\": 0,\n            \"lm_head\": \"cpu\",\n            \"transformer.h.0\": 0,\n            \"transformer.h.1\": 0,\n            \"transformer.h.2\": 0,\n            \"transformer.h.3\": 0,\n            \"transformer.h.4\": 0,\n            \"transformer.h.5\": 0,\n            \"transformer.h.6\": 0,\n            \"transformer.h.7\": 0,\n            \"transformer.h.8\": 0,\n            \"transformer.h.9\": 1,\n            \"transformer.h.10\": 0,\n            \"transformer.h.11\": 1,\n            \"transformer.h.12\": 0,\n            \"transformer.h.13\": 0,\n            \"transformer.h.14\": 1,\n            \"transformer.h.15\": 0,\n            \"transformer.h.16\": 0,\n            \"transformer.h.17\": 1,\n            \"transformer.h.18\": 1,\n            \"transformer.h.19\": 0,\n            \"transformer.h.20\": 1,\n            \"transformer.h.21\": 1,\n            \"transformer.h.22\": 0,\n            \"transformer.h.23\": 0,\n            \"transformer.ln_f\": 1,\n        }\n\n        bnb_quantization_config = BnbQuantizationConfig(load_in_4bit=True)\n\n        with init_empty_weights():\n            model_4bit = AutoModelForCausalLM.from_config(AutoConfig.from_pretrained(self.model_name))\n\n        model_4bit.tie_weights()\n        model_4bit = load_and_quantize_model(\n            model_4bit,\n            bnb_quantization_config,\n            weights_location=self.weights_location,\n            device_map=device_map,\n            no_split_module_classes=[\"BloomBlock\"],\n        )\n        self.check_inference_correctness(model_4bit)\n\n    @require_multi_gpu\n    def test_cpu_gpu_loading_custom_device_map(self):\n        from transformers import AutoConfig, AutoModelForCausalLM\n\n        r\"\"\"\n        A test to check is dispatching a model on cpu & gpu works correctly using a random `device_map`.\n        \"\"\"\n        device_map = {\n            \"transformer.word_embeddings\": \"cpu\",\n            \"transformer.word_embeddings_layernorm\": \"cpu\",\n            \"lm_head\": \"cpu\",\n            \"transformer.h\": 0,\n            \"transformer.ln_f\": 1,\n        }\n\n        bnb_quantization_config = BnbQuantizationConfig(load_in_4bit=True)\n\n        with init_empty_weights():\n            model_4bit = AutoModelForCausalLM.from_config(AutoConfig.from_pretrained(self.model_name))\n\n        model_4bit.tie_weights()\n        model_4bit = load_and_quantize_model(\n            model_4bit,\n            bnb_quantization_config,\n            weights_location=self.weights_location,\n            device_map=device_map,\n            no_split_module_classes=[\"BloomBlock\"],\n        )\n        self.check_inference_correctness(model_4bit)\n\n    @require_multi_gpu\n    def test_cpu_gpu_disk_loading_custom_device_map_kwargs(self):\n        from transformers import AutoConfig, AutoModelForCausalLM\n\n        r\"\"\"\n        A test to check is dispatching a model on cpu & gpu works correctly using a custom `device_map`.\n        This time we also add `disk` on the device_map - using the kwargs directly instead of the quantization config\n        \"\"\"\n        device_map = {\n            \"transformer.word_embeddings\": 0,\n            \"transformer.word_embeddings_layernorm\": \"disk\",\n            \"lm_head\": 0,\n            \"transformer.h\": 1,\n            \"transformer.ln_f\": \"cpu\",\n        }\n        bnb_quantization_config = BnbQuantizationConfig(load_in_4bit=True)\n\n        with init_empty_weights():\n            model_4bit = AutoModelForCausalLM.from_config(AutoConfig.from_pretrained(self.model_name))\n\n        model_4bit.tie_weights()\n        with tempfile.TemporaryDirectory() as tmpdirname:\n            model_4bit = load_and_quantize_model(\n                model_4bit,\n                bnb_quantization_config,\n                weights_location=self.weights_location,\n                device_map=device_map,\n                no_split_module_classes=[\"BloomBlock\"],\n                offload_folder=tmpdirname,\n                offload_state_dict=True,\n            )\n            self.check_inference_correctness(model_4bit)\n\n\n@slow\n@require_cuda\n@require_bnb\n@require_huggingface_suite\nclass Bnb4BitTestLoadedModel(unittest.TestCase):\n    # We keep the constants inside the init function and model loading inside setUp function\n\n    # We need to test on relatively large models (aka >1b parameters otherwise the quantiztion may not work as expected)\n    # Therefore here we use only bloom-1b3 to test our module\n    model_name = \"marcsun13/bloom-1b7_with_lm_head\"\n\n    # Constant values\n    # This was obtained on a RTX Titan so the number might slightly change\n    EXPECTED_RELATIVE_DIFFERENCE = 2.109659552692574\n\n    input_text = \"Hello my name is\"\n    EXPECTED_OUTPUTS = set()\n    EXPECTED_OUTPUTS.add(\"Hello my name is John and I am a professional photographer. I\")\n    EXPECTED_OUTPUTS.add(\"Hello my name is John.\\nI am a friend of your father.\\n\")\n    MAX_NEW_TOKENS = 10\n\n    def setUp(self):\n        \"\"\"\n        Setup quantized model from loaded model\n        \"\"\"\n        from transformers import AutoModelForCausalLM, AutoTokenizer\n\n        super().setUp()\n\n        # Models and tokenizer\n        self.model_fp16 = AutoModelForCausalLM.from_pretrained(\n            self.model_name, torch_dtype=torch.float16, device_map=\"auto\"\n        )\n\n        self.bnb_quantization_config = BnbQuantizationConfig(load_in_4bit=True)\n\n        self.model_4bit = AutoModelForCausalLM.from_pretrained(self.model_name, torch_dtype=torch.float16)\n        self.model_4bit = load_and_quantize_model(self.model_4bit, self.bnb_quantization_config)\n\n        self.tokenizer = AutoTokenizer.from_pretrained(\"bigscience/bloom-1b7\")\n\n    def tearDown(self):\n        \"\"\"\n        TearDown function needs to be called at the end of each test to free the GPU memory and cache, also to\n        avoid unexpected behaviors. Please see: https://discuss.pytorch.org/t/how-can-we-release-gpu-memory-cache/14530/27\n        \"\"\"\n        super().tearDown()\n        del self.model_fp16\n        del self.model_4bit\n\n        gc.collect()\n        torch.cuda.empty_cache()\n\n    def test_memory_footprint(self):\n        r\"\"\"\n        A simple test to check if the model conversion has been done correctly by checking on the\n        memory footprint of the converted model and the class type of the linear layers of the converted models\n        \"\"\"\n        from bitsandbytes.nn import Params4bit\n\n        mem_fp16 = self.model_fp16.get_memory_footprint()\n        mem_4bit = self.model_4bit.get_memory_footprint()\n\n        self.assertAlmostEqual(mem_fp16 / mem_4bit, self.EXPECTED_RELATIVE_DIFFERENCE)\n        self.assertTrue(self.model_4bit.transformer.h[0].mlp.dense_4h_to_h.weight.__class__ == Params4bit)\n\n    def test_linear_are_4bit(self):\n        r\"\"\"\n        A simple test to check if the model conversion has been done correctly by checking on the\n        memory footprint of the converted model and the class type of the linear layers of the converted models\n        \"\"\"\n\n        self.model_fp16.get_memory_footprint()\n        self.model_4bit.get_memory_footprint()\n\n        for name, module in self.model_4bit.named_modules():\n            if isinstance(module, torch.nn.Linear):\n                if (\n                    name\n                    not in self.bnb_quantization_config.keep_in_fp32_modules\n                    + self.bnb_quantization_config.skip_modules\n                ):\n                    # 4-bit parameters are packed in uint8 variables\n                    self.assertTrue(module.weight.dtype == torch.uint8)\n\n    def test_generate_quality(self):\n        r\"\"\"\n        Test the generation quality of the quantized model and see that we are matching the expected output.\n        Given that we are operating on small numbers + the testing model is relatively small, we might not get\n        the same output across GPUs. So we'll generate few tokens (5-10) and check their output.\n        \"\"\"\n        encoded_input = self.tokenizer(self.input_text, return_tensors=\"pt\")\n\n        output_sequences = self.model_4bit.generate(\n            input_ids=encoded_input[\"input_ids\"].to(self.model_4bit.device), max_new_tokens=10\n        )\n\n        self.assertIn(self.tokenizer.decode(output_sequences[0], skip_special_tokens=True), self.EXPECTED_OUTPUTS)\n\n    def test_fp32_4bit_conversion(self):\n        r\"\"\"\n        Test whether it is possible to mix both `4bit` and `fp32` weights when using `keep_in_fp32_modules` correctly.\n        \"\"\"\n        from transformers import AutoModelForCausalLM\n\n        bnb_quantization_config = BnbQuantizationConfig(load_in_4bit=True, keep_in_fp32_modules=[\"lm_head\"])\n\n        model = AutoModelForCausalLM.from_pretrained(self.model_name, torch_dtype=torch.float16)\n        model = load_and_quantize_model(model, bnb_quantization_config)\n        self.assertTrue(model.lm_head.weight.dtype == torch.float32)\n", "# Copyright 2022 The HuggingFace Team. All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport unittest\n\nimport torch\nfrom torch import nn\n\nfrom accelerate.test_utils import require_cuda\nfrom accelerate.utils.memory import find_executable_batch_size, release_memory\n\n\ndef raise_fake_out_of_memory():\n    raise RuntimeError(\"CUDA out of memory.\")\n\n\nclass ModelForTest(nn.Module):\n    def __init__(self):\n        super().__init__()\n        self.linear1 = nn.Linear(3, 4)\n        self.batchnorm = nn.BatchNorm1d(4)\n        self.linear2 = nn.Linear(4, 5)\n\n    def forward(self, x):\n        return self.linear2(self.batchnorm(self.linear1(x)))\n\n\nclass MemoryTest(unittest.TestCase):\n    def test_memory_implicit(self):\n        batch_sizes = []\n\n        @find_executable_batch_size(starting_batch_size=128)\n        def mock_training_loop_function(batch_size):\n            nonlocal batch_sizes\n            batch_sizes.append(batch_size)\n            if batch_size != 8:\n                raise_fake_out_of_memory()\n\n        mock_training_loop_function()\n        self.assertListEqual(batch_sizes, [128, 64, 32, 16, 8])\n\n    def test_memory_explicit(self):\n        batch_sizes = []\n\n        @find_executable_batch_size(starting_batch_size=128)\n        def mock_training_loop_function(batch_size, arg1):\n            nonlocal batch_sizes\n            batch_sizes.append(batch_size)\n            if batch_size != 8:\n                raise_fake_out_of_memory()\n            return batch_size, arg1\n\n        bs, arg1 = mock_training_loop_function(\"hello\")\n        self.assertListEqual(batch_sizes, [128, 64, 32, 16, 8])\n        self.assertListEqual([bs, arg1], [8, \"hello\"])\n\n    def test_start_zero(self):\n        @find_executable_batch_size(starting_batch_size=0)\n        def mock_training_loop_function(batch_size):\n            pass\n\n        with self.assertRaises(RuntimeError) as cm:\n            mock_training_loop_function()\n            self.assertIn(\"No executable batch size found, reached zero.\", cm.exception.args[0])\n\n    def test_approach_zero(self):\n        @find_executable_batch_size(starting_batch_size=16)\n        def mock_training_loop_function(batch_size):\n            if batch_size > 0:\n                raise_fake_out_of_memory()\n            pass\n\n        with self.assertRaises(RuntimeError) as cm:\n            mock_training_loop_function()\n            self.assertIn(\"No executable batch size found, reached zero.\", cm.exception.args[0])\n\n    def test_verbose_guard(self):\n        @find_executable_batch_size(starting_batch_size=128)\n        def mock_training_loop_function(batch_size, arg1, arg2):\n            if batch_size != 8:\n                raise raise_fake_out_of_memory()\n\n        with self.assertRaises(TypeError) as cm:\n            mock_training_loop_function(128, \"hello\", \"world\")\n            self.assertIn(\"Batch size was passed into `f`\", cm.exception.args[0])\n            self.assertIn(\"`f(arg1='hello', arg2='world')\", cm.exception.args[0])\n\n    def test_any_other_error(self):\n        @find_executable_batch_size(starting_batch_size=16)\n        def mock_training_loop_function(batch_size):\n            raise ValueError(\"Oops, we had an error!\")\n\n        with self.assertRaises(ValueError) as cm:\n            mock_training_loop_function()\n            self.assertIn(\"Oops, we had an error!\", cm.exception.args[0])\n\n    @require_cuda\n    def test_release_memory(self):\n        starting_memory = torch.cuda.memory_allocated()\n        model = ModelForTest()\n        model.cuda()\n        self.assertGreater(torch.cuda.memory_allocated(), starting_memory)\n        model = release_memory(model)\n        self.assertEqual(torch.cuda.memory_allocated(), starting_memory)\n", "# Copyright 2021 The HuggingFace Team. All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"\nA simple launcher script for TPU training\n\nInspired by https://github.com/pytorch/pytorch/blob/master/torch/distributed/launch.py\n\n::\n    >>> python xla_spawn.py --num_cores=NUM_CORES_YOU_HAVE\n               YOUR_TRAINING_SCRIPT.py (--arg1 --arg2 --arg3 and all other\n               arguments of your training script)\n\n\"\"\"\n\n\nimport importlib\nimport sys\nfrom argparse import REMAINDER, ArgumentParser\nfrom pathlib import Path\n\nimport torch_xla.distributed.xla_multiprocessing as xmp\n\n\ndef parse_args():\n    \"\"\"\n    Helper function parsing the command line options\n    @retval ArgumentParser\n    \"\"\"\n    parser = ArgumentParser(\n        description=(\n            \"PyTorch TPU distributed training launch \"\n            \"helper utility that will spawn up \"\n            \"multiple distributed processes\"\n        )\n    )\n\n    # Optional arguments for the launch helper\n    parser.add_argument(\"--num_cores\", type=int, default=1, help=\"Number of TPU cores to use (1 or 8).\")\n\n    # positional\n    parser.add_argument(\n        \"training_script\",\n        type=str,\n        help=(\n            \"The full path to the single TPU training \"\n            \"program/script to be launched in parallel, \"\n            \"followed by all the arguments for the \"\n            \"training script\"\n        ),\n    )\n\n    # rest from the training program\n    parser.add_argument(\"training_script_args\", nargs=REMAINDER)\n\n    return parser.parse_args()\n\n\ndef main():\n    args = parse_args()\n\n    # Import training_script as a module.\n    script_fpath = Path(args.training_script)\n    sys.path.append(str(script_fpath.parent.resolve()))\n    mod_name = script_fpath.stem\n    mod = importlib.import_module(mod_name)\n\n    # Patch sys.argv\n    sys.argv = [args.training_script] + args.training_script_args + [\"--tpu_num_cores\", str(args.num_cores)]\n    xmp.spawn(mod._mp_fn, args=(), nprocs=args.num_cores)\n\n\nif __name__ == \"__main__\":\n    main()\n", "# Copyright 2021 The HuggingFace Team. All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport inspect\nimport os\nimport sys\nimport unittest\n\nimport accelerate\nfrom accelerate.test_utils import execute_subprocess_async, require_tpu\n\n\nclass MultiTPUTester(unittest.TestCase):\n    def setUp(self):\n        mod_file = inspect.getfile(accelerate.test_utils)\n        self.test_file_path = os.path.sep.join(mod_file.split(os.path.sep)[:-1] + [\"scripts\", \"test_script.py\"])\n        self.test_dir = os.path.sep.join(inspect.getfile(self.__class__).split(os.path.sep)[:-1])\n\n    @require_tpu\n    def test_tpu(self):\n        distributed_args = f\"\"\"\n            {self.test_dir}/xla_spawn.py\n            --num_cores 8\n            {self.test_file_path}\n        \"\"\".split()\n        cmd = [sys.executable] + distributed_args\n        execute_subprocess_async(cmd, env=os.environ.copy())\n", "# Copyright 2021 The HuggingFace Team. All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport random\nimport unittest\n\nfrom torch.utils.data import BatchSampler, DataLoader, IterableDataset\n\nfrom accelerate import Accelerator\nfrom accelerate.data_loader import (\n    BatchSamplerShard,\n    DataLoaderDispatcher,\n    DataLoaderShard,\n    IterableDatasetShard,\n    SkipBatchSampler,\n    SkipDataLoader,\n    skip_first_batches,\n)\n\n\nclass RandomIterableDataset(IterableDataset):\n    # For testing, an iterable dataset of random length\n    def __init__(self, p_stop=0.01, max_length=1000):\n        self.p_stop = p_stop\n        self.max_length = max_length\n\n    def __iter__(self):\n        count = 0\n        stop = False\n        while not stop and count < self.max_length:\n            yield count\n            count += 1\n            stop = random.random() < self.p_stop\n\n\nclass DataLoaderTester(unittest.TestCase):\n    def check_batch_sampler_shards(self, batch_sampler, expected, split_batches=False, even_batches=True):\n        batch_sampler_shards = [\n            BatchSamplerShard(batch_sampler, 2, i, split_batches=split_batches, even_batches=even_batches)\n            for i in range(2)\n        ]\n        batch_sampler_lists = [list(batch_sampler_shard) for batch_sampler_shard in batch_sampler_shards]\n        if not split_batches:\n            self.assertListEqual([len(shard) for shard in batch_sampler_shards], [len(e) for e in expected])\n        self.assertListEqual(batch_sampler_lists, expected)\n\n    def test_batch_sampler_shards_with_no_splits(self):\n        # Check the shards when the dataset is a round multiple of total batch size.\n        batch_sampler = BatchSampler(range(24), batch_size=3, drop_last=False)\n        expected = [\n            [[0, 1, 2], [6, 7, 8], [12, 13, 14], [18, 19, 20]],\n            [[3, 4, 5], [9, 10, 11], [15, 16, 17], [21, 22, 23]],\n        ]\n        self.check_batch_sampler_shards(batch_sampler, expected)\n\n        batch_sampler = BatchSampler(range(24), batch_size=3, drop_last=True)\n        # Expected shouldn't change\n        self.check_batch_sampler_shards(batch_sampler, expected)\n\n        # Check the shards when the dataset is a round multiple of batch size but not total batch size.\n        batch_sampler = BatchSampler(range(21), batch_size=3, drop_last=False)\n        expected = [\n            [[0, 1, 2], [6, 7, 8], [12, 13, 14], [18, 19, 20]],\n            [[3, 4, 5], [9, 10, 11], [15, 16, 17], [0, 1, 2]],\n        ]\n        self.check_batch_sampler_shards(batch_sampler, expected)\n\n        batch_sampler = BatchSampler(range(21), batch_size=3, drop_last=True)\n        expected = [\n            [[0, 1, 2], [6, 7, 8], [12, 13, 14]],\n            [[3, 4, 5], [9, 10, 11], [15, 16, 17]],\n        ]\n        self.check_batch_sampler_shards(batch_sampler, expected)\n\n        # Check the shards when the dataset is not a round multiple of batch size but has a multiple of\n        # num_processes batch.\n        batch_sampler = BatchSampler(range(22), batch_size=3, drop_last=False)\n        expected = [\n            [[0, 1, 2], [6, 7, 8], [12, 13, 14], [18, 19, 20]],\n            [[3, 4, 5], [9, 10, 11], [15, 16, 17], [21, 0, 1]],\n        ]\n        self.check_batch_sampler_shards(batch_sampler, expected)\n\n        batch_sampler = BatchSampler(range(22), batch_size=3, drop_last=True)\n        expected = [\n            [[0, 1, 2], [6, 7, 8], [12, 13, 14]],\n            [[3, 4, 5], [9, 10, 11], [15, 16, 17]],\n        ]\n        self.check_batch_sampler_shards(batch_sampler, expected)\n\n        # Check the shards when the dataset is not a round multiple of batch size but and has not a multiple of\n        # num_processes batch.\n        batch_sampler = BatchSampler(range(20), batch_size=3, drop_last=False)\n        expected = [\n            [[0, 1, 2], [6, 7, 8], [12, 13, 14], [18, 19, 0]],\n            [[3, 4, 5], [9, 10, 11], [15, 16, 17], [1, 2, 3]],\n        ]\n        self.check_batch_sampler_shards(batch_sampler, expected)\n\n        batch_sampler = BatchSampler(range(20), batch_size=3, drop_last=True)\n        expected = [\n            [[0, 1, 2], [6, 7, 8], [12, 13, 14]],\n            [[3, 4, 5], [9, 10, 11], [15, 16, 17]],\n        ]\n        self.check_batch_sampler_shards(batch_sampler, expected)\n\n        # Check the shards when the dataset is very small.\n        batch_sampler = BatchSampler(range(2), batch_size=3, drop_last=False)\n        expected = [[[0, 1, 0]], [[1, 0, 1]]]\n        self.check_batch_sampler_shards(batch_sampler, expected)\n\n        batch_sampler = BatchSampler(range(2), batch_size=3, drop_last=True)\n        expected = [[], []]\n        self.check_batch_sampler_shards(batch_sampler, expected)\n\n    def test_batch_sampler_shards_with_splits(self):\n        # Check the shards when the dataset is a round multiple of batch size.\n        batch_sampler = BatchSampler(range(24), batch_size=4, drop_last=False)\n        expected = [\n            [[0, 1], [4, 5], [8, 9], [12, 13], [16, 17], [20, 21]],\n            [[2, 3], [6, 7], [10, 11], [14, 15], [18, 19], [22, 23]],\n        ]\n        self.check_batch_sampler_shards(batch_sampler, expected, split_batches=True)\n\n        batch_sampler = BatchSampler(range(24), batch_size=4, drop_last=True)\n        # Expected shouldn't change\n        self.check_batch_sampler_shards(batch_sampler, expected, split_batches=True)\n\n        # Check the shards when the dataset is not a round multiple of batch size.\n        batch_sampler = BatchSampler(range(22), batch_size=4, drop_last=False)\n        expected = [\n            [[0, 1], [4, 5], [8, 9], [12, 13], [16, 17], [20, 21]],\n            [[2, 3], [6, 7], [10, 11], [14, 15], [18, 19], [0, 1]],\n        ]\n        self.check_batch_sampler_shards(batch_sampler, expected, split_batches=True)\n\n        batch_sampler = BatchSampler(range(22), batch_size=4, drop_last=True)\n        expected = [\n            [[0, 1], [4, 5], [8, 9], [12, 13], [16, 17]],\n            [[2, 3], [6, 7], [10, 11], [14, 15], [18, 19]],\n        ]\n        self.check_batch_sampler_shards(batch_sampler, expected, split_batches=True)\n\n        # Check the shards when the dataset is not a round multiple of batch size or num_processes.\n        batch_sampler = BatchSampler(range(21), batch_size=4, drop_last=False)\n        expected = [\n            [[0, 1], [4, 5], [8, 9], [12, 13], [16, 17], [20, 0]],\n            [[2, 3], [6, 7], [10, 11], [14, 15], [18, 19], [1, 2]],\n        ]\n        self.check_batch_sampler_shards(batch_sampler, expected, split_batches=True)\n\n        batch_sampler = BatchSampler(range(21), batch_size=4, drop_last=True)\n        expected = [\n            [[0, 1], [4, 5], [8, 9], [12, 13], [16, 17]],\n            [[2, 3], [6, 7], [10, 11], [14, 15], [18, 19]],\n        ]\n        self.check_batch_sampler_shards(batch_sampler, expected, split_batches=True)\n\n        # Check the shards when the dataset is very small.\n        batch_sampler = BatchSampler(range(2), batch_size=4, drop_last=False)\n        expected = [[[0, 1]], [[0, 1]]]\n        self.check_batch_sampler_shards(batch_sampler, expected, split_batches=True)\n\n        batch_sampler = BatchSampler(range(2), batch_size=4, drop_last=True)\n        expected = [[], []]\n        self.check_batch_sampler_shards(batch_sampler, expected, split_batches=True)\n\n    def test_batch_sampler_shards_with_no_splits_no_even(self):\n        # Check the shards when the dataset is a round multiple of total batch size.\n        batch_sampler = BatchSampler(range(24), batch_size=3, drop_last=False)\n        expected = [\n            [[0, 1, 2], [6, 7, 8], [12, 13, 14], [18, 19, 20]],\n            [[3, 4, 5], [9, 10, 11], [15, 16, 17], [21, 22, 23]],\n        ]\n        self.check_batch_sampler_shards(batch_sampler, expected, even_batches=False)\n\n        batch_sampler = BatchSampler(range(24), batch_size=3, drop_last=True)\n        # Expected shouldn't change\n        self.check_batch_sampler_shards(batch_sampler, expected, even_batches=False)\n\n        # Check the shards when the dataset is a round multiple of batch size but not total batch size.\n        batch_sampler = BatchSampler(range(21), batch_size=3, drop_last=False)\n        expected = [\n            [[0, 1, 2], [6, 7, 8], [12, 13, 14], [18, 19, 20]],\n            [[3, 4, 5], [9, 10, 11], [15, 16, 17]],\n        ]\n        self.check_batch_sampler_shards(batch_sampler, expected, even_batches=False)\n\n        batch_sampler = BatchSampler(range(21), batch_size=3, drop_last=True)\n        expected = [\n            [[0, 1, 2], [6, 7, 8], [12, 13, 14]],\n            [[3, 4, 5], [9, 10, 11], [15, 16, 17]],\n        ]\n        self.check_batch_sampler_shards(batch_sampler, expected, even_batches=False)\n\n        # Check the shards when the dataset is not a round multiple of batch size but has a multiple of\n        # num_processes batch.\n        batch_sampler = BatchSampler(range(22), batch_size=3, drop_last=False)\n        expected = [\n            [[0, 1, 2], [6, 7, 8], [12, 13, 14], [18, 19, 20]],\n            [[3, 4, 5], [9, 10, 11], [15, 16, 17], [21]],\n        ]\n        self.check_batch_sampler_shards(batch_sampler, expected, even_batches=False)\n\n        batch_sampler = BatchSampler(range(22), batch_size=3, drop_last=True)\n        expected = [\n            [[0, 1, 2], [6, 7, 8], [12, 13, 14]],\n            [[3, 4, 5], [9, 10, 11], [15, 16, 17]],\n        ]\n        self.check_batch_sampler_shards(batch_sampler, expected, even_batches=False)\n\n        # Check the shards when the dataset is not a round multiple of batch size but and has not a multiple of\n        # num_processes batch.\n        batch_sampler = BatchSampler(range(20), batch_size=3, drop_last=False)\n        expected = [\n            [[0, 1, 2], [6, 7, 8], [12, 13, 14], [18, 19]],\n            [[3, 4, 5], [9, 10, 11], [15, 16, 17]],\n        ]\n        self.check_batch_sampler_shards(batch_sampler, expected, even_batches=False)\n\n        batch_sampler = BatchSampler(range(20), batch_size=3, drop_last=True)\n        expected = [\n            [[0, 1, 2], [6, 7, 8], [12, 13, 14]],\n            [[3, 4, 5], [9, 10, 11], [15, 16, 17]],\n        ]\n        self.check_batch_sampler_shards(batch_sampler, expected, even_batches=False)\n\n        # Check the shards when the dataset is very small.\n        batch_sampler = BatchSampler(range(2), batch_size=3, drop_last=False)\n        expected = [[[0, 1]], []]\n        self.check_batch_sampler_shards(batch_sampler, expected, even_batches=False)\n\n        batch_sampler = BatchSampler(range(2), batch_size=3, drop_last=True)\n        expected = [[], []]\n        self.check_batch_sampler_shards(batch_sampler, expected, even_batches=False)\n\n    def test_batch_sampler_shards_with_splits_no_even(self):\n        # Check the shards when the dataset is a round multiple of batch size.\n        batch_sampler = BatchSampler(range(24), batch_size=4, drop_last=False)\n        expected = [\n            [[0, 1], [4, 5], [8, 9], [12, 13], [16, 17], [20, 21]],\n            [[2, 3], [6, 7], [10, 11], [14, 15], [18, 19], [22, 23]],\n        ]\n        self.check_batch_sampler_shards(batch_sampler, expected, split_batches=True, even_batches=False)\n\n        batch_sampler = BatchSampler(range(24), batch_size=4, drop_last=True)\n        # Expected shouldn't change\n        self.check_batch_sampler_shards(batch_sampler, expected, split_batches=True, even_batches=False)\n\n        # Check the shards when the dataset is not a round multiple of batch size.\n        batch_sampler = BatchSampler(range(22), batch_size=4, drop_last=False)\n        expected = [\n            [[0, 1], [4, 5], [8, 9], [12, 13], [16, 17], [20, 21]],\n            [[2, 3], [6, 7], [10, 11], [14, 15], [18, 19]],\n        ]\n        self.check_batch_sampler_shards(batch_sampler, expected, split_batches=True, even_batches=False)\n\n        batch_sampler = BatchSampler(range(22), batch_size=4, drop_last=True)\n        expected = [\n            [[0, 1], [4, 5], [8, 9], [12, 13], [16, 17]],\n            [[2, 3], [6, 7], [10, 11], [14, 15], [18, 19]],\n        ]\n        self.check_batch_sampler_shards(batch_sampler, expected, split_batches=True, even_batches=False)\n\n        # Check the shards when the dataset is not a round multiple of batch size or num_processes.\n        batch_sampler = BatchSampler(range(21), batch_size=4, drop_last=False)\n        expected = [\n            [[0, 1], [4, 5], [8, 9], [12, 13], [16, 17], [20]],\n            [[2, 3], [6, 7], [10, 11], [14, 15], [18, 19]],\n        ]\n        self.check_batch_sampler_shards(batch_sampler, expected, split_batches=True, even_batches=False)\n\n        batch_sampler = BatchSampler(range(21), batch_size=4, drop_last=True)\n        expected = [\n            [[0, 1], [4, 5], [8, 9], [12, 13], [16, 17]],\n            [[2, 3], [6, 7], [10, 11], [14, 15], [18, 19]],\n        ]\n        self.check_batch_sampler_shards(batch_sampler, expected, split_batches=True, even_batches=False)\n\n        # Check the shards when the dataset is very small.\n        batch_sampler = BatchSampler(range(2), batch_size=4, drop_last=False)\n        expected = [[[0, 1]], []]\n        self.check_batch_sampler_shards(batch_sampler, expected, split_batches=True, even_batches=False)\n\n        batch_sampler = BatchSampler(range(2), batch_size=4, drop_last=True)\n        expected = [[], []]\n        self.check_batch_sampler_shards(batch_sampler, expected, split_batches=True, even_batches=False)\n\n    def test_batch_sampler_with_varying_batch_size(self):\n        batch_sampler = [[0, 1, 2], [3, 4], [5, 6, 7, 8], [9, 10, 11], [12, 13]]\n        batch_sampler_shards = [BatchSamplerShard(batch_sampler, 2, i, even_batches=False) for i in range(2)]\n\n        self.assertEqual(len(batch_sampler_shards[0]), 3)\n        self.assertEqual(len(batch_sampler_shards[1]), 2)\n\n        self.assertListEqual(list(batch_sampler_shards[0]), [[0, 1, 2], [5, 6, 7, 8], [12, 13]])\n        self.assertListEqual(list(batch_sampler_shards[1]), [[3, 4], [9, 10, 11]])\n\n    def check_iterable_dataset_shards(\n        self, dataset, seed, batch_size, drop_last=False, num_processes=2, split_batches=False\n    ):\n        random.seed(seed)\n        reference = list(dataset)\n\n        iterable_dataset_shards = [\n            IterableDatasetShard(\n                dataset,\n                batch_size=batch_size,\n                drop_last=drop_last,\n                num_processes=num_processes,\n                process_index=i,\n                split_batches=split_batches,\n            )\n            for i in range(num_processes)\n        ]\n        iterable_dataset_lists = []\n        for iterable_dataset_shard in iterable_dataset_shards:\n            # Since our random iterable dataset will be... random... we need to use a seed to get reproducible results.\n            random.seed(seed)\n            iterable_dataset_lists.append(list(iterable_dataset_shard))\n\n        shard_batch_size = batch_size // num_processes if split_batches else batch_size\n        # All iterable dataset shard should have the same length, a round multiple of shard_batch_size\n        first_list = iterable_dataset_lists[0]\n        for l in iterable_dataset_lists[1:]:\n            self.assertEqual(len(l), len(first_list))\n            self.assertTrue(len(l) % shard_batch_size == 0)\n\n        observed = []\n        for idx in range(0, len(first_list), shard_batch_size):\n            for l in iterable_dataset_lists:\n                observed += l[idx : idx + shard_batch_size]\n\n        if not drop_last:\n            while len(reference) < len(observed):\n                reference += reference\n        self.assertListEqual(observed, reference[: len(observed)])\n\n    def test_iterable_dataset_shard(self):\n        seed = 42\n        dataset = RandomIterableDataset()\n\n        self.check_iterable_dataset_shards(dataset, seed, batch_size=4, drop_last=False, split_batches=False)\n        self.check_iterable_dataset_shards(dataset, seed, batch_size=4, drop_last=True, split_batches=False)\n        self.check_iterable_dataset_shards(dataset, seed, batch_size=4, drop_last=False, split_batches=True)\n        self.check_iterable_dataset_shards(dataset, seed, batch_size=4, drop_last=True, split_batches=True)\n\n        # Edge case with a very small dataset\n        dataset = RandomIterableDataset(max_length=2)\n\n        self.check_iterable_dataset_shards(dataset, seed, batch_size=4, drop_last=False, split_batches=False)\n        self.check_iterable_dataset_shards(dataset, seed, batch_size=4, drop_last=True, split_batches=False)\n        self.check_iterable_dataset_shards(dataset, seed, batch_size=4, drop_last=False, split_batches=True)\n        self.check_iterable_dataset_shards(dataset, seed, batch_size=4, drop_last=True, split_batches=True)\n\n    def test_skip_batch_sampler(self):\n        batch_sampler = BatchSampler(range(16), batch_size=4, drop_last=False)\n        new_batch_sampler = SkipBatchSampler(batch_sampler, 2)\n        self.assertListEqual(list(new_batch_sampler), [[8, 9, 10, 11], [12, 13, 14, 15]])\n\n    def test_skip_data_loader(self):\n        dataloader = SkipDataLoader(list(range(16)), batch_size=4, skip_batches=2)\n        self.assertListEqual([t.tolist() for t in dataloader], [[8, 9, 10, 11], [12, 13, 14, 15]])\n\n    def test_skip_first_batches(self):\n        dataloader = DataLoader(list(range(16)), batch_size=4)\n        new_dataloader = skip_first_batches(dataloader, num_batches=2)\n        self.assertListEqual([t.tolist() for t in new_dataloader], [[8, 9, 10, 11], [12, 13, 14, 15]])\n\n    def test_end_of_dataloader(self):\n        dataloader = DataLoaderShard(list(range(16)), batch_size=4)\n        for idx, _ in enumerate(dataloader):\n            self.assertEqual(dataloader.end_of_dataloader, idx == 3)\n\n        # Test it also works on the second iteration\n        for idx, _ in enumerate(dataloader):\n            self.assertEqual(dataloader.end_of_dataloader, idx == 3)\n\n    def test_end_of_dataloader_dispatcher(self):\n        Accelerator()\n        dataloader = DataLoaderDispatcher(range(16), batch_size=4)\n        for idx, _ in enumerate(dataloader):\n            self.assertEqual(dataloader.end_of_dataloader, idx == 3)\n\n        # Test it also works on the second iteration\n        for idx, _ in enumerate(dataloader):\n            self.assertEqual(dataloader.end_of_dataloader, idx == 3)\n", "# Copyright 2021 The HuggingFace Team. All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport os\nimport pickle\nimport unittest\nfrom collections import UserDict, namedtuple\n\nimport torch\n\nfrom accelerate.test_utils.testing import require_cuda, require_torch_min_version\nfrom accelerate.test_utils.training import RegressionModel\nfrom accelerate.utils import (\n    convert_outputs_to_fp32,\n    extract_model_from_parallel,\n    find_device,\n    listify,\n    patch_environment,\n    recursively_apply,\n    send_to_device,\n)\n\n\nExampleNamedTuple = namedtuple(\"ExampleNamedTuple\", \"a b c\")\n\n\nclass UtilsTester(unittest.TestCase):\n    def test_send_to_device(self):\n        tensor = torch.randn(5, 2)\n        device = torch.device(\"cuda\") if torch.cuda.is_available() else torch.device(\"cpu\")\n\n        result1 = send_to_device(tensor, device)\n        self.assertTrue(torch.equal(result1.cpu(), tensor))\n\n        result2 = send_to_device((tensor, [tensor, tensor], 1), device)\n        self.assertIsInstance(result2, tuple)\n        self.assertTrue(torch.equal(result2[0].cpu(), tensor))\n        self.assertIsInstance(result2[1], list)\n        self.assertTrue(torch.equal(result2[1][0].cpu(), tensor))\n        self.assertTrue(torch.equal(result2[1][1].cpu(), tensor))\n        self.assertEqual(result2[2], 1)\n\n        result2 = send_to_device({\"a\": tensor, \"b\": [tensor, tensor], \"c\": 1}, device)\n        self.assertIsInstance(result2, dict)\n        self.assertTrue(torch.equal(result2[\"a\"].cpu(), tensor))\n        self.assertIsInstance(result2[\"b\"], list)\n        self.assertTrue(torch.equal(result2[\"b\"][0].cpu(), tensor))\n        self.assertTrue(torch.equal(result2[\"b\"][1].cpu(), tensor))\n        self.assertEqual(result2[\"c\"], 1)\n\n        result3 = send_to_device(ExampleNamedTuple(a=tensor, b=[tensor, tensor], c=1), device)\n        self.assertIsInstance(result3, ExampleNamedTuple)\n        self.assertTrue(torch.equal(result3.a.cpu(), tensor))\n        self.assertIsInstance(result3.b, list)\n        self.assertTrue(torch.equal(result3.b[0].cpu(), tensor))\n        self.assertTrue(torch.equal(result3.b[1].cpu(), tensor))\n        self.assertEqual(result3.c, 1)\n\n        result4 = send_to_device(UserDict({\"a\": tensor, \"b\": [tensor, tensor], \"c\": 1}), device)\n        self.assertIsInstance(result4, UserDict)\n        self.assertTrue(torch.equal(result4[\"a\"].cpu(), tensor))\n        self.assertIsInstance(result4[\"b\"], list)\n        self.assertTrue(torch.equal(result4[\"b\"][0].cpu(), tensor))\n        self.assertTrue(torch.equal(result4[\"b\"][1].cpu(), tensor))\n        self.assertEqual(result4[\"c\"], 1)\n\n    def test_honor_type(self):\n        with self.assertRaises(TypeError) as cm:\n            _ = recursively_apply(torch.tensor, (torch.tensor(1), 1), error_on_other_type=True)\n        self.assertEqual(\n            str(cm.exception),\n            \"Unsupported types (<class 'int'>) passed to `tensor`. Only nested list/tuple/dicts of objects that are valid for `is_torch_tensor` should be passed.\",\n        )\n\n    def test_listify(self):\n        tensor = torch.tensor([1, 2, 3, 4, 5])\n        self.assertEqual(listify(tensor), [1, 2, 3, 4, 5])\n\n        tensor = torch.tensor([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]])\n        self.assertEqual(listify(tensor), [[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]])\n\n        tensor = torch.tensor([[[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]], [[11, 12, 13, 14, 15], [16, 17, 18, 19, 20]]])\n        self.assertEqual(\n            listify(tensor), [[[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]], [[11, 12, 13, 14, 15], [16, 17, 18, 19, 20]]]\n        )\n\n    def test_patch_environment(self):\n        with patch_environment(aa=1, BB=2):\n            self.assertEqual(os.environ.get(\"AA\"), \"1\")\n            self.assertEqual(os.environ.get(\"BB\"), \"2\")\n\n        self.assertNotIn(\"AA\", os.environ)\n        self.assertNotIn(\"BB\", os.environ)\n\n    def test_can_undo_convert_outputs(self):\n        model = RegressionModel()\n        model._original_forward = model.forward\n        model.forward = convert_outputs_to_fp32(model.forward)\n        model = extract_model_from_parallel(model, keep_fp32_wrapper=False)\n        _ = pickle.dumps(model)\n\n    @require_cuda\n    def test_can_undo_fp16_conversion(self):\n        model = RegressionModel()\n        model._original_forward = model.forward\n        model.forward = torch.cuda.amp.autocast(dtype=torch.float16)(model.forward)\n        model.forward = convert_outputs_to_fp32(model.forward)\n        model = extract_model_from_parallel(model, keep_fp32_wrapper=False)\n        _ = pickle.dumps(model)\n\n    @require_cuda\n    @require_torch_min_version(version=\"2.0\")\n    def test_dynamo(self):\n        model = RegressionModel()\n        model._original_forward = model.forward\n        model.forward = torch.cuda.amp.autocast(dtype=torch.float16)(model.forward)\n        model.forward = convert_outputs_to_fp32(model.forward)\n        model.forward = torch.compile(model.forward, backend=\"inductor\")\n        inputs = torch.randn(4, 10).cuda()\n        _ = model(inputs)\n\n    def test_extract_model(self):\n        model = RegressionModel()\n        # could also do a test with DistributedDataParallel, but difficult to run on CPU or single GPU\n        distributed_model = torch.nn.parallel.DataParallel(model)\n        model_unwrapped = extract_model_from_parallel(distributed_model)\n\n        self.assertEqual(model, model_unwrapped)\n\n    @require_torch_min_version(version=\"2.0\")\n    def test_dynamo_extract_model(self):\n        model = RegressionModel()\n        compiled_model = torch.compile(model)\n\n        # could also do a test with DistributedDataParallel, but difficult to run on CPU or single GPU\n        distributed_model = torch.nn.parallel.DataParallel(model)\n        distributed_compiled_model = torch.compile(distributed_model)\n        compiled_model_unwrapped = extract_model_from_parallel(distributed_compiled_model)\n\n        self.assertEqual(compiled_model._orig_mod, compiled_model_unwrapped._orig_mod)\n\n    def test_find_device(self):\n        self.assertEqual(find_device([1, \"a\", torch.tensor([1, 2, 3])]), torch.device(\"cpu\"))\n        self.assertEqual(find_device({\"a\": 1, \"b\": torch.tensor([1, 2, 3])}), torch.device(\"cpu\"))\n        self.assertIsNone(find_device([1, \"a\"]))\n", "# Copyright 2022 The HuggingFace Team. All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport inspect\nimport os\nimport unittest\nfrom pathlib import Path\n\nimport torch\n\nimport accelerate\nfrom accelerate.test_utils import execute_subprocess_async\nfrom accelerate.test_utils.testing import run_command\n\n\nclass AccelerateLauncherTester(unittest.TestCase):\n    \"\"\"\n    Test case for verifying the `accelerate launch` CLI operates correctly.\n    If a `default_config.yaml` file is located in the cache it will temporarily move it\n    for the duration of the tests.\n    \"\"\"\n\n    mod_file = inspect.getfile(accelerate.test_utils)\n    test_file_path = os.path.sep.join(mod_file.split(os.path.sep)[:-1] + [\"scripts\", \"test_cli.py\"])\n\n    base_cmd = [\"accelerate\", \"launch\"]\n    config_folder = Path.home() / \".cache/huggingface/accelerate\"\n    config_file = \"default_config.yaml\"\n    config_path = config_folder / config_file\n    changed_path = config_folder / \"_default_config.yaml\"\n\n    test_config_path = Path(\"tests/test_configs\")\n\n    @classmethod\n    def setUpClass(cls):\n        if cls.config_path.is_file():\n            cls.config_path.rename(cls.changed_path)\n\n    @classmethod\n    def tearDownClass(cls):\n        if cls.changed_path.is_file():\n            cls.changed_path.rename(cls.config_path)\n\n    def test_no_config(self):\n        cmd = self.base_cmd\n        if torch.cuda.is_available() and (torch.cuda.device_count() > 1):\n            cmd += [\"--multi_gpu\"]\n        execute_subprocess_async(cmd + [self.test_file_path], env=os.environ.copy())\n\n    def test_config_compatibility(self):\n        for config in sorted(self.test_config_path.glob(\"**/*.yaml\")):\n            with self.subTest(config_file=config):\n                execute_subprocess_async(\n                    self.base_cmd + [\"--config_file\", str(config), self.test_file_path], env=os.environ.copy()\n                )\n\n    def test_accelerate_test(self):\n        execute_subprocess_async([\"accelerate\", \"test\"], env=os.environ.copy())\n\n\nclass TpuConfigTester(unittest.TestCase):\n    \"\"\"\n    Test case for verifying the `accelerate tpu-config` CLI passes the right `gcloud` command.\n    \"\"\"\n\n    tpu_name = \"test-tpu\"\n    tpu_zone = \"us-central1-a\"\n    command = \"ls\"\n    cmd = [\"accelerate\", \"tpu-config\"]\n    base_output = \"cd /usr/share\"\n    command_file = \"tests/test_samples/test_command_file.sh\"\n    gcloud = \"Running gcloud compute tpus tpu-vm ssh\"\n\n    def test_base(self):\n        output = run_command(\n            self.cmd\n            + [\"--command\", self.command, \"--tpu_zone\", self.tpu_zone, \"--tpu_name\", self.tpu_name, \"--debug\"],\n            return_stdout=True,\n        )\n        self.assertIn(\n            f\"{self.gcloud} test-tpu --zone us-central1-a --command {self.base_output}; ls --worker all\",\n            output,\n        )\n\n    def test_base_backward_compatibility(self):\n        output = run_command(\n            self.cmd\n            + [\n                \"--config_file\",\n                \"tests/test_configs/0_12_0.yaml\",\n                \"--command\",\n                self.command,\n                \"--tpu_zone\",\n                self.tpu_zone,\n                \"--tpu_name\",\n                self.tpu_name,\n                \"--debug\",\n            ],\n            return_stdout=True,\n        )\n        self.assertIn(\n            f\"{self.gcloud} test-tpu --zone us-central1-a --command {self.base_output}; ls --worker all\",\n            output,\n        )\n\n    def test_with_config_file(self):\n        output = run_command(\n            self.cmd + [\"--config_file\", \"tests/test_configs/latest.yaml\", \"--debug\"], return_stdout=True\n        )\n        self.assertIn(\n            f'{self.gcloud} test-tpu --zone us-central1-a --command {self.base_output}; echo \"hello world\"; echo \"this is a second command\" --worker all',\n            output,\n        )\n\n    def test_with_config_file_and_command(self):\n        output = run_command(\n            self.cmd + [\"--config_file\", \"tests/test_configs/latest.yaml\", \"--command\", self.command, \"--debug\"],\n            return_stdout=True,\n        )\n        self.assertIn(\n            f\"{self.gcloud} test-tpu --zone us-central1-a --command {self.base_output}; ls --worker all\",\n            output,\n        )\n\n    def test_with_config_file_and_multiple_command(self):\n        output = run_command(\n            self.cmd\n            + [\n                \"--config_file\",\n                \"tests/test_configs/latest.yaml\",\n                \"--command\",\n                self.command,\n                \"--command\",\n                'echo \"Hello World\"',\n                \"--debug\",\n            ],\n            return_stdout=True,\n        )\n        self.assertIn(\n            f'{self.gcloud} test-tpu --zone us-central1-a --command {self.base_output}; ls; echo \"Hello World\" --worker all',\n            output,\n        )\n\n    def test_with_config_file_and_command_file(self):\n        output = run_command(\n            self.cmd\n            + [\"--config_file\", \"tests/test_configs/latest.yaml\", \"--command_file\", self.command_file, \"--debug\"],\n            return_stdout=True,\n        )\n        self.assertIn(\n            f'{self.gcloud} test-tpu --zone us-central1-a --command {self.base_output}; echo \"hello world\"; echo \"this is a second command\" --worker all',\n            output,\n        )\n\n    def test_with_config_file_and_command_file_backward_compatibility(self):\n        output = run_command(\n            self.cmd\n            + [\n                \"--config_file\",\n                \"tests/test_configs/0_12_0.yaml\",\n                \"--command_file\",\n                self.command_file,\n                \"--tpu_zone\",\n                self.tpu_zone,\n                \"--tpu_name\",\n                self.tpu_name,\n                \"--debug\",\n            ],\n            return_stdout=True,\n        )\n        self.assertIn(\n            f'{self.gcloud} test-tpu --zone us-central1-a --command {self.base_output}; echo \"hello world\"; echo \"this is a second command\" --worker all',\n            output,\n        )\n\n    def test_accelerate_install(self):\n        output = run_command(\n            self.cmd + [\"--config_file\", \"tests/test_configs/latest.yaml\", \"--install_accelerate\", \"--debug\"],\n            return_stdout=True,\n        )\n        self.assertIn(\n            f'{self.gcloud} test-tpu --zone us-central1-a --command {self.base_output}; pip install accelerate -U; echo \"hello world\"; echo \"this is a second command\" --worker all',\n            output,\n        )\n\n    def test_accelerate_install_version(self):\n        output = run_command(\n            self.cmd\n            + [\n                \"--config_file\",\n                \"tests/test_configs/latest.yaml\",\n                \"--install_accelerate\",\n                \"--accelerate_version\",\n                \"12.0.0\",\n                \"--debug\",\n            ],\n            return_stdout=True,\n        )\n        self.assertIn(\n            f'{self.gcloud} test-tpu --zone us-central1-a --command {self.base_output}; pip install accelerate==12.0.0; echo \"hello world\"; echo \"this is a second command\" --worker all',\n            output,\n        )\n", "# Copyright 2022 The HuggingFace Team. All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport csv\nimport json\nimport logging\nimport os\nimport re\nimport subprocess\nimport tempfile\nimport unittest\nimport zipfile\nfrom pathlib import Path\nfrom typing import Optional\nfrom unittest import mock\n\nimport torch\n\n# We use TF to parse the logs\nfrom accelerate import Accelerator\nfrom accelerate.test_utils.testing import (\n    MockingTestCase,\n    TempDirTestCase,\n    require_comet_ml,\n    require_tensorboard,\n    require_wandb,\n    skip,\n)\nfrom accelerate.tracking import CometMLTracker, GeneralTracker\nfrom accelerate.utils import ProjectConfiguration, is_comet_ml_available, is_tensorboard_available\n\n\nif is_comet_ml_available():\n    from comet_ml import OfflineExperiment\n\nif is_tensorboard_available():\n    import struct\n\n    import tensorboard.compat.proto.event_pb2 as event_pb2\n\nlogger = logging.getLogger(__name__)\n\n\n@require_tensorboard\nclass TensorBoardTrackingTest(unittest.TestCase):\n    def test_init_trackers(self):\n        project_name = \"test_project_with_config\"\n        with tempfile.TemporaryDirectory() as dirpath:\n            accelerator = Accelerator(log_with=\"tensorboard\", project_dir=dirpath)\n            config = {\"num_iterations\": 12, \"learning_rate\": 1e-2, \"some_boolean\": False, \"some_string\": \"some_value\"}\n            accelerator.init_trackers(project_name, config)\n            accelerator.end_training()\n            for child in Path(f\"{dirpath}/{project_name}\").glob(\"*/**\"):\n                log = list(filter(lambda x: x.is_file(), child.iterdir()))[0]\n            self.assertNotEqual(str(log), \"\")\n\n    def test_log(self):\n        project_name = \"test_project_with_log\"\n        with tempfile.TemporaryDirectory() as dirpath:\n            accelerator = Accelerator(log_with=\"tensorboard\", project_dir=dirpath)\n            accelerator.init_trackers(project_name)\n            values = {\"total_loss\": 0.1, \"iteration\": 1, \"my_text\": \"some_value\"}\n            accelerator.log(values, step=0)\n            accelerator.end_training()\n            # Logged values are stored in the outermost-tfevents file and can be read in as a TFRecord\n            # Names are randomly generated each time\n            log = list(filter(lambda x: x.is_file(), Path(f\"{dirpath}/{project_name}\").iterdir()))[0]\n            self.assertNotEqual(str(log), \"\")\n\n    def test_log_with_tensor(self):\n        project_name = \"test_project_with_log\"\n        with tempfile.TemporaryDirectory() as dirpath:\n            accelerator = Accelerator(log_with=\"tensorboard\", project_dir=dirpath)\n            accelerator.init_trackers(project_name)\n            values = {\"tensor\": torch.tensor(1)}\n            accelerator.log(values, step=0)\n            accelerator.end_training()\n            # Logged values are stored in the outermost-tfevents file and can be read in as a TFRecord\n            # Names are randomly generated each time\n            log = list(filter(lambda x: x.is_file(), Path(f\"{dirpath}/{project_name}\").iterdir()))[0]\n            # Reading implementation based on https://github.com/pytorch/pytorch/issues/45327#issuecomment-703757685\n            with open(log, \"rb\") as f:\n                data = f.read()\n            found_tensor = False\n            while data:\n                header = struct.unpack(\"Q\", data[:8])\n\n                event_str = data[12 : 12 + int(header[0])]  # 8+4\n                data = data[12 + int(header[0]) + 4 :]\n                event = event_pb2.Event()\n\n                event.ParseFromString(event_str)\n                if event.HasField(\"summary\"):\n                    for value in event.summary.value:\n                        if value.simple_value == 1.0 and value.tag == \"tensor\":\n                            found_tensor = True\n            self.assertTrue(found_tensor, \"Converted tensor was not found in the log file!\")\n\n    def test_project_dir(self):\n        with self.assertRaisesRegex(ValueError, \"Logging with `tensorboard` requires a `logging_dir`\"):\n            _ = Accelerator(log_with=\"tensorboard\")\n        with tempfile.TemporaryDirectory() as dirpath:\n            _ = Accelerator(log_with=\"tensorboard\", project_dir=dirpath)\n\n    def test_project_dir_with_config(self):\n        config = ProjectConfiguration(total_limit=30)\n        with tempfile.TemporaryDirectory() as dirpath:\n            _ = Accelerator(log_with=\"tensorboard\", project_dir=dirpath, project_config=config)\n\n\n@require_wandb\n@mock.patch.dict(os.environ, {\"WANDB_MODE\": \"offline\"})\nclass WandBTrackingTest(TempDirTestCase, MockingTestCase):\n    def setUp(self):\n        super().setUp()\n        # wandb let's us override where logs are stored to via the WANDB_DIR env var\n        self.add_mocks(mock.patch.dict(os.environ, {\"WANDB_DIR\": self.tmpdir}))\n\n    @staticmethod\n    def parse_log(log: str, section: str, record: bool = True):\n        \"\"\"\n        Parses wandb log for `section` and returns a dictionary of\n        all items in that section. Section names are based on the\n        output of `wandb sync --view --verbose` and items starting\n        with \"Record\" in that result\n        \"\"\"\n        # Big thanks to the W&B team for helping us parse their logs\n        pattern = rf\"{section} ([\\S\\s]*?)\\n\\n\"\n        if record:\n            pattern = rf\"Record: {pattern}\"\n        cleaned_record = re.findall(pattern, log)[0]\n        # A config\n        if section == \"config\" or section == \"history\":\n            cleaned_record = re.findall(r'\"([a-zA-Z0-9_.,]+)', cleaned_record)\n            return {key: val for key, val in zip(cleaned_record[0::2], cleaned_record[1::2])}\n        # Everything else\n        else:\n            return dict(re.findall(r'(\\w+): \"([^\\s]+)\"', cleaned_record))\n\n    @skip\n    def test_wandb(self):\n        project_name = \"test_project_with_config\"\n        accelerator = Accelerator(log_with=\"wandb\")\n        config = {\"num_iterations\": 12, \"learning_rate\": 1e-2, \"some_boolean\": False, \"some_string\": \"some_value\"}\n        kwargs = {\"wandb\": {\"tags\": [\"my_tag\"]}}\n        accelerator.init_trackers(project_name, config, kwargs)\n        values = {\"total_loss\": 0.1, \"iteration\": 1, \"my_text\": \"some_value\"}\n        accelerator.log(values, step=0)\n        accelerator.end_training()\n        # The latest offline log is stored at wandb/latest-run/*.wandb\n        for child in Path(f\"{self.tmpdir}/wandb/latest-run\").glob(\"*\"):\n            if child.is_file() and child.suffix == \".wandb\":\n                content = subprocess.check_output(\n                    [\"wandb\", \"sync\", \"--view\", \"--verbose\", str(child)], env=os.environ.copy()\n                ).decode(\"utf8\", \"ignore\")\n                break\n\n        # Check HPS through careful parsing and cleaning\n        logged_items = self.parse_log(content, \"config\")\n        self.assertEqual(logged_items[\"num_iterations\"], \"12\")\n        self.assertEqual(logged_items[\"learning_rate\"], \"0.01\")\n        self.assertEqual(logged_items[\"some_boolean\"], \"false\")\n        self.assertEqual(logged_items[\"some_string\"], \"some_value\")\n        self.assertEqual(logged_items[\"some_string\"], \"some_value\")\n\n        # Run tags\n        logged_items = self.parse_log(content, \"run\", False)\n        self.assertEqual(logged_items[\"tags\"], \"my_tag\")\n\n        # Actual logging\n        logged_items = self.parse_log(content, \"history\")\n        self.assertEqual(logged_items[\"total_loss\"], \"0.1\")\n        self.assertEqual(logged_items[\"iteration\"], \"1\")\n        self.assertEqual(logged_items[\"my_text\"], \"some_value\")\n        self.assertEqual(logged_items[\"_step\"], \"0\")\n\n\n# Comet has a special `OfflineExperiment` we need to use for testing\ndef offline_init(self, run_name: str, tmpdir: str):\n    self.run_name = run_name\n    self.writer = OfflineExperiment(project_name=run_name, offline_directory=tmpdir)\n    logger.info(f\"Initialized offline CometML project {self.run_name}\")\n    logger.info(\"Make sure to log any initial configurations with `self.store_init_configuration` before training!\")\n\n\n@require_comet_ml\n@mock.patch.object(CometMLTracker, \"__init__\", offline_init)\nclass CometMLTest(unittest.TestCase):\n    @staticmethod\n    def get_value_from_key(log_list, key: str, is_param: bool = False):\n        \"Extracts `key` from Comet `log`\"\n        for log in log_list:\n            j = json.loads(log)[\"payload\"]\n            if is_param and \"param\" in j.keys():\n                if j[\"param\"][\"paramName\"] == key:\n                    return j[\"param\"][\"paramValue\"]\n            if \"log_other\" in j.keys():\n                if j[\"log_other\"][\"key\"] == key:\n                    return j[\"log_other\"][\"val\"]\n            if \"metric\" in j.keys():\n                if j[\"metric\"][\"metricName\"] == key:\n                    return j[\"metric\"][\"metricValue\"]\n\n    def test_init_trackers(self):\n        with tempfile.TemporaryDirectory() as d:\n            tracker = CometMLTracker(\"test_project_with_config\", d)\n            accelerator = Accelerator(log_with=tracker)\n            config = {\"num_iterations\": 12, \"learning_rate\": 1e-2, \"some_boolean\": False, \"some_string\": \"some_value\"}\n            accelerator.init_trackers(None, config)\n            accelerator.end_training()\n            log = os.listdir(d)[0]  # Comet is nice, it's just a zip file here\n            # We parse the raw logs\n            p = os.path.join(d, log)\n            archive = zipfile.ZipFile(p, \"r\")\n            log = archive.open(\"messages.json\").read().decode(\"utf-8\")\n        list_of_json = log.split(\"\\n\")[:-1]\n        self.assertEqual(self.get_value_from_key(list_of_json, \"num_iterations\", True), 12)\n        self.assertEqual(self.get_value_from_key(list_of_json, \"learning_rate\", True), 0.01)\n        self.assertEqual(self.get_value_from_key(list_of_json, \"some_boolean\", True), False)\n        self.assertEqual(self.get_value_from_key(list_of_json, \"some_string\", True), \"some_value\")\n\n    def test_log(self):\n        with tempfile.TemporaryDirectory() as d:\n            tracker = CometMLTracker(\"test_project_with_config\", d)\n            accelerator = Accelerator(log_with=tracker)\n            accelerator.init_trackers(None)\n            values = {\"total_loss\": 0.1, \"iteration\": 1, \"my_text\": \"some_value\"}\n            accelerator.log(values, step=0)\n            accelerator.end_training()\n            log = os.listdir(d)[0]  # Comet is nice, it's just a zip file here\n            # We parse the raw logs\n            p = os.path.join(d, log)\n            archive = zipfile.ZipFile(p, \"r\")\n            log = archive.open(\"messages.json\").read().decode(\"utf-8\")\n        list_of_json = log.split(\"\\n\")[:-1]\n        self.assertEqual(self.get_value_from_key(list_of_json, \"curr_step\", True), 0)\n        self.assertEqual(self.get_value_from_key(list_of_json, \"total_loss\"), 0.1)\n        self.assertEqual(self.get_value_from_key(list_of_json, \"iteration\"), 1)\n        self.assertEqual(self.get_value_from_key(list_of_json, \"my_text\"), \"some_value\")\n\n\nclass MyCustomTracker(GeneralTracker):\n    \"Basic tracker that writes to a csv for testing\"\n    _col_names = [\n        \"total_loss\",\n        \"iteration\",\n        \"my_text\",\n        \"learning_rate\",\n        \"num_iterations\",\n        \"some_boolean\",\n        \"some_string\",\n    ]\n\n    name = \"my_custom_tracker\"\n    requires_logging_directory = False\n\n    def __init__(self, dir: str):\n        self.f = open(f\"{dir}/log.csv\", \"w+\")\n        self.writer = csv.DictWriter(self.f, fieldnames=self._col_names)\n        self.writer.writeheader()\n\n    @property\n    def tracker(self):\n        return self.writer\n\n    def store_init_configuration(self, values: dict):\n        logger.info(\"Call init\")\n        self.writer.writerow(values)\n\n    def log(self, values: dict, step: Optional[int]):\n        logger.info(\"Call log\")\n        self.writer.writerow(values)\n\n    def finish(self):\n        self.f.close()\n\n\nclass CustomTrackerTestCase(unittest.TestCase):\n    def test_init_trackers(self):\n        with tempfile.TemporaryDirectory() as d:\n            tracker = MyCustomTracker(d)\n            accelerator = Accelerator(log_with=tracker)\n            config = {\"num_iterations\": 12, \"learning_rate\": 1e-2, \"some_boolean\": False, \"some_string\": \"some_value\"}\n            accelerator.init_trackers(\"Some name\", config)\n            accelerator.end_training()\n            with open(f\"{d}/log.csv\", \"r\") as f:\n                data = csv.DictReader(f)\n                data = next(data)\n                truth = {\n                    \"total_loss\": \"\",\n                    \"iteration\": \"\",\n                    \"my_text\": \"\",\n                    \"learning_rate\": \"0.01\",\n                    \"num_iterations\": \"12\",\n                    \"some_boolean\": \"False\",\n                    \"some_string\": \"some_value\",\n                }\n                self.assertDictEqual(data, truth)\n\n    def test_log(self):\n        with tempfile.TemporaryDirectory() as d:\n            tracker = MyCustomTracker(d)\n            accelerator = Accelerator(log_with=tracker)\n            accelerator.init_trackers(\"Some name\")\n            values = {\"total_loss\": 0.1, \"iteration\": 1, \"my_text\": \"some_value\"}\n            accelerator.log(values, step=0)\n            accelerator.end_training()\n            with open(f\"{d}/log.csv\", \"r\") as f:\n                data = csv.DictReader(f)\n                data = next(data)\n                truth = {\n                    \"total_loss\": \"0.1\",\n                    \"iteration\": \"1\",\n                    \"my_text\": \"some_value\",\n                    \"learning_rate\": \"\",\n                    \"num_iterations\": \"\",\n                    \"some_boolean\": \"\",\n                    \"some_string\": \"\",\n                }\n                self.assertDictEqual(data, truth)\n", "# Copyright 2021 The HuggingFace Team. All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport unittest\nfrom functools import partial\n\nimport torch\n\nfrom accelerate import Accelerator, debug_launcher\nfrom accelerate.state import AcceleratorState, GradientState\nfrom accelerate.test_utils import require_cpu, require_huggingface_suite\nfrom accelerate.utils import GradientAccumulationPlugin\n\n\ndef one_cycle_test(num_processes=2, step_scheduler_with_optimizer=True, split_batches=False):\n    accelerator = Accelerator(step_scheduler_with_optimizer=step_scheduler_with_optimizer, split_batches=split_batches)\n    model = torch.nn.Linear(2, 4)\n    optimizer = torch.optim.AdamW(model.parameters(), lr=1.0)\n    scheduler = torch.optim.lr_scheduler.OneCycleLR(optimizer, max_lr=0.01, steps_per_epoch=2, epochs=1)\n    model, optimizer, scheduler = accelerator.prepare(model, optimizer, scheduler)\n\n    # Optimizer has stepped\n    scheduler.step()\n    if step_scheduler_with_optimizer or (num_processes == 1):\n        assert (\n            scheduler.scheduler.last_epoch == num_processes\n        ), f\"Last Epoch ({scheduler.scheduler.last_epoch}) != Num Processes ({num_processes})\"\n    else:\n        assert (\n            scheduler.scheduler.last_epoch != num_processes\n        ), f\"Last Epoch ({scheduler.scheduler.last_epoch}) == Num Processes ({num_processes})\"\n\n\ndef lambda_test(num_processes=2, step_scheduler_with_optimizer=True, split_batches=False):\n    accelerator = Accelerator(step_scheduler_with_optimizer=step_scheduler_with_optimizer, split_batches=split_batches)\n    model = torch.nn.Linear(2, 4)\n    optimizer = torch.optim.AdamW(model.parameters(), lr=1.0)\n    scheduler = torch.optim.lr_scheduler.LambdaLR(optimizer, lr_lambda=lambda n: 1 - n / 10)\n    model, optimizer, scheduler = accelerator.prepare(model, optimizer, scheduler)\n\n    # Optimizer has stepped\n    optimizer._is_overflow = False\n    scheduler.step()\n    expected_lr = 1 - (num_processes if (step_scheduler_with_optimizer and not split_batches) else 1) / 10\n    assert (\n        scheduler.get_last_lr()[0] == expected_lr\n    ), f\"Wrong lr found at first step, expected {expected_lr}, got {scheduler.get_last_lr()[0]}\"\n\n    # Optimizer has not stepped\n    optimizer._is_overflow = True\n    scheduler.step()\n    if not step_scheduler_with_optimizer:\n        expected_lr = 1 - 2 / 10\n    assert (\n        scheduler.get_last_lr()[0] == expected_lr\n    ), f\"Wrong lr found at second step, expected {expected_lr}, got {scheduler.get_last_lr()[0]}\"\n\n\ndef accumulation_test(num_processes: int = 2):\n    \"\"\"\n    With this test, an observed batch size of 64 should result in neglible\n    differences in the scheduler after going through the correct number of steps.\n\n    Uses single, two, and four steps to test.\n    \"\"\"\n    from transformers import get_linear_schedule_with_warmup\n\n    steps = [1, 2, 4]\n    for num_steps in steps:\n        plugin = GradientAccumulationPlugin(num_steps=num_steps, adjust_scheduler=num_steps > 1)\n        accelerator = Accelerator(gradient_accumulation_plugin=plugin)\n        model = torch.nn.Linear(2, 4)\n        optimizer = torch.optim.AdamW(model.parameters(), lr=10.0)\n        scheduler = get_linear_schedule_with_warmup(optimizer=optimizer, num_warmup_steps=0, num_training_steps=20)\n\n        model, optimizer, scheduler = accelerator.prepare(model, optimizer, scheduler)\n\n        for i in range(10 * num_steps):\n            with accelerator.accumulate(model):\n                optimizer.step()\n                scheduler.step()\n\n            if i == (10 * num_steps - 2):\n                assert (\n                    scheduler.get_last_lr()[0] != 0\n                ), f\"Wrong lr found at second-to-last step, expected non-zero, got {scheduler.get_last_lr()[0]}. num_steps: {num_steps}\"\n        assert (\n            scheduler.get_last_lr()[0] == 0\n        ), f\"Wrong lr found at last step, expected 0, got {scheduler.get_last_lr()[0]}\"\n        GradientState._reset_state()\n\n\n@require_cpu\nclass SchedulerTester(unittest.TestCase):\n    def test_lambda_scheduler_steps_with_optimizer_single_process(self):\n        debug_launcher(partial(lambda_test, num_processes=1), num_processes=1)\n        debug_launcher(partial(lambda_test, num_processes=1, split_batches=True), num_processes=1)\n\n    def test_one_cycle_scheduler_steps_with_optimizer_single_process(self):\n        debug_launcher(partial(one_cycle_test, num_processes=1), num_processes=1)\n        debug_launcher(partial(one_cycle_test, num_processes=1, split_batches=True), num_processes=1)\n\n    def test_lambda_scheduler_not_step_with_optimizer_single_process(self):\n        debug_launcher(partial(lambda_test, num_processes=1, step_scheduler_with_optimizer=False), num_processes=1)\n\n    def test_one_cycle_scheduler_not_step_with_optimizer_single_process(self):\n        debug_launcher(partial(one_cycle_test, num_processes=1, step_scheduler_with_optimizer=False), num_processes=1)\n\n    def test_lambda_scheduler_steps_with_optimizer_multiprocess(self):\n        AcceleratorState._reset_state(True)\n        debug_launcher(lambda_test)\n        debug_launcher(partial(lambda_test, num_processes=1, split_batches=True), num_processes=1)\n\n    def test_one_cycle_scheduler_steps_with_optimizer_multiprocess(self):\n        AcceleratorState._reset_state(True)\n        debug_launcher(one_cycle_test)\n        debug_launcher(partial(one_cycle_test, num_processes=1, split_batches=True), num_processes=1)\n\n    def test_lambda_scheduler_not_step_with_optimizer_multiprocess(self):\n        AcceleratorState._reset_state(True)\n        debug_launcher(partial(lambda_test, step_scheduler_with_optimizer=False))\n\n    def test_one_cycle_scheduler_not_step_with_optimizer_multiprocess(self):\n        AcceleratorState._reset_state(True)\n        debug_launcher(partial(one_cycle_test, step_scheduler_with_optimizer=False))\n\n    @require_huggingface_suite\n    def test_accumulation(self):\n        AcceleratorState._reset_state(True)\n        debug_launcher(partial(accumulation_test, num_processes=1))\n        debug_launcher(accumulation_test)\n", "# Copyright 2022 The HuggingFace Team. All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport os\nimport unittest\nfrom tempfile import TemporaryDirectory\n\nimport torch\nimport torch.nn as nn\n\nfrom accelerate.utils import (\n    OffloadedWeightsLoader,\n    extract_submodules_state_dict,\n    load_offloaded_weight,\n    offload_state_dict,\n    offload_weight,\n)\n\n\nclass ModelForTest(nn.Module):\n    def __init__(self):\n        super().__init__()\n        self.linear1 = nn.Linear(3, 4)\n        self.batchnorm = nn.BatchNorm1d(4)\n        self.linear2 = nn.Linear(4, 5)\n\n    def forward(self, x):\n        return self.linear2(self.batchnorm(self.linear1(x)))\n\n\nclass OffloadTester(unittest.TestCase):\n    def test_offload_state_dict(self):\n        model = ModelForTest()\n        with TemporaryDirectory() as tmp_dir:\n            offload_state_dict(tmp_dir, model.state_dict())\n            index_file = os.path.join(tmp_dir, \"index.json\")\n            self.assertTrue(os.path.isfile(index_file))\n            # TODO: add tests on what is inside the index\n\n            for key in [\"linear1.weight\", \"linear1.bias\", \"linear2.weight\", \"linear2.bias\"]:\n                weight_file = os.path.join(tmp_dir, f\"{key}.dat\")\n                self.assertTrue(os.path.isfile(weight_file))\n                # TODO: add tests on the fact weights are properly loaded\n\n    def test_offload_weight(self):\n        dtypes = [torch.float16, torch.float32, torch.bfloat16]\n\n        for dtype in dtypes:\n            weight = torch.randn(2, 3, dtype=dtype)\n            with TemporaryDirectory() as tmp_dir:\n                index = offload_weight(weight, \"weight\", tmp_dir, {})\n                weight_file = os.path.join(tmp_dir, \"weight.dat\")\n                self.assertTrue(os.path.isfile(weight_file))\n                self.assertDictEqual(index, {\"weight\": {\"shape\": [2, 3], \"dtype\": str(dtype).split(\".\")[1]}})\n\n                new_weight = load_offloaded_weight(weight_file, index[\"weight\"])\n                self.assertTrue(torch.equal(weight, new_weight))\n\n    def test_offload_weights_loader(self):\n        model = ModelForTest()\n        state_dict = model.state_dict()\n        cpu_part = {k: v for k, v in state_dict.items() if \"linear2\" not in k}\n        disk_part = {k: v for k, v in state_dict.items() if \"linear2\" in k}\n\n        with TemporaryDirectory() as tmp_dir:\n            offload_state_dict(tmp_dir, disk_part)\n            weight_map = OffloadedWeightsLoader(state_dict=cpu_part, save_folder=tmp_dir)\n\n            # Every key is there with the right value\n            self.assertEqual(sorted(weight_map), sorted(state_dict.keys()))\n            for key, param in state_dict.items():\n                self.assertTrue(torch.allclose(param, weight_map[key]))\n\n        cpu_part = {k: v for k, v in state_dict.items() if \"weight\" in k}\n        disk_part = {k: v for k, v in state_dict.items() if \"weight\" not in k}\n\n        with TemporaryDirectory() as tmp_dir:\n            offload_state_dict(tmp_dir, disk_part)\n            weight_map = OffloadedWeightsLoader(state_dict=cpu_part, save_folder=tmp_dir)\n\n            # Every key is there with the right value\n            self.assertEqual(sorted(weight_map), sorted(state_dict.keys()))\n            for key, param in state_dict.items():\n                self.assertTrue(torch.allclose(param, weight_map[key]))\n\n        with TemporaryDirectory() as tmp_dir:\n            offload_state_dict(tmp_dir, state_dict)\n            # Duplicates are removed\n            weight_map = OffloadedWeightsLoader(state_dict=cpu_part, save_folder=tmp_dir)\n\n            # Every key is there with the right value\n            self.assertEqual(sorted(weight_map), sorted(state_dict.keys()))\n            for key, param in state_dict.items():\n                self.assertTrue(torch.allclose(param, weight_map[key]))\n\n    def test_extract_submodules_state_dict(self):\n        state_dict = {\"a.1\": 0, \"a.10\": 1, \"a.2\": 2}\n        extracted = extract_submodules_state_dict(state_dict, [\"a.1\", \"a.2\"])\n        self.assertDictEqual(extracted, {\"a.1\": 0, \"a.2\": 2})\n\n        state_dict = {\"a.1.a\": 0, \"a.10.a\": 1, \"a.2.a\": 2}\n        extracted = extract_submodules_state_dict(state_dict, [\"a.1\", \"a.2\"])\n        self.assertDictEqual(extracted, {\"a.1.a\": 0, \"a.2.a\": 2})\n", "# Copyright 2021 The HuggingFace Team. All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport inspect\nimport os\nimport unittest\nfrom dataclasses import dataclass\n\nimport torch\n\nfrom accelerate import Accelerator, DistributedDataParallelKwargs, GradScalerKwargs\nfrom accelerate.state import AcceleratorState\nfrom accelerate.test_utils import execute_subprocess_async, require_cuda, require_multi_gpu\nfrom accelerate.utils import AutocastKwargs, KwargsHandler, TorchDynamoPlugin, clear_environment\n\n\n@dataclass\nclass MockClass(KwargsHandler):\n    a: int = 0\n    b: bool = False\n    c: float = 3.0\n\n\nclass KwargsHandlerTester(unittest.TestCase):\n    def test_kwargs_handler(self):\n        # If no defaults are changed, `to_kwargs` returns an empty dict.\n        self.assertDictEqual(MockClass().to_kwargs(), {})\n        self.assertDictEqual(MockClass(a=2).to_kwargs(), {\"a\": 2})\n        self.assertDictEqual(MockClass(a=2, b=True).to_kwargs(), {\"a\": 2, \"b\": True})\n        self.assertDictEqual(MockClass(a=2, c=2.25).to_kwargs(), {\"a\": 2, \"c\": 2.25})\n\n    @require_cuda\n    def test_grad_scaler_kwargs(self):\n        # If no defaults are changed, `to_kwargs` returns an empty dict.\n        scaler_handler = GradScalerKwargs(init_scale=1024, growth_factor=2)\n        AcceleratorState._reset_state()\n        accelerator = Accelerator(mixed_precision=\"fp16\", kwargs_handlers=[scaler_handler])\n        print(accelerator.use_fp16)\n        scaler = accelerator.scaler\n\n        # Check the kwargs have been applied\n        self.assertEqual(scaler._init_scale, 1024.0)\n        self.assertEqual(scaler._growth_factor, 2.0)\n\n        # Check the other values are at the default\n        self.assertEqual(scaler._backoff_factor, 0.5)\n        self.assertEqual(scaler._growth_interval, 2000)\n        self.assertEqual(scaler._enabled, True)\n\n    @require_multi_gpu\n    def test_ddp_kwargs(self):\n        cmd = [\"torchrun\", f\"--nproc_per_node={torch.cuda.device_count()}\", inspect.getfile(self.__class__)]\n        execute_subprocess_async(cmd, env=os.environ.copy())\n\n    @require_cuda\n    def test_autocast_kwargs(self):\n        kwargs = AutocastKwargs(enabled=False)\n        AcceleratorState._reset_state()\n        accelerator = Accelerator(mixed_precision=\"fp16\")\n\n        a_float32 = torch.rand((8, 8), device=accelerator.device)\n        b_float32 = torch.rand((8, 8), device=accelerator.device)\n        c_float32 = torch.rand((8, 8), device=accelerator.device)\n        d_float32 = torch.rand((8, 8), device=accelerator.device)\n\n        with accelerator.autocast():\n            e_float16 = torch.mm(a_float32, b_float32)\n            assert e_float16.dtype == torch.float16\n\n            with accelerator.autocast(autocast_handler=kwargs):\n                # Convert e_float16 to float32\n                f_float32 = torch.mm(c_float32, e_float16.float())\n                assert f_float32.dtype == torch.float32\n\n            g_float16 = torch.mm(d_float32, f_float32)\n            # We should be back in fp16\n            assert g_float16.dtype == torch.float16\n\n    def test_torch_dynamo_plugin(self):\n        with clear_environment():\n            prefix = \"ACCELERATE_DYNAMO_\"\n            # nvfuser's dynamo backend name is \"nvprims_nvfuser\"\n            # use \"nvfuser\" here to cause exception if this test causes os.environ changed permanently\n            os.environ[prefix + \"BACKEND\"] = \"nvfuser\"\n            os.environ[prefix + \"MODE\"] = \"reduce-overhead\"\n\n            dynamo_plugin_kwargs = TorchDynamoPlugin().to_kwargs()\n            self.assertEqual(dynamo_plugin_kwargs, {\"backend\": \"nvfuser\", \"mode\": \"reduce-overhead\"})\n\n\nif __name__ == \"__main__\":\n    ddp_scaler = DistributedDataParallelKwargs(bucket_cap_mb=15, find_unused_parameters=True)\n    accelerator = Accelerator(kwargs_handlers=[ddp_scaler])\n    model = torch.nn.Linear(100, 200)\n    model = accelerator.prepare(model)\n\n    # Check the values changed in kwargs\n    error_msg = \"\"\n    observed_bucket_cap_map = model.bucket_bytes_cap // (1024 * 1024)\n    if observed_bucket_cap_map != 15:\n        error_msg += f\"Kwargs badly passed, should have `15` but found {observed_bucket_cap_map}.\\n\"\n    if model.find_unused_parameters is not True:\n        error_msg += f\"Kwargs badly passed, should have `True` but found {model.find_unused_parameters}.\\n\"\n\n    # Check the values of the defaults\n    if model.dim != 0:\n        error_msg += f\"Default value not respected, should have `0` but found {model.dim}.\\n\"\n    if model.broadcast_buffers is not True:\n        error_msg += f\"Default value not respected, should have `True` but found {model.broadcast_buffers}.\\n\"\n    if model.gradient_as_bucket_view is not False:\n        error_msg += f\"Default value not respected, should have `False` but found {model.gradient_as_bucket_view}.\\n\"\n\n    # Raise error at the end to make sure we don't stop at the first failure.\n    if len(error_msg) > 0:\n        raise ValueError(error_msg)\n", "# Copyright 2022 The HuggingFace Team. All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport os\nimport unittest\nfrom tempfile import TemporaryDirectory\n\nimport torch\nimport torch.nn as nn\nfrom transformers import AutoModelForCausalLM, AutoTokenizer\n\nfrom accelerate.big_modeling import (\n    cpu_offload,\n    cpu_offload_with_hook,\n    disk_offload,\n    dispatch_model,\n    init_empty_weights,\n    init_on_device,\n    load_checkpoint_and_dispatch,\n)\nfrom accelerate.hooks import remove_hook_from_submodules\nfrom accelerate.test_utils import require_bnb, require_cuda, require_mps, require_multi_gpu, slow\nfrom accelerate.utils import offload_state_dict\n\n\nclass ModelForTest(nn.Module):\n    def __init__(self):\n        super().__init__()\n        self.linear1 = nn.Linear(3, 4)\n        self.batchnorm = nn.BatchNorm1d(4)\n        self.linear2 = nn.Linear(4, 5)\n\n    def forward(self, x):\n        return self.linear2(self.batchnorm(self.linear1(x)))\n\n\nclass ModelForTestTiedWeights(nn.Module):\n    def __init__(self):\n        super().__init__()\n        self.linear1 = nn.Linear(4, 4)\n        self.batchnorm = nn.BatchNorm1d(4)\n        self.linear2 = nn.Linear(4, 4)\n\n    def forward(self, x):\n        return self.linear2(self.batchnorm(self.linear1(x)))\n\n\nclass BiggerModelForTest(nn.Module):\n    def __init__(self):\n        super().__init__()\n        self.linear1 = nn.Linear(3, 4)\n        self.linear2 = nn.Linear(4, 5)\n        self.batchnorm = nn.BatchNorm1d(5)\n        self.linear3 = nn.Linear(5, 6)\n        self.linear4 = nn.Linear(6, 5)\n\n    def forward(self, x):\n        return self.linear4(self.linear3(self.batchnorm(self.linear2(self.linear1(x)))))\n\n\n# To test preload_module_classes\nclass ModuleWithUnusedSubModules(nn.Module):\n    def __init__(self, input_dim, output_dim):\n        super().__init__()\n        self.linear = nn.Linear(input_dim, output_dim)\n\n    def forward(self, x):\n        return x @ self.linear.weight.t() + self.linear.bias\n\n\nclass ModelWithUnusedSubModulesForTest(nn.Module):\n    def __init__(self):\n        super().__init__()\n        self.linear1 = ModuleWithUnusedSubModules(3, 4)\n        self.linear2 = ModuleWithUnusedSubModules(4, 5)\n        self.batchnorm = nn.BatchNorm1d(5)\n        self.linear3 = ModuleWithUnusedSubModules(5, 6)\n        self.linear4 = ModuleWithUnusedSubModules(6, 5)\n\n    def forward(self, x):\n        return self.linear4(self.linear3(self.batchnorm(self.linear2(self.linear1(x)))))\n\n\nclass BigModelingTester(unittest.TestCase):\n    def test_init_empty_weights(self):\n        # base use\n        with init_empty_weights():\n            module = nn.Linear(4, 5)\n        self.assertEqual(module.weight.device, torch.device(\"meta\"))\n\n        # base use with buffers, they are not touched\n        with init_empty_weights():\n            module = nn.BatchNorm1d(4)\n        self.assertEqual(module.weight.device, torch.device(\"meta\"))\n        self.assertEqual(module.running_mean.device, torch.device(\"cpu\"))\n\n        # Use with include_buffers=True\n        with init_empty_weights(include_buffers=True):\n            module = nn.BatchNorm1d(4)\n        self.assertEqual(module.weight.device, torch.device(\"meta\"))\n        self.assertEqual(module.running_mean.device, torch.device(\"meta\"))\n\n        # Double check we didn't break PyTorch\n        module = nn.BatchNorm1d(4)\n        self.assertEqual(module.weight.device, torch.device(\"cpu\"))\n        self.assertEqual(module.running_mean.device, torch.device(\"cpu\"))\n\n    def test_init_empty_weights_very_large_model(self):\n        # This is a 100 billion parameters model.\n        with init_empty_weights():\n            _ = nn.Sequential(*[nn.Linear(10000, 10000) for _ in range(1000)])\n\n    @require_cuda\n    def test_init_on_device_cuda(self):\n        device = torch.device(\"cuda:0\")\n        with init_on_device(device):\n            model = nn.Linear(10, 10)\n        self.assertEqual(model.weight.device, device)\n        self.assertEqual(model.weight.device, device)\n\n    @require_mps\n    def test_init_on_device_mps(self):\n        device = torch.device(\"mps:0\")\n        with init_on_device(device):\n            model = nn.Linear(10, 10)\n        self.assertEqual(model.weight.device, device)\n        self.assertEqual(model.weight.device, device)\n\n    def test_cpu_offload(self):\n        model = ModelForTest()\n        x = torch.randn(2, 3)\n        expected = model(x)\n\n        device = torch.device(0 if torch.cuda.is_available() else \"cpu\")\n\n        cpu_offload(model, execution_device=device)\n        output = model(x)\n        self.assertTrue(\n            torch.allclose(expected, output.cpu(), 1e-4, 1e-5), msg=f\"Expected: {expected}\\nActual: {output.cpu()}\"\n        )\n\n        # Clean up for next test.\n        remove_hook_from_submodules(model)\n\n        cpu_offload(model, execution_device=device, offload_buffers=True)\n        output = model(x)\n        self.assertTrue(\n            torch.allclose(expected, output.cpu(), 1e-4, 1e-5), msg=f\"Expected: {expected}\\nActual: {output.cpu()}\"\n        )\n\n    def test_cpu_offload_with_unused_submodules(self):\n        model = ModelWithUnusedSubModulesForTest()\n        x = torch.randn(2, 3)\n        expected = model(x)\n\n        device = torch.device(0 if torch.cuda.is_available() else \"cpu\")\n\n        cpu_offload(model, execution_device=device, preload_module_classes=[\"ModuleWithUnusedSubModules\"])\n        output = model(x)\n        self.assertTrue(\n            torch.allclose(expected, output.cpu(), 1e-4, 1e-5), msg=f\"Expected: {expected}\\nActual: {output.cpu()}\"\n        )\n\n        # Clean up for next test.\n        remove_hook_from_submodules(model)\n\n        cpu_offload(\n            model,\n            execution_device=device,\n            offload_buffers=True,\n            preload_module_classes=[\"ModuleWithUnusedSubModules\"],\n        )\n        output = model(x)\n        self.assertTrue(\n            torch.allclose(expected, output.cpu(), 1e-4, 1e-5), msg=f\"Expected: {expected}\\nActual: {output.cpu()}\"\n        )\n\n    @slow\n    @require_cuda\n    def test_cpu_offload_gpt2(self):\n        tokenizer = AutoTokenizer.from_pretrained(\"gpt2\")\n        inputs = tokenizer(\"Hello world! My name is\", return_tensors=\"pt\").to(0)\n\n        gpt2 = AutoModelForCausalLM.from_pretrained(\"gpt2\")\n        cpu_offload(gpt2, execution_device=0)\n        outputs = gpt2.generate(inputs[\"input_ids\"])\n        self.assertEqual(\n            tokenizer.decode(outputs[0].tolist()),\n            \"Hello world! My name is Kiyoshi, and I'm a student at the University of Tokyo\",\n        )\n\n    def test_disk_offload(self):\n        model = ModelForTest()\n        x = torch.randn(2, 3)\n        expected = model(x)\n\n        device = torch.device(0 if torch.cuda.is_available() else \"cpu\")\n\n        with TemporaryDirectory() as tmp_dir:\n            disk_offload(model, tmp_dir, execution_device=device)\n            output = model(x)\n            self.assertTrue(\n                torch.allclose(expected, output.cpu(), 1e-4, 1e-5), msg=f\"Expected: {expected}\\nActual: {output.cpu()}\"\n            )\n\n            # Clean up for next test.\n            remove_hook_from_submodules(model)\n\n        with TemporaryDirectory() as tmp_dir:\n            disk_offload(model, tmp_dir, execution_device=device, offload_buffers=True)\n            output = model(x)\n            self.assertTrue(\n                torch.allclose(expected, output.cpu(), 1e-4, 1e-5), msg=f\"Expected: {expected}\\nActual: {output.cpu()}\"\n            )\n\n    def test_disk_offload_with_unused_submodules(self):\n        model = ModelWithUnusedSubModulesForTest()\n        x = torch.randn(2, 3)\n        expected = model(x)\n\n        device = torch.device(0 if torch.cuda.is_available() else \"cpu\")\n\n        with TemporaryDirectory() as tmp_dir:\n            disk_offload(\n                model, tmp_dir, execution_device=device, preload_module_classes=[\"ModuleWithUnusedSubModules\"]\n            )\n            output = model(x)\n            self.assertTrue(\n                torch.allclose(expected, output.cpu(), 1e-4, 1e-5), msg=f\"Expected: {expected}\\nActual: {output.cpu()}\"\n            )\n\n            # Clean up for next test.\n            remove_hook_from_submodules(model)\n\n        with TemporaryDirectory() as tmp_dir:\n            disk_offload(\n                model,\n                tmp_dir,\n                execution_device=device,\n                offload_buffers=True,\n                preload_module_classes=[\"ModuleWithUnusedSubModules\"],\n            )\n            output = model(x)\n            self.assertTrue(\n                torch.allclose(expected, output.cpu(), 1e-4, 1e-5), msg=f\"Expected: {expected}\\nActual: {output.cpu()}\"\n            )\n\n    @slow\n    @require_cuda\n    def test_disk_offload_gpt2(self):\n        tokenizer = AutoTokenizer.from_pretrained(\"gpt2\")\n        inputs = tokenizer(\"Hello world! My name is\", return_tensors=\"pt\").to(0)\n\n        gpt2 = AutoModelForCausalLM.from_pretrained(\"gpt2\")\n        with TemporaryDirectory() as tmp_dir:\n            disk_offload(gpt2, tmp_dir, execution_device=0)\n            outputs = gpt2.generate(inputs[\"input_ids\"])\n            self.assertEqual(\n                tokenizer.decode(outputs[0].tolist()),\n                \"Hello world! My name is Kiyoshi, and I'm a student at the University of Tokyo\",\n            )\n\n    @require_cuda\n    def test_dispatch_model(self):\n        model = ModelForTest()\n        device_map = {\"linear1\": \"disk\", \"batchnorm\": \"cpu\", \"linear2\": 0}\n\n        x = torch.randn(2, 3)\n        expected = model(x)\n\n        with TemporaryDirectory() as tmp_dir:\n            dispatch_model(model, device_map, offload_dir=tmp_dir)\n            output = model(x)\n            self.assertTrue(torch.allclose(expected, output.cpu(), atol=1e-5))\n\n    @require_mps\n    def test_dispatch_model_mps(self):\n        model = ModelForTest()\n        device_map = {\"linear1\": \"mps\", \"batchnorm\": \"disk\", \"linear2\": \"disk\"}\n\n        x = torch.randn(2, 3)\n        expected = model(x)\n\n        with TemporaryDirectory() as tmp_dir:\n            dispatch_model(model, device_map, offload_dir=tmp_dir)\n            output = model(x)\n            self.assertTrue(torch.allclose(expected, output.cpu(), atol=1e-5))\n\n    @require_cuda\n    def test_dispatch_model_tied_weights(self):\n        model = ModelForTestTiedWeights()\n        model.linear1.weight = model.linear2.weight\n        device_map = {\"linear1\": 0, \"batchnorm\": 0, \"linear2\": 0}\n\n        dispatch_model(model, device_map)\n        self.assertIs(model.linear2.weight, model.linear1.weight)\n\n    @require_multi_gpu\n    def test_dispatch_model_multi_gpu(self):\n        model = BiggerModelForTest()\n        device_map = {\"linear1\": \"cpu\", \"linear2\": \"disk\", \"batchnorm\": \"cpu\", \"linear3\": 0, \"linear4\": 1}\n\n        x = torch.randn(2, 3)\n        expected = model(x)\n\n        with TemporaryDirectory() as tmp_dir:\n            dispatch_model(model, device_map, offload_dir=tmp_dir)\n            output = model(x)\n            self.assertTrue(torch.allclose(expected, output.cpu(), atol=1e-5))\n\n    @slow\n    @require_multi_gpu\n    def test_dispatch_model_gpt2_on_two_gpus(self):\n        tokenizer = AutoTokenizer.from_pretrained(\"gpt2\")\n        inputs = tokenizer(\"Hello world! My name is\", return_tensors=\"pt\").to(0)\n\n        gpt2 = AutoModelForCausalLM.from_pretrained(\"gpt2\")\n        # Dispatch on GPUs 0 and 1\n        device_map = {\n            \"transformer.wte\": 0,\n            \"transformer.wpe\": 0,\n            \"transformer.ln_f\": 1,\n            \"lm_head\": 0,\n        }\n        for i in range(12):\n            device_map[f\"transformer.h.{i}\"] = 0 if i <= 5 else 1\n\n        gpt2 = dispatch_model(gpt2, device_map)\n        outputs = gpt2.generate(inputs[\"input_ids\"])\n        self.assertEqual(\n            tokenizer.decode(outputs[0].tolist()),\n            \"Hello world! My name is Kiyoshi, and I'm a student at the University of Tokyo\",\n        )\n\n        # Dispatch with a bit of CPU offload\n        gpt2 = AutoModelForCausalLM.from_pretrained(\"gpt2\")\n        for i in range(4):\n            device_map[f\"transformer.h.{i}\"] = \"cpu\"\n        gpt2 = dispatch_model(gpt2, device_map)\n        outputs = gpt2.generate(inputs[\"input_ids\"])\n        self.assertEqual(\n            tokenizer.decode(outputs[0].tolist()),\n            \"Hello world! My name is Kiyoshi, and I'm a student at the University of Tokyo\",\n        )\n        # Dispatch with a bit of CPU and disk offload\n        gpt2 = AutoModelForCausalLM.from_pretrained(\"gpt2\")\n        for i in range(2):\n            device_map[f\"transformer.h.{i}\"] = \"disk\"\n\n        with TemporaryDirectory() as tmp_dir:\n            state_dict = {\n                k: p for k, p in gpt2.state_dict().items() if \"transformer.h.0\" in k or \"transformer.h.1\" in k\n            }\n            offload_state_dict(tmp_dir, state_dict)\n            gpt2 = dispatch_model(gpt2, device_map, offload_dir=tmp_dir)\n            outputs = gpt2.generate(inputs[\"input_ids\"])\n            self.assertEqual(\n                tokenizer.decode(outputs[0].tolist()),\n                \"Hello world! My name is Kiyoshi, and I'm a student at the University of Tokyo\",\n            )\n\n    @require_cuda\n    def test_dispatch_model_with_unused_submodules(self):\n        model = ModelWithUnusedSubModulesForTest()\n        device_map = {\"linear1\": \"cpu\", \"linear2\": \"disk\", \"batchnorm\": \"cpu\", \"linear3\": 0, \"linear4\": 0}\n\n        x = torch.randn(2, 3)\n        expected = model(x)\n\n        with TemporaryDirectory() as tmp_dir:\n            dispatch_model(\n                model, device_map, offload_dir=tmp_dir, preload_module_classes=[\"ModuleWithUnusedSubModules\"]\n            )\n            output = model(x)\n            self.assertTrue(torch.allclose(expected, output.cpu(), atol=1e-5))\n\n    @require_mps\n    def test_dispatch_model_with_unused_submodules_mps(self):\n        model = ModelWithUnusedSubModulesForTest()\n        device_map = {\"linear1\": \"mps\", \"linear2\": \"mps\", \"batchnorm\": \"mps\", \"linear3\": \"mps\", \"linear4\": \"disk\"}\n\n        x = torch.randn(2, 3)\n        expected = model(x)\n\n        with TemporaryDirectory() as tmp_dir:\n            dispatch_model(\n                model, device_map, offload_dir=tmp_dir, preload_module_classes=[\"ModuleWithUnusedSubModules\"]\n            )\n            output = model(x)\n            self.assertTrue(torch.allclose(expected, output.cpu(), atol=1e-5))\n\n    @require_multi_gpu\n    def test_dispatch_model_with_unused_submodules_multi_gpu(self):\n        model = ModelWithUnusedSubModulesForTest()\n        device_map = {\"linear1\": \"cpu\", \"linear2\": \"disk\", \"batchnorm\": \"cpu\", \"linear3\": 0, \"linear4\": 1}\n\n        x = torch.randn(2, 3)\n        expected = model(x)\n\n        with TemporaryDirectory() as tmp_dir:\n            dispatch_model(\n                model, device_map, offload_dir=tmp_dir, preload_module_classes=[\"ModuleWithUnusedSubModules\"]\n            )\n            output = model(x)\n            self.assertTrue(torch.allclose(expected, output.cpu(), atol=1e-5))\n\n    @require_cuda\n    def test_load_checkpoint_and_dispatch(self):\n        model = ModelForTest()\n        device_map = {\"linear1\": \"cpu\", \"batchnorm\": \"cpu\", \"linear2\": 0}\n\n        x = torch.randn(2, 3)\n        expected = model(x)\n\n        with TemporaryDirectory() as tmp_dir:\n            checkpoint = os.path.join(tmp_dir, \"pt_model.bin\")\n            torch.save(model.state_dict(), checkpoint)\n\n            new_model = ModelForTest()\n            new_model = load_checkpoint_and_dispatch(new_model, checkpoint, device_map=device_map)\n\n        # CPU-offloaded weights are on the meta device while waiting for the forward pass.\n        self.assertEqual(new_model.linear1.weight.device, torch.device(\"meta\"))\n        self.assertEqual(new_model.linear2.weight.device, torch.device(0))\n\n        output = new_model(x)\n        self.assertTrue(torch.allclose(expected, output.cpu(), atol=1e-5))\n\n    @require_mps\n    def test_load_checkpoint_and_dispatch_mps(self):\n        model = ModelForTest()\n        device_map = {\"linear1\": \"mps\", \"batchnorm\": \"mps\", \"linear2\": \"disk\"}\n\n        x = torch.randn(2, 3)\n        expected = model(x)\n\n        with TemporaryDirectory() as tmp_dir:\n            checkpoint = os.path.join(tmp_dir, \"pt_model.bin\")\n            torch.save(model.state_dict(), checkpoint)\n\n            new_model = ModelForTest()\n            new_model = load_checkpoint_and_dispatch(\n                new_model, checkpoint, device_map=device_map, offload_folder=tmp_dir\n            )\n\n            # CPU-offloaded weights are on the meta device while waiting for the forward pass.\n            self.assertEqual(new_model.linear1.weight.device, torch.device(\"mps:0\"))\n            self.assertEqual(new_model.linear2.weight.device, torch.device(\"meta\"))\n\n            output = new_model(x)\n            self.assertTrue(torch.allclose(expected, output.cpu(), atol=1e-5))\n\n    @require_multi_gpu\n    def test_load_checkpoint_and_dispatch_multi_gpu(self):\n        model = BiggerModelForTest()\n        device_map = {\"linear1\": \"cpu\", \"linear2\": \"cpu\", \"batchnorm\": 0, \"linear3\": 0, \"linear4\": 1}\n\n        x = torch.randn(2, 3)\n        expected = model(x)\n\n        with TemporaryDirectory() as tmp_dir:\n            checkpoint = os.path.join(tmp_dir, \"pt_model.bin\")\n            torch.save(model.state_dict(), checkpoint)\n\n            new_model = BiggerModelForTest()\n            new_model = load_checkpoint_and_dispatch(new_model, checkpoint, device_map=device_map)\n\n        # CPU-offloaded weights are on the meta device while waiting for the forward pass.\n        self.assertEqual(new_model.linear1.weight.device, torch.device(\"meta\"))\n        self.assertEqual(new_model.linear2.weight.device, torch.device(\"meta\"))\n        self.assertEqual(new_model.linear3.weight.device, torch.device(0))\n        self.assertEqual(new_model.linear4.weight.device, torch.device(1))\n\n        output = new_model(x)\n        self.assertTrue(torch.allclose(expected, output.cpu(), atol=1e-5))\n\n    @require_cuda\n    def test_load_checkpoint_and_dispatch_with_unused_submodules(self):\n        model = ModelWithUnusedSubModulesForTest()\n        device_map = {\"linear1\": \"cpu\", \"linear2\": \"cpu\", \"batchnorm\": 0, \"linear3\": 0, \"linear4\": 0}\n\n        x = torch.randn(2, 3)\n        expected = model(x)\n\n        with TemporaryDirectory() as tmp_dir:\n            checkpoint = os.path.join(tmp_dir, \"pt_model.bin\")\n            torch.save(model.state_dict(), checkpoint)\n\n            new_model = ModelWithUnusedSubModulesForTest()\n            new_model = load_checkpoint_and_dispatch(\n                new_model, checkpoint, device_map=device_map, preload_module_classes=[\"ModuleWithUnusedSubModules\"]\n            )\n\n        # CPU-offloaded weights are on the meta device while waiting for the forward pass.\n        self.assertEqual(new_model.linear1.linear.weight.device, torch.device(\"meta\"))\n        self.assertEqual(new_model.linear2.linear.weight.device, torch.device(\"meta\"))\n        self.assertEqual(new_model.linear3.linear.weight.device, torch.device(0))\n        self.assertEqual(new_model.linear4.linear.weight.device, torch.device(0))\n\n        output = new_model(x)\n        self.assertTrue(torch.allclose(expected, output.cpu(), atol=1e-5))\n\n    @require_mps\n    def test_load_checkpoint_and_dispatch_with_unused_submodules_mps(self):\n        model = ModelWithUnusedSubModulesForTest()\n        device_map = {\"linear1\": \"mps\", \"linear2\": \"mps\", \"batchnorm\": \"mps\", \"linear3\": \"disk\", \"linear4\": \"disk\"}\n\n        x = torch.randn(2, 3)\n        expected = model(x)\n\n        with TemporaryDirectory() as tmp_dir:\n            checkpoint = os.path.join(tmp_dir, \"pt_model.bin\")\n            torch.save(model.state_dict(), checkpoint)\n\n            new_model = ModelWithUnusedSubModulesForTest()\n            new_model = load_checkpoint_and_dispatch(\n                new_model,\n                checkpoint,\n                device_map=device_map,\n                preload_module_classes=[\"ModuleWithUnusedSubModules\"],\n                offload_folder=tmp_dir,\n            )\n\n            # CPU-offloaded weights are on the meta device while waiting for the forward pass.\n            self.assertEqual(new_model.linear1.linear.weight.device, torch.device(\"mps:0\"))\n            self.assertEqual(new_model.linear2.linear.weight.device, torch.device(\"mps:0\"))\n            self.assertEqual(new_model.linear3.linear.weight.device, torch.device(\"meta\"))\n            self.assertEqual(new_model.linear4.linear.weight.device, torch.device(\"meta\"))\n\n            output = new_model(x)\n            self.assertTrue(torch.allclose(expected, output.cpu(), atol=1e-5))\n\n    @require_multi_gpu\n    def test_load_checkpoint_and_dispatch_multi_gpu_with_unused_submodules(self):\n        model = ModelWithUnusedSubModulesForTest()\n        device_map = {\"linear1\": \"cpu\", \"linear2\": \"cpu\", \"batchnorm\": 0, \"linear3\": 0, \"linear4\": 1}\n\n        x = torch.randn(2, 3)\n        expected = model(x)\n\n        with TemporaryDirectory() as tmp_dir:\n            checkpoint = os.path.join(tmp_dir, \"pt_model.bin\")\n            torch.save(model.state_dict(), checkpoint)\n\n            new_model = ModelWithUnusedSubModulesForTest()\n            new_model = load_checkpoint_and_dispatch(\n                new_model, checkpoint, device_map=device_map, preload_module_classes=[\"ModuleWithUnusedSubModules\"]\n            )\n\n        # CPU-offloaded weights are on the meta device while waiting for the forward pass.\n        self.assertEqual(new_model.linear1.linear.weight.device, torch.device(\"meta\"))\n        self.assertEqual(new_model.linear2.linear.weight.device, torch.device(\"meta\"))\n        self.assertEqual(new_model.linear3.linear.weight.device, torch.device(0))\n        self.assertEqual(new_model.linear4.linear.weight.device, torch.device(1))\n\n        output = new_model(x)\n        self.assertTrue(torch.allclose(expected, output.cpu(), atol=1e-5))\n\n    @require_cuda\n    def test_cpu_offload_with_hook(self):\n        model1 = torch.nn.Linear(4, 5)\n        model1, hook1 = cpu_offload_with_hook(model1)\n        self.assertEqual(model1.weight.device, torch.device(\"cpu\"))\n\n        inputs = torch.randn(3, 4)\n        outputs = model1(inputs)\n        self.assertEqual(outputs.device, torch.device(0))\n        self.assertEqual(model1.weight.device, torch.device(0))\n\n        hook1.offload()\n        self.assertEqual(model1.weight.device, torch.device(\"cpu\"))\n\n        model2 = torch.nn.Linear(5, 5)\n        model2, hook2 = cpu_offload_with_hook(model2, prev_module_hook=hook1)\n        self.assertEqual(model2.weight.device, torch.device(\"cpu\"))\n\n        outputs = model1(inputs)\n        self.assertEqual(outputs.device, torch.device(0))\n        self.assertEqual(model1.weight.device, torch.device(0))\n\n        outputs = model2(outputs)\n        self.assertEqual(outputs.device, torch.device(0))\n        self.assertEqual(model1.weight.device, torch.device(\"cpu\"))\n        self.assertEqual(model2.weight.device, torch.device(0))\n\n        hook2.offload()\n        self.assertEqual(model2.weight.device, torch.device(\"cpu\"))\n\n    @slow\n    @require_bnb\n    @require_multi_gpu\n    def test_dispatch_model_bnb(self):\n        \"\"\"Tests that `dispatch_model` quantizes int8 layers\"\"\"\n        from huggingface_hub import hf_hub_download\n        from transformers import AutoConfig, AutoModel, BitsAndBytesConfig\n        from transformers.utils.bitsandbytes import replace_with_bnb_linear\n\n        with init_empty_weights():\n            model = AutoModel.from_config(AutoConfig.from_pretrained(\"bigscience/bloom-560m\"))\n\n        # TODO: @younesbelkada remove the positional arg on the next `transformers` release\n        quantization_config = BitsAndBytesConfig(load_in_8bit=True)\n        model = replace_with_bnb_linear(\n            model, modules_to_not_convert=[\"lm_head\"], quantization_config=quantization_config\n        )\n\n        # TODO: @younesbelkada remove this block on the next `transformers` release\n        for p in model.parameters():\n            p.requires_grad = False\n\n        model_path = hf_hub_download(\"bigscience/bloom-560m\", \"pytorch_model.bin\")\n\n        model = load_checkpoint_and_dispatch(\n            model,\n            checkpoint=model_path,\n            # device_map=\"auto\",\n            device_map=\"balanced\",\n        )\n\n        self.assertTrue(model.h[0].self_attention.query_key_value.weight.dtype == torch.int8)\n        self.assertTrue(model.h[0].self_attention.query_key_value.weight.device.index == 0)\n\n        self.assertTrue(model.h[-1].self_attention.query_key_value.weight.dtype == torch.int8)\n        self.assertTrue(model.h[-1].self_attention.query_key_value.weight.device.index == 1)\n\n    @slow\n    @require_bnb\n    def test_dispatch_model_int8_simple(self):\n        \"\"\"Tests that `dispatch_model` quantizes int8 layers\"\"\"\n        from huggingface_hub import hf_hub_download\n        from transformers import AutoConfig, AutoModel, BitsAndBytesConfig\n        from transformers.utils.bitsandbytes import replace_with_bnb_linear\n\n        with init_empty_weights():\n            model = AutoModel.from_config(AutoConfig.from_pretrained(\"bigscience/bloom-560m\"))\n\n        # TODO: @younesbelkada remove the positional arg on the next `transformers` release\n        quantization_config = BitsAndBytesConfig(load_in_8bit=True)\n        model = replace_with_bnb_linear(\n            model, modules_to_not_convert=[\"lm_head\"], quantization_config=quantization_config\n        )\n\n        # TODO: @younesbelkada remove this block on the next `transformers` release\n        for p in model.parameters():\n            p.requires_grad = False\n\n        model_path = hf_hub_download(\"bigscience/bloom-560m\", \"pytorch_model.bin\")\n\n        # test with auto\n        model = load_checkpoint_and_dispatch(\n            model,\n            checkpoint=model_path,\n            device_map=\"auto\",\n        )\n\n        self.assertTrue(model.h[0].self_attention.query_key_value.weight.dtype == torch.int8)\n        self.assertTrue(model.h[0].self_attention.query_key_value.weight.device.index == 0)\n\n        with init_empty_weights():\n            model = AutoModel.from_config(AutoConfig.from_pretrained(\"bigscience/bloom-560m\"))\n\n        # TODO: @younesbelkada remove the positional arg on the next `transformers` release\n        model = replace_with_bnb_linear(\n            model, modules_to_not_convert=[\"lm_head\"], quantization_config=quantization_config\n        )\n\n        for p in model.parameters():\n            p.requires_grad = False\n\n        # test with str device map\n        model = load_checkpoint_and_dispatch(\n            model,\n            checkpoint=model_path,\n            device_map={\"\": torch.device(\"cuda:0\")},\n        )\n\n        self.assertTrue(model.h[0].self_attention.query_key_value.weight.dtype == torch.int8)\n        self.assertTrue(model.h[0].self_attention.query_key_value.weight.device.index == 0)\n\n        with init_empty_weights():\n            model = AutoModel.from_config(AutoConfig.from_pretrained(\"bigscience/bloom-560m\"))\n\n        # TODO: @younesbelkada remove the positional arg on the next `transformers` release\n        model = replace_with_bnb_linear(\n            model, modules_to_not_convert=[\"lm_head\"], quantization_config=quantization_config\n        )\n\n        # TODO: @younesbelkada remove this block on the next `transformers` release\n        for p in model.parameters():\n            p.requires_grad = False\n\n        # test with torch.device device map\n        model = load_checkpoint_and_dispatch(\n            model,\n            checkpoint=model_path,\n            device_map={\"\": \"cuda:0\"},\n        )\n\n        self.assertTrue(model.h[0].self_attention.query_key_value.weight.dtype == torch.int8)\n        self.assertTrue(model.h[0].self_attention.query_key_value.weight.device.index == 0)\n\n    @slow\n    @require_bnb\n    @unittest.skip(\"Un-skip in the next transformers release\")\n    def test_dipatch_model_fp4_simple(self):\n        \"\"\"Tests that `dispatch_model` quantizes fp4 layers\"\"\"\n        from huggingface_hub import hf_hub_download\n        from transformers import AutoConfig, AutoModel, BitsAndBytesConfig\n        from transformers.utils.bitsandbytes import replace_with_bnb_linear\n\n        with init_empty_weights():\n            model = AutoModel.from_config(AutoConfig.from_pretrained(\"bigscience/bloom-560m\"))\n\n        quantization_config = BitsAndBytesConfig(load_in_4bit=True)\n\n        model = replace_with_bnb_linear(\n            model, modules_to_not_convert=[\"lm_head\"], quantization_config=quantization_config\n        )\n\n        model_path = hf_hub_download(\"bigscience/bloom-560m\", \"pytorch_model.bin\")\n\n        # test with auto\n        model = load_checkpoint_and_dispatch(\n            model,\n            checkpoint=model_path,\n            device_map=\"auto\",\n        )\n\n        self.assertTrue(model.h[0].self_attention.query_key_value.weight.dtype == torch.uint8)\n        self.assertTrue(model.h[0].self_attention.query_key_value.weight.device.index == 0)\n\n        with init_empty_weights():\n            model = AutoModel.from_config(AutoConfig.from_pretrained(\"bigscience/bloom-560m\"))\n\n        model = replace_with_bnb_linear(\n            model, modules_to_not_convert=[\"lm_head\"], quantization_config=quantization_config\n        )\n\n        # test with str device map\n        model = load_checkpoint_and_dispatch(\n            model,\n            checkpoint=model_path,\n            device_map={\"\": torch.device(\"cuda:0\")},\n        )\n\n        self.assertTrue(model.h[0].self_attention.query_key_value.weight.dtype == torch.uint8)\n        self.assertTrue(model.h[0].self_attention.query_key_value.weight.device.index == 0)\n\n        with init_empty_weights():\n            model = AutoModel.from_config(AutoConfig.from_pretrained(\"bigscience/bloom-560m\"))\n\n        model = replace_with_bnb_linear(\n            model, modules_to_not_convert=[\"lm_head\"], quantization_config=quantization_config\n        )\n\n        # test with torch.device device map\n        model = load_checkpoint_and_dispatch(\n            model,\n            checkpoint=model_path,\n            device_map={\"\": \"cuda:0\"},\n        )\n\n        self.assertTrue(model.h[0].self_attention.query_key_value.weight.dtype == torch.uint8)\n        self.assertTrue(model.h[0].self_attention.query_key_value.weight.device.index == 0)\n", "# Copyright 2022 The HuggingFace Team. All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport inspect\nimport logging\nimport os\nimport random\nimport shutil\nimport tempfile\nimport unittest\n\nimport pytest\nimport torch\nfrom torch import nn\nfrom torch.utils.data import DataLoader, TensorDataset\n\nfrom accelerate import Accelerator\nfrom accelerate.test_utils import execute_subprocess_async, require_cuda\nfrom accelerate.utils import ProjectConfiguration, set_seed\n\n\nlogger = logging.getLogger(__name__)\n\n\ndef dummy_dataloaders(a=2, b=3, batch_size=16, n_train_batches: int = 10, n_valid_batches: int = 2):\n    \"Generates a tuple of dummy DataLoaders to test with\"\n\n    def get_dataset(n_batches):\n        x = torch.randn(batch_size * n_batches, 1)\n        return TensorDataset(x, a * x + b + 0.1 * torch.randn(batch_size * n_batches, 1))\n\n    train_dataset = get_dataset(n_train_batches)\n    valid_dataset = get_dataset(n_valid_batches)\n    train_dataloader = DataLoader(train_dataset, shuffle=True, batch_size=batch_size, num_workers=4)\n    valid_dataloader = DataLoader(valid_dataset, shuffle=False, batch_size=batch_size, num_workers=4)\n    return (train_dataloader, valid_dataloader)\n\n\ndef train(num_epochs, model, dataloader, optimizer, accelerator, scheduler=None):\n    \"Trains for `num_epochs`\"\n    rands = []\n    for epoch in range(num_epochs):\n        # Train quickly\n        model.train()\n        for batch in dataloader:\n            x, y = batch\n            outputs = model(x)\n            loss = torch.nn.functional.mse_loss(outputs, y)\n            accelerator.backward(loss)\n            optimizer.step()\n            optimizer.zero_grad()\n        rands.append(random.random())  # Introduce some randomness\n        if scheduler is not None:\n            scheduler.step()\n    return rands\n\n\nclass DummyModel(nn.Module):\n    \"Simple model to do y=mx+b\"\n\n    def __init__(self):\n        super().__init__()\n        self.a = nn.Parameter(torch.randn(1))\n        self.b = nn.Parameter(torch.randn(1))\n\n    def forward(self, x):\n        return x * self.a + self.b\n\n\nclass CheckpointTest(unittest.TestCase):\n    def test_with_save_limit(self):\n        with tempfile.TemporaryDirectory() as tmpdir:\n            set_seed(42)\n            model = DummyModel()\n            optimizer = torch.optim.Adam(params=model.parameters(), lr=1e-3)\n            train_dataloader, valid_dataloader = dummy_dataloaders()\n            project_config = ProjectConfiguration(total_limit=1, project_dir=tmpdir, automatic_checkpoint_naming=True)\n            # Train baseline\n            accelerator = Accelerator(project_config=project_config)\n            model, optimizer, train_dataloader, valid_dataloader = accelerator.prepare(\n                model, optimizer, train_dataloader, valid_dataloader\n            )\n            # Save initial\n            accelerator.save_state()\n\n            # Save second state\n            accelerator.save_state()\n            self.assertEqual(len(os.listdir(accelerator.project_dir)), 1)\n\n    def test_can_resume_training_with_folder(self):\n        with tempfile.TemporaryDirectory() as tmpdir:\n            set_seed(42)\n            model = DummyModel()\n            optimizer = torch.optim.Adam(params=model.parameters(), lr=1e-3)\n            train_dataloader, valid_dataloader = dummy_dataloaders()\n            # Train baseline\n            accelerator = Accelerator()\n            model, optimizer, train_dataloader, valid_dataloader = accelerator.prepare(\n                model, optimizer, train_dataloader, valid_dataloader\n            )\n            # Save initial\n            initial = os.path.join(tmpdir, \"initial\")\n            accelerator.save_state(initial)\n            (a, b) = model.a.item(), model.b.item()\n            opt_state = optimizer.state_dict()\n            ground_truth_rands = train(3, model, train_dataloader, optimizer, accelerator)\n            (a1, b1) = model.a.item(), model.b.item()\n            opt_state1 = optimizer.state_dict()\n\n            # Train partially\n            set_seed(42)\n            model = DummyModel()\n            optimizer = torch.optim.Adam(params=model.parameters(), lr=1e-3)\n            train_dataloader, valid_dataloader = dummy_dataloaders()\n            accelerator = Accelerator()\n            model, optimizer, train_dataloader, valid_dataloader = accelerator.prepare(\n                model, optimizer, train_dataloader, valid_dataloader\n            )\n            accelerator.load_state(initial)\n            (a2, b2) = model.a.item(), model.b.item()\n            opt_state2 = optimizer.state_dict()\n            self.assertEqual(a, a2)\n            self.assertEqual(b, b2)\n            self.assertEqual(opt_state, opt_state2)\n\n            test_rands = train(2, model, train_dataloader, optimizer, accelerator)\n            # Save everything\n            checkpoint = os.path.join(tmpdir, \"checkpoint\")\n            accelerator.save_state(checkpoint)\n\n            # Load everything back in and make sure all states work\n            accelerator.load_state(checkpoint)\n            test_rands += train(1, model, train_dataloader, optimizer, accelerator)\n            (a3, b3) = model.a.item(), model.b.item()\n            opt_state3 = optimizer.state_dict()\n            self.assertEqual(a1, a3)\n            self.assertEqual(b1, b3)\n            self.assertEqual(opt_state1, opt_state3)\n            self.assertEqual(ground_truth_rands, test_rands)\n\n    def test_can_resume_training(self):\n        with tempfile.TemporaryDirectory() as tmpdir:\n            set_seed(42)\n            model = DummyModel()\n            optimizer = torch.optim.Adam(params=model.parameters(), lr=1e-3)\n            train_dataloader, valid_dataloader = dummy_dataloaders()\n            project_config = ProjectConfiguration(automatic_checkpoint_naming=True)\n\n            # Train baseline\n            accelerator = Accelerator(project_dir=tmpdir, project_config=project_config)\n            model, optimizer, train_dataloader, valid_dataloader = accelerator.prepare(\n                model, optimizer, train_dataloader, valid_dataloader\n            )\n            # Save initial\n            accelerator.save_state()\n            (a, b) = model.a.item(), model.b.item()\n            opt_state = optimizer.state_dict()\n            ground_truth_rands = train(3, model, train_dataloader, optimizer, accelerator)\n            (a1, b1) = model.a.item(), model.b.item()\n            opt_state1 = optimizer.state_dict()\n\n            # Train partially\n            set_seed(42)\n            model = DummyModel()\n            optimizer = torch.optim.Adam(params=model.parameters(), lr=1e-3)\n            train_dataloader, valid_dataloader = dummy_dataloaders()\n            project_config = ProjectConfiguration(iteration=1, automatic_checkpoint_naming=True)\n            accelerator = Accelerator(project_dir=tmpdir, project_config=project_config)\n            model, optimizer, train_dataloader, valid_dataloader = accelerator.prepare(\n                model, optimizer, train_dataloader, valid_dataloader\n            )\n            accelerator.load_state(os.path.join(tmpdir, \"checkpoints\", \"checkpoint_0\"))\n            (a2, b2) = model.a.item(), model.b.item()\n            opt_state2 = optimizer.state_dict()\n            self.assertEqual(a, a2)\n            self.assertEqual(b, b2)\n            self.assertEqual(opt_state, opt_state2)\n\n            test_rands = train(2, model, train_dataloader, optimizer, accelerator)\n            # Save everything\n            accelerator.save_state()\n\n            # Load everything back in and make sure all states work\n            accelerator.load_state(os.path.join(tmpdir, \"checkpoints\", \"checkpoint_1\"))\n            test_rands += train(1, model, train_dataloader, optimizer, accelerator)\n            (a3, b3) = model.a.item(), model.b.item()\n            opt_state3 = optimizer.state_dict()\n            self.assertEqual(a1, a3)\n            self.assertEqual(b1, b3)\n            self.assertEqual(opt_state1, opt_state3)\n            self.assertEqual(ground_truth_rands, test_rands)\n\n    def test_invalid_registration(self):\n        t = torch.tensor([1, 2, 3])\n        t1 = torch.tensor([2, 3, 4])\n        net = DummyModel()\n        opt = torch.optim.Adam(net.parameters())\n        accelerator = Accelerator()\n        with self.assertRaises(ValueError) as ve:\n            accelerator.register_for_checkpointing(t, t1, net, opt)\n        message = str(ve.exception)\n        self.assertTrue(\"Item at index 0\" in message)\n        self.assertTrue(\"Item at index 1\" in message)\n        self.assertFalse(\"Item at index 2\" in message)\n        self.assertFalse(\"Item at index 3\" in message)\n\n    def test_with_scheduler(self):\n        with tempfile.TemporaryDirectory() as tmpdir:\n            set_seed(42)\n            model = DummyModel()\n            optimizer = torch.optim.Adam(params=model.parameters(), lr=1e-3)\n            scheduler = torch.optim.lr_scheduler.StepLR(optimizer, step_size=1, gamma=0.99)\n            train_dataloader, valid_dataloader = dummy_dataloaders()\n            project_config = ProjectConfiguration(automatic_checkpoint_naming=True)\n            # Train baseline\n            accelerator = Accelerator(project_dir=tmpdir, project_config=project_config)\n            model, optimizer, train_dataloader, valid_dataloader, scheduler = accelerator.prepare(\n                model, optimizer, train_dataloader, valid_dataloader, scheduler\n            )\n            # Save initial\n            accelerator.save_state()\n            scheduler_state = scheduler.state_dict()\n            train(3, model, train_dataloader, optimizer, accelerator, scheduler)\n            self.assertNotEqual(scheduler_state, scheduler.state_dict())\n\n            # Load everything back in and make sure all states work\n            accelerator.load_state(os.path.join(tmpdir, \"checkpoints\", \"checkpoint_0\"))\n            self.assertEqual(scheduler_state, scheduler.state_dict())\n\n    def test_automatic_loading(self):\n        with tempfile.TemporaryDirectory() as tmpdir:\n            set_seed(42)\n            model = DummyModel()\n            optimizer = torch.optim.Adam(params=model.parameters(), lr=1e-3)\n            scheduler = torch.optim.lr_scheduler.StepLR(optimizer, step_size=1, gamma=0.99)\n            train_dataloader, valid_dataloader = dummy_dataloaders()\n            project_config = ProjectConfiguration(automatic_checkpoint_naming=True)\n            # Train baseline\n            accelerator = Accelerator(project_dir=tmpdir, project_config=project_config)\n            model, optimizer, train_dataloader, valid_dataloader, scheduler = accelerator.prepare(\n                model, optimizer, train_dataloader, valid_dataloader, scheduler\n            )\n            # Save initial\n            accelerator.save_state()\n            train(2, model, train_dataloader, optimizer, accelerator, scheduler)\n            (a2, b2) = model.a.item(), model.b.item()\n            # Save a first time\n            accelerator.save_state()\n            train(1, model, train_dataloader, optimizer, accelerator, scheduler)\n            (a3, b3) = model.a.item(), model.b.item()\n\n            # Load back in the last saved checkpoint, should point to a2, b2\n            accelerator.load_state()\n            self.assertNotEqual(a3, model.a.item())\n            self.assertNotEqual(b3, model.b.item())\n            self.assertEqual(a2, model.a.item())\n            self.assertEqual(b2, model.b.item())\n\n    def test_checkpoint_deletion(self):\n        with tempfile.TemporaryDirectory() as tmpdir:\n            set_seed(42)\n            model = DummyModel()\n            project_config = ProjectConfiguration(automatic_checkpoint_naming=True, total_limit=2)\n            # Train baseline\n            accelerator = Accelerator(project_dir=tmpdir, project_config=project_config)\n            model = accelerator.prepare(model)\n            # Save 3 states:\n            for _ in range(11):\n                accelerator.save_state()\n            self.assertTrue(not os.path.exists(os.path.join(tmpdir, \"checkpoints\", \"checkpoint_0\")))\n            self.assertTrue(os.path.exists(os.path.join(tmpdir, \"checkpoints\", \"checkpoint_9\")))\n            self.assertTrue(os.path.exists(os.path.join(tmpdir, \"checkpoints\", \"checkpoint_10\")))\n\n    @require_cuda\n    def test_map_location(self):\n        cmd = [\"torchrun\", f\"--nproc_per_node={torch.cuda.device_count()}\", inspect.getfile(self.__class__)]\n        execute_subprocess_async(cmd, env=os.environ.copy())\n\n\nif __name__ == \"__main__\":\n    savedir = \"/tmp/accelerate/state_checkpointing\"\n    model = DummyModel()\n    optimizer = torch.optim.Adam(params=model.parameters(), lr=1e-3)\n    scheduler = torch.optim.lr_scheduler.StepLR(optimizer, step_size=1, gamma=0.99)\n    train_dataloader, valid_dataloader = dummy_dataloaders()\n    project_config = ProjectConfiguration(automatic_checkpoint_naming=True)\n    # Train baseline\n    accelerator = Accelerator(project_dir=savedir, project_config=project_config, mixed_precision=\"no\")\n    if accelerator.process_index == 0:\n        if os.path.exists(savedir):\n            shutil.rmtree(savedir)\n        os.makedirs(savedir)\n    model, optimizer, train_dataloader, valid_dataloader, scheduler = accelerator.prepare(\n        model, optimizer, train_dataloader, valid_dataloader, scheduler\n    )\n    model, optimizer = accelerator.prepare(model, optimizer)\n    train(3, model, train_dataloader, optimizer, accelerator, scheduler)\n    # Check that the intial optimizer is loaded on the GPU\n    for group in optimizer.param_groups:\n        param_device = group[\"params\"][0].device\n        break\n    assert param_device.type == accelerator.device.type\n    model = model.cpu()\n    accelerator.wait_for_everyone()\n    accelerator.save_state()\n    accelerator.wait_for_everyone()\n\n    # Check CPU state\n    accelerator.load_state(os.path.join(savedir, \"checkpoints\", \"checkpoint_0\"), map_location=\"cpu\")\n    for group in optimizer.param_groups:\n        param_device = group[\"params\"][0].device\n        break\n    assert (\n        param_device.type == torch.device(\"cpu\").type\n    ), f\"Loaded optimizer states did not match, expected to be loaded on the CPU but got {param_device}\"\n\n    # Check device state\n    model.to(accelerator.device)\n    accelerator.load_state(os.path.join(savedir, \"checkpoints\", \"checkpoint_0\"), map_location=\"on_device\")\n    for group in optimizer.param_groups:\n        param_device = group[\"params\"][0].device\n        break\n    assert (\n        param_device.type == accelerator.device.type\n    ), f\"Loaded optimizer states did not match, expected to be loaded on {accelerator.device} but got {param_device}\"\n\n    # Check error\n    with pytest.raises(TypeError, match=\"Unsupported optimizer map location passed\"):\n        accelerator.load_state(os.path.join(savedir, \"checkpoints\", \"checkpoint_0\"), map_location=\"invalid\")\n    accelerator.wait_for_everyone()\n    if accelerator.process_index == 0:\n        shutil.rmtree(savedir)\n    accelerator.wait_for_everyone()\n", "# Copyright 2021 The HuggingFace Team. All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport inspect\nimport os\nimport unittest\n\nimport torch\n\nimport accelerate\nfrom accelerate import debug_launcher\nfrom accelerate.test_utils import (\n    execute_subprocess_async,\n    require_cpu,\n    require_huggingface_suite,\n    require_multi_gpu,\n    require_single_gpu,\n)\nfrom accelerate.utils import patch_environment\n\n\n@require_huggingface_suite\nclass MetricTester(unittest.TestCase):\n    def setUp(self):\n        mod_file = inspect.getfile(accelerate.test_utils)\n        self.test_file_path = os.path.sep.join(\n            mod_file.split(os.path.sep)[:-1] + [\"scripts\", \"external_deps\", \"test_metrics.py\"]\n        )\n\n        from accelerate.test_utils.scripts.external_deps import test_metrics  # noqa: F401\n\n        self.test_metrics = test_metrics\n\n    @require_cpu\n    def test_metric_cpu_noop(self):\n        debug_launcher(self.test_metrics.main, num_processes=1)\n\n    @require_cpu\n    def test_metric_cpu_multi(self):\n        debug_launcher(self.test_metrics.main)\n\n    @require_single_gpu\n    def test_metric_gpu(self):\n        self.test_metrics.main()\n\n    @require_multi_gpu\n    def test_metric_gpu_multi(self):\n        print(f\"Found {torch.cuda.device_count()} devices.\")\n        cmd = [\"torchrun\", f\"--nproc_per_node={torch.cuda.device_count()}\", self.test_file_path]\n        with patch_environment(omp_num_threads=1):\n            execute_subprocess_async(cmd, env=os.environ.copy())\n", "{\n    \"fp16\": {\n        \"enabled\": \"auto\",\n        \"loss_scale\": 0,\n        \"loss_scale_window\": 1000,\n        \"initial_scale_power\": 16,\n        \"hysteresis\": 2,\n        \"min_loss_scale\": 1\n    },\n    \"bf16\": {\n        \"enabled\": \"auto\"\n    },\n    \"optimizer\": {\n        \"type\": \"AdamW\",\n        \"params\": {\n            \"lr\": \"auto\",\n            \"weight_decay\": \"auto\",\n            \"torch_adam\": true,\n            \"adam_w_mode\": true\n        }\n    },\n    \"scheduler\": {\n        \"type\": \"WarmupLR\",\n        \"params\": {\n            \"warmup_min_lr\": \"auto\",\n            \"warmup_max_lr\": \"auto\",\n            \"warmup_num_steps\": \"auto\"\n        }\n    },\n    \"zero_optimization\": {\n        \"stage\": 2,\n        \"offload_optimizer\": {\n            \"device\": \"cpu\",\n            \"pin_memory\": true\n        },\n        \"allgather_partitions\": true,\n        \"allgather_bucket_size\": 2e8,\n        \"overlap_comm\": true,\n        \"reduce_scatter\": true,\n        \"reduce_bucket_size\": \"auto\",\n        \"contiguous_gradients\": true\n    },\n    \"gradient_accumulation_steps\": 1,\n    \"gradient_clipping\": \"auto\",\n    \"steps_per_print\": 2000,\n    \"train_batch_size\": \"auto\",\n    \"train_micro_batch_size_per_gpu\": \"auto\",\n    \"wall_clock_breakdown\": false\n}", "# Copyright 2022 The HuggingFace Team. All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport inspect\nimport io\nimport itertools\nimport json\nimport os\nimport tempfile\nfrom copy import deepcopy\nfrom pathlib import Path\n\nimport torch\nfrom parameterized import parameterized\nfrom torch.utils.data import DataLoader\nfrom transformers import AutoModel, AutoModelForCausalLM, get_scheduler\nfrom transformers.testing_utils import mockenv_context\nfrom transformers.trainer_utils import set_seed\nfrom transformers.utils import is_torch_bf16_available\n\nimport accelerate\nfrom accelerate.accelerator import Accelerator\nfrom accelerate.scheduler import AcceleratedScheduler\nfrom accelerate.state import AcceleratorState\nfrom accelerate.test_utils.testing import (\n    AccelerateTestCase,\n    TempDirTestCase,\n    execute_subprocess_async,\n    require_cuda,\n    require_deepspeed,\n    require_multi_gpu,\n    slow,\n)\nfrom accelerate.test_utils.training import RegressionDataset\nfrom accelerate.utils.dataclasses import DeepSpeedPlugin\nfrom accelerate.utils.deepspeed import (\n    DeepSpeedEngineWrapper,\n    DeepSpeedOptimizerWrapper,\n    DeepSpeedSchedulerWrapper,\n    DummyOptim,\n    DummyScheduler,\n)\nfrom accelerate.utils.other import patch_environment\n\n\nset_seed(42)\n\nT5_SMALL = \"t5-small\"\nT5_TINY = \"patrickvonplaten/t5-tiny-random\"\nGPT2_TINY = \"sshleifer/tiny-gpt2\"\n\nZERO2 = \"zero2\"\nZERO3 = \"zero3\"\n\nFP16 = \"fp16\"\nBF16 = \"bf16\"\n\nCUSTOM_OPTIMIZER = \"custom_optimizer\"\nCUSTOM_SCHEDULER = \"custom_scheduler\"\nDS_OPTIMIZER = \"deepspeed_optimizer\"\nDS_SCHEDULER = \"deepspeed_scheduler\"\n\nstages = [ZERO2, ZERO3]\noptims = [CUSTOM_OPTIMIZER, DS_OPTIMIZER]\nschedulers = [CUSTOM_SCHEDULER, DS_SCHEDULER]\nif is_torch_bf16_available():\n    dtypes = [FP16, BF16]\nelse:\n    dtypes = [FP16]\n\n\ndef parameterized_custom_name_func(func, param_num, param):\n    # customize the test name generator function as we want both params to appear in the sub-test\n    # name, as by default it shows only the first param\n    param_based_name = parameterized.to_safe_name(\"_\".join(str(x) for x in param.args))\n    return f\"{func.__name__}_{param_based_name}\"\n\n\n# Cartesian-product of zero stages with models to test\nparams = list(itertools.product(stages, dtypes))\noptim_scheduler_params = list(itertools.product(optims, schedulers))\n\n\n@require_deepspeed\n@require_cuda\nclass DeepSpeedConfigIntegration(AccelerateTestCase):\n    def setUp(self):\n        super().setUp()\n\n        self._test_file_path = inspect.getfile(self.__class__)\n        path = Path(self._test_file_path).resolve()\n        self.test_file_dir_str = str(path.parents[0])\n\n        self.ds_config_file = dict(\n            zero2=f\"{self.test_file_dir_str}/ds_config_zero2.json\",\n            zero3=f\"{self.test_file_dir_str}/ds_config_zero3.json\",\n        )\n\n        # use self.get_config_dict(stage) to use these to ensure the original is not modified\n        with io.open(self.ds_config_file[ZERO2], \"r\", encoding=\"utf-8\") as f:\n            config_zero2 = json.load(f)\n        with io.open(self.ds_config_file[ZERO3], \"r\", encoding=\"utf-8\") as f:\n            config_zero3 = json.load(f)\n            # The following setting slows things down, so don't enable it by default unless needed by a test.\n            # It's in the file as a demo for users since we want everything to work out of the box even if slower.\n            config_zero3[\"zero_optimization\"][\"stage3_gather_16bit_weights_on_model_save\"] = False\n\n        self.ds_config_dict = dict(zero2=config_zero2, zero3=config_zero3)\n\n        self.dist_env = dict(\n            ACCELERATE_USE_DEEPSPEED=\"true\",\n            MASTER_ADDR=\"localhost\",\n            MASTER_PORT=\"10999\",\n            RANK=\"0\",\n            LOCAL_RANK=\"0\",\n            WORLD_SIZE=\"1\",\n        )\n\n    def get_config_dict(self, stage):\n        # As some tests modify the dict, always make a copy\n        return deepcopy(self.ds_config_dict[stage])\n\n    @parameterized.expand(stages, name_func=parameterized_custom_name_func)\n    def test_deepspeed_plugin(self, stage):\n        # Test zero3_init_flag will be set to False when ZeRO stage != 3\n        deepspeed_plugin = DeepSpeedPlugin(\n            gradient_accumulation_steps=1,\n            gradient_clipping=1.0,\n            zero_stage=2,\n            offload_optimizer_device=\"cpu\",\n            offload_param_device=\"cpu\",\n            zero3_save_16bit_model=True,\n            zero3_init_flag=True,\n        )\n        self.assertFalse(deepspeed_plugin.zero3_init_flag)\n        deepspeed_plugin.deepspeed_config = None\n\n        # Test zero3_init_flag will be set to True only when ZeRO stage == 3\n        deepspeed_plugin = DeepSpeedPlugin(\n            gradient_accumulation_steps=1,\n            gradient_clipping=1.0,\n            zero_stage=3,\n            offload_optimizer_device=\"cpu\",\n            offload_param_device=\"cpu\",\n            zero3_save_16bit_model=True,\n            zero3_init_flag=True,\n        )\n        self.assertTrue(deepspeed_plugin.zero3_init_flag)\n        deepspeed_plugin.deepspeed_config = None\n\n        # Test config files are loaded correctly\n        deepspeed_plugin = DeepSpeedPlugin(hf_ds_config=self.ds_config_file[stage], zero3_init_flag=True)\n        if stage == ZERO2:\n            self.assertFalse(deepspeed_plugin.zero3_init_flag)\n        elif stage == ZERO3:\n            self.assertTrue(deepspeed_plugin.zero3_init_flag)\n\n        # Test `gradient_accumulation_steps` is set to 1 if unavailable in config file\n        with tempfile.TemporaryDirectory() as dirpath:\n            ds_config = self.get_config_dict(stage)\n            del ds_config[\"gradient_accumulation_steps\"]\n            with open(os.path.join(dirpath, \"ds_config.json\"), \"w\") as out_file:\n                json.dump(ds_config, out_file)\n            deepspeed_plugin = DeepSpeedPlugin(hf_ds_config=os.path.join(dirpath, \"ds_config.json\"))\n            self.assertEqual(deepspeed_plugin.deepspeed_config[\"gradient_accumulation_steps\"], 1)\n            deepspeed_plugin.deepspeed_config = None\n\n        # Test `ValueError` is raised if `zero_optimization` is unavailable in config file\n        with tempfile.TemporaryDirectory() as dirpath:\n            ds_config = self.get_config_dict(stage)\n            del ds_config[\"zero_optimization\"]\n            with open(os.path.join(dirpath, \"ds_config.json\"), \"w\") as out_file:\n                json.dump(ds_config, out_file)\n            with self.assertRaises(ValueError) as cm:\n                deepspeed_plugin = DeepSpeedPlugin(hf_ds_config=os.path.join(dirpath, \"ds_config.json\"))\n            self.assertTrue(\n                \"Please specify the ZeRO optimization config in the DeepSpeed config.\" in str(cm.exception)\n            )\n            deepspeed_plugin.deepspeed_config = None\n\n        # Test `deepspeed_config_process`\n        deepspeed_plugin = DeepSpeedPlugin(hf_ds_config=self.ds_config_file[stage])\n        kwargs = {\n            \"fp16.enabled\": True,\n            \"bf16.enabled\": False,\n            \"optimizer.params.lr\": 5e-5,\n            \"optimizer.params.weight_decay\": 0.0,\n            \"scheduler.params.warmup_min_lr\": 0.0,\n            \"scheduler.params.warmup_max_lr\": 5e-5,\n            \"scheduler.params.warmup_num_steps\": 0,\n            \"train_micro_batch_size_per_gpu\": 16,\n            \"gradient_clipping\": 1.0,\n            \"train_batch_size\": 16,\n            \"zero_optimization.reduce_bucket_size\": 5e5,\n            \"zero_optimization.stage3_prefetch_bucket_size\": 5e5,\n            \"zero_optimization.stage3_param_persistence_threshold\": 5e5,\n            \"zero_optimization.stage3_gather_16bit_weights_on_model_save\": False,\n        }\n        deepspeed_plugin.deepspeed_config_process(**kwargs)\n        for ds_key_long, value in kwargs.items():\n            config, ds_key = deepspeed_plugin.hf_ds_config.find_config_node(ds_key_long)\n            if config.get(ds_key) is not None:\n                self.assertEqual(config.get(ds_key), value)\n\n        # Test mismatches\n        mismatches = {\n            \"optimizer.params.lr\": 1e-5,\n            \"optimizer.params.weight_decay\": 1e-5,\n            \"gradient_accumulation_steps\": 2,\n        }\n        with self.assertRaises(ValueError) as cm:\n            new_kwargs = deepcopy(kwargs)\n            new_kwargs.update(mismatches)\n            deepspeed_plugin.deepspeed_config_process(**new_kwargs)\n        for key in mismatches.keys():\n            self.assertTrue(\n                key in str(cm.exception),\n                f\"{key} is not in the exception message:\\n{cm.exception}\",\n            )\n\n        # Test `ValueError` is raised if some config file fields with `auto` value is missing in `kwargs`\n        deepspeed_plugin.deepspeed_config[\"optimizer\"][\"params\"][\"lr\"] = \"auto\"\n        with self.assertRaises(ValueError) as cm:\n            del kwargs[\"optimizer.params.lr\"]\n            deepspeed_plugin.deepspeed_config_process(**kwargs)\n        self.assertTrue(\"`optimizer.params.lr` not found in kwargs.\" in str(cm.exception))\n\n    @parameterized.expand([FP16, BF16], name_func=parameterized_custom_name_func)\n    def test_accelerate_state_deepspeed(self, dtype):\n        AcceleratorState._reset_state(True)\n        deepspeed_plugin = DeepSpeedPlugin(\n            gradient_accumulation_steps=1,\n            gradient_clipping=1.0,\n            zero_stage=ZERO2,\n            offload_optimizer_device=\"cpu\",\n            offload_param_device=\"cpu\",\n            zero3_save_16bit_model=True,\n            zero3_init_flag=True,\n        )\n        with mockenv_context(**self.dist_env):\n            state = Accelerator(mixed_precision=dtype, deepspeed_plugin=deepspeed_plugin).state\n            self.assertTrue(state.deepspeed_plugin.deepspeed_config[dtype][\"enabled\"])\n\n    def test_init_zero3(self):\n        deepspeed_plugin = DeepSpeedPlugin(\n            gradient_accumulation_steps=1,\n            gradient_clipping=1.0,\n            zero_stage=3,\n            offload_optimizer_device=\"cpu\",\n            offload_param_device=\"cpu\",\n            zero3_save_16bit_model=True,\n            zero3_init_flag=True,\n        )\n\n        with mockenv_context(**self.dist_env):\n            accelerator = Accelerator(deepspeed_plugin=deepspeed_plugin)  # noqa: F841\n            from transformers.deepspeed import is_deepspeed_zero3_enabled\n\n            self.assertTrue(is_deepspeed_zero3_enabled())\n\n    @parameterized.expand(optim_scheduler_params, name_func=parameterized_custom_name_func)\n    def test_prepare_deepspeed(self, optim_type, scheduler_type):\n        # 1. Testing with one of the ZeRO Stages is enough to test the `_prepare_deepspeed` function.\n        # Here we test using ZeRO Stage 2 with FP16 enabled.\n        from deepspeed.runtime.engine import DeepSpeedEngine\n\n        kwargs = {\n            \"optimizer.params.lr\": 5e-5,\n            \"optimizer.params.weight_decay\": 0.0,\n            \"scheduler.params.warmup_min_lr\": 0.0,\n            \"scheduler.params.warmup_max_lr\": 5e-5,\n            \"scheduler.params.warmup_num_steps\": 0,\n            \"train_micro_batch_size_per_gpu\": 16,\n            \"gradient_clipping\": 1.0,\n            \"train_batch_size\": 16,\n            \"zero_optimization.reduce_bucket_size\": 5e5,\n            \"zero_optimization.stage3_prefetch_bucket_size\": 5e5,\n            \"zero_optimization.stage3_param_persistence_threshold\": 5e5,\n            \"zero_optimization.stage3_gather_16bit_weights_on_model_save\": False,\n        }\n\n        if optim_type == CUSTOM_OPTIMIZER and scheduler_type == CUSTOM_SCHEDULER:\n            # Test custom optimizer + custom scheduler\n            deepspeed_plugin = DeepSpeedPlugin(\n                gradient_accumulation_steps=1,\n                gradient_clipping=1.0,\n                zero_stage=2,\n                offload_optimizer_device=\"cpu\",\n                offload_param_device=\"cpu\",\n                zero3_save_16bit_model=False,\n                zero3_init_flag=False,\n            )\n            with mockenv_context(**self.dist_env):\n                accelerator = Accelerator(mixed_precision=\"fp16\", deepspeed_plugin=deepspeed_plugin)\n\n                train_set = RegressionDataset(length=80)\n                eval_set = RegressionDataset(length=20)\n                train_dataloader = DataLoader(train_set, batch_size=16, shuffle=True)\n                eval_dataloader = DataLoader(eval_set, batch_size=32, shuffle=False)\n                model = AutoModel.from_pretrained(GPT2_TINY)\n                optimizer = torch.optim.AdamW(model.parameters(), lr=5e-5)\n                lr_scheduler = get_scheduler(\n                    name=\"linear\",\n                    optimizer=optimizer,\n                    num_warmup_steps=0,\n                    num_training_steps=1000,\n                )\n                dummy_optimizer = DummyOptim(params=model.parameters())\n                dummy_lr_scheduler = DummyScheduler(dummy_optimizer)\n\n                with self.assertRaises(ValueError) as cm:\n                    model, optimizer, train_dataloader, eval_dataloader, lr_scheduler = accelerator.prepare(\n                        model, dummy_optimizer, train_dataloader, eval_dataloader, lr_scheduler\n                    )\n                self.assertTrue(\n                    \"You cannot create a `DummyOptim` without specifying an optimizer in the config file.\"\n                    in str(cm.exception)\n                )\n                with self.assertRaises(ValueError) as cm:\n                    model, optimizer, train_dataloader, eval_dataloader, lr_scheduler = accelerator.prepare(\n                        model, optimizer, train_dataloader, eval_dataloader, dummy_lr_scheduler\n                    )\n                self.assertTrue(\n                    \"You cannot create a `DummyScheduler` without specifying a scheduler in the config file.\"\n                    in str(cm.exception)\n                )\n\n                with self.assertRaises(ValueError) as cm:\n                    model, optimizer, lr_scheduler = accelerator.prepare(model, optimizer, lr_scheduler)\n                self.assertTrue(\n                    \"When using DeepSpeed `accelerate.prepare()` requires you to pass at least one of training or evaluation dataloaders \"\n                    \"or alternatively set an integer value in `train_micro_batch_size_per_gpu` in the deepspeed config file\"\n                    \"or assign integer value to `AcceleratorState().deepspeed_plugin.deepspeed_config['train_micro_batch_size_per_gpu']`.\"\n                    in str(cm.exception)\n                )\n\n                model, optimizer, train_dataloader, eval_dataloader, lr_scheduler = accelerator.prepare(\n                    model, optimizer, train_dataloader, eval_dataloader, lr_scheduler\n                )\n                self.assertTrue(accelerator.deepspeed_config[\"zero_allow_untested_optimizer\"])\n                self.assertTrue(accelerator.deepspeed_config[\"train_batch_size\"], 16)\n                self.assertEqual(type(model), DeepSpeedEngine)\n                self.assertEqual(type(optimizer), DeepSpeedOptimizerWrapper)\n                self.assertEqual(type(lr_scheduler), AcceleratedScheduler)\n                self.assertEqual(type(accelerator.deepspeed_engine_wrapped), DeepSpeedEngineWrapper)\n\n        elif optim_type == DS_OPTIMIZER and scheduler_type == DS_SCHEDULER:\n            # Test DeepSpeed optimizer + DeepSpeed scheduler\n            deepspeed_plugin = DeepSpeedPlugin(hf_ds_config=self.ds_config_file[ZERO2])\n            with mockenv_context(**self.dist_env):\n                accelerator = Accelerator(deepspeed_plugin=deepspeed_plugin, mixed_precision=\"fp16\")\n                train_set = RegressionDataset(length=80)\n                eval_set = RegressionDataset(length=20)\n                train_dataloader = DataLoader(train_set, batch_size=10, shuffle=True)\n                eval_dataloader = DataLoader(eval_set, batch_size=5, shuffle=False)\n                model = AutoModel.from_pretrained(GPT2_TINY)\n                optimizer = torch.optim.AdamW(model.parameters(), lr=5e-5)\n                lr_scheduler = get_scheduler(\n                    name=\"linear\",\n                    optimizer=optimizer,\n                    num_warmup_steps=0,\n                    num_training_steps=1000,\n                )\n                dummy_optimizer = DummyOptim(params=model.parameters())\n                dummy_lr_scheduler = DummyScheduler(dummy_optimizer)\n                kwargs[\"train_batch_size\"] = (\n                    kwargs[\"train_micro_batch_size_per_gpu\"]\n                    * deepspeed_plugin.deepspeed_config[\"gradient_accumulation_steps\"]\n                    * accelerator.num_processes\n                )\n                accelerator.state.deepspeed_plugin.deepspeed_config_process(**kwargs)\n                with self.assertRaises(ValueError) as cm:\n                    model, optimizer, train_dataloader, eval_dataloader, lr_scheduler = accelerator.prepare(\n                        model, optimizer, train_dataloader, eval_dataloader, dummy_lr_scheduler\n                    )\n                self.assertTrue(\n                    \"You cannot specify an optimizer in the config file and in the code at the same time\"\n                    in str(cm.exception)\n                )\n\n                with self.assertRaises(ValueError) as cm:\n                    model, optimizer, train_dataloader, eval_dataloader, lr_scheduler = accelerator.prepare(\n                        model, dummy_optimizer, train_dataloader, eval_dataloader, lr_scheduler\n                    )\n                self.assertTrue(\n                    \"You cannot specify a scheduler in the config file and in the code at the same time\"\n                    in str(cm.exception)\n                )\n\n                with self.assertRaises(ValueError) as cm:\n                    model, optimizer, train_dataloader, eval_dataloader, lr_scheduler = accelerator.prepare(\n                        model, dummy_optimizer, train_dataloader, eval_dataloader, lr_scheduler\n                    )\n                self.assertTrue(\n                    \"You cannot specify a scheduler in the config file and in the code at the same time\"\n                    in str(cm.exception)\n                )\n\n                model, optimizer, train_dataloader, eval_dataloader, lr_scheduler = accelerator.prepare(\n                    model, dummy_optimizer, train_dataloader, eval_dataloader, dummy_lr_scheduler\n                )\n                self.assertTrue(type(model) == DeepSpeedEngine)\n                self.assertTrue(type(optimizer) == DeepSpeedOptimizerWrapper)\n                self.assertTrue(type(lr_scheduler) == DeepSpeedSchedulerWrapper)\n                self.assertTrue(type(accelerator.deepspeed_engine_wrapped) == DeepSpeedEngineWrapper)\n\n        elif optim_type == CUSTOM_OPTIMIZER and scheduler_type == DS_SCHEDULER:\n            # Test custom optimizer + DeepSpeed scheduler\n            deepspeed_plugin = DeepSpeedPlugin(hf_ds_config=self.ds_config_file[ZERO2])\n            with mockenv_context(**self.dist_env):\n                accelerator = Accelerator(deepspeed_plugin=deepspeed_plugin, mixed_precision=\"fp16\")\n                train_set = RegressionDataset(length=80)\n                eval_set = RegressionDataset(length=20)\n                train_dataloader = DataLoader(train_set, batch_size=10, shuffle=True)\n                eval_dataloader = DataLoader(eval_set, batch_size=5, shuffle=False)\n                model = AutoModel.from_pretrained(GPT2_TINY)\n                optimizer = torch.optim.AdamW(model.parameters(), lr=5e-5)\n                lr_scheduler = get_scheduler(\n                    name=\"linear\",\n                    optimizer=optimizer,\n                    num_warmup_steps=0,\n                    num_training_steps=1000,\n                )\n                dummy_optimizer = DummyOptim(params=model.parameters())\n                dummy_lr_scheduler = DummyScheduler(dummy_optimizer)\n                kwargs[\"train_batch_size\"] = (\n                    kwargs[\"train_micro_batch_size_per_gpu\"]\n                    * deepspeed_plugin.deepspeed_config[\"gradient_accumulation_steps\"]\n                    * accelerator.num_processes\n                )\n                accelerator.state.deepspeed_plugin.deepspeed_config_process(**kwargs)\n                del accelerator.state.deepspeed_plugin.deepspeed_config[\"optimizer\"]\n                model, optimizer, train_dataloader, eval_dataloader, lr_scheduler = accelerator.prepare(\n                    model, optimizer, train_dataloader, eval_dataloader, dummy_lr_scheduler\n                )\n                self.assertTrue(type(model) == DeepSpeedEngine)\n                self.assertTrue(type(optimizer) == DeepSpeedOptimizerWrapper)\n                self.assertTrue(type(lr_scheduler) == DeepSpeedSchedulerWrapper)\n                self.assertTrue(type(accelerator.deepspeed_engine_wrapped) == DeepSpeedEngineWrapper)\n        elif optim_type == DS_OPTIMIZER and scheduler_type == CUSTOM_SCHEDULER:\n            # Test deepspeed optimizer + custom scheduler\n            deepspeed_plugin = DeepSpeedPlugin(hf_ds_config=self.ds_config_file[ZERO2])\n            with mockenv_context(**self.dist_env):\n                accelerator = Accelerator(deepspeed_plugin=deepspeed_plugin, mixed_precision=\"fp16\")\n                train_set = RegressionDataset(length=80)\n                eval_set = RegressionDataset(length=20)\n                train_dataloader = DataLoader(train_set, batch_size=10, shuffle=True)\n                eval_dataloader = DataLoader(eval_set, batch_size=5, shuffle=False)\n                model = AutoModel.from_pretrained(GPT2_TINY)\n                optimizer = torch.optim.AdamW(model.parameters(), lr=5e-5)\n                lr_scheduler = get_scheduler(\n                    name=\"linear\",\n                    optimizer=optimizer,\n                    num_warmup_steps=0,\n                    num_training_steps=1000,\n                )\n                dummy_optimizer = DummyOptim(params=model.parameters())\n                dummy_lr_scheduler = DummyScheduler(dummy_optimizer)\n                kwargs[\"train_batch_size\"] = (\n                    kwargs[\"train_micro_batch_size_per_gpu\"]\n                    * deepspeed_plugin.deepspeed_config[\"gradient_accumulation_steps\"]\n                    * accelerator.num_processes\n                )\n                accelerator.state.deepspeed_plugin.deepspeed_config_process(**kwargs)\n                del accelerator.state.deepspeed_plugin.deepspeed_config[\"scheduler\"]\n                with self.assertRaises(ValueError) as cm:\n                    model, optimizer, train_dataloader, eval_dataloader, lr_scheduler = accelerator.prepare(\n                        model, dummy_optimizer, train_dataloader, eval_dataloader, lr_scheduler\n                    )\n                self.assertTrue(\n                    \"You can only specify `accelerate.utils.DummyScheduler` in the code when using `accelerate.utils.DummyOptim`.\"\n                    in str(cm.exception)\n                )\n\n    def test_save_checkpoints(self):\n        deepspeed_plugin = DeepSpeedPlugin(\n            hf_ds_config=self.ds_config_file[ZERO3],\n            zero3_init_flag=True,\n        )\n        del deepspeed_plugin.deepspeed_config[\"bf16\"]\n        kwargs = {\n            \"optimizer.params.lr\": 5e-5,\n            \"optimizer.params.weight_decay\": 0.0,\n            \"scheduler.params.warmup_min_lr\": 0.0,\n            \"scheduler.params.warmup_max_lr\": 5e-5,\n            \"scheduler.params.warmup_num_steps\": 0,\n            \"train_micro_batch_size_per_gpu\": 16,\n            \"gradient_clipping\": 1.0,\n            \"train_batch_size\": 16,\n            \"zero_optimization.reduce_bucket_size\": 5e5,\n            \"zero_optimization.stage3_prefetch_bucket_size\": 5e5,\n            \"zero_optimization.stage3_param_persistence_threshold\": 5e5,\n            \"zero_optimization.stage3_gather_16bit_weights_on_model_save\": False,\n        }\n\n        with mockenv_context(**self.dist_env):\n            accelerator = Accelerator(deepspeed_plugin=deepspeed_plugin, mixed_precision=\"fp16\")\n            kwargs[\"train_batch_size\"] = (\n                kwargs[\"train_micro_batch_size_per_gpu\"]\n                * deepspeed_plugin.deepspeed_config[\"gradient_accumulation_steps\"]\n                * accelerator.num_processes\n            )\n            accelerator.state.deepspeed_plugin.deepspeed_config_process(**kwargs)\n\n            train_set = RegressionDataset(length=80)\n            eval_set = RegressionDataset(length=20)\n            train_dataloader = DataLoader(train_set, batch_size=16, shuffle=True)\n            eval_dataloader = DataLoader(eval_set, batch_size=32, shuffle=False)\n            model = AutoModelForCausalLM.from_pretrained(\"gpt2\")\n            dummy_optimizer = DummyOptim(params=model.parameters())\n            dummy_lr_scheduler = DummyScheduler(dummy_optimizer)\n\n            model, _, train_dataloader, eval_dataloader, _ = accelerator.prepare(\n                model, dummy_optimizer, train_dataloader, eval_dataloader, dummy_lr_scheduler\n            )\n            with self.assertRaises(ValueError) as cm:\n                accelerator.get_state_dict(model)\n            msg = (\n                \"Cannot get 16bit model weights because `stage3_gather_16bit_weights_on_model_save` in DeepSpeed config is False. \"\n                \"To save the model weights in 16bit, set `stage3_gather_16bit_weights_on_model_save` to True in DeepSpeed config file or \"\n                \"set `zero3_save_16bit_model` to True when using `accelerate config`. \"\n                \"To save the full checkpoint, run `model.save_checkpoint(save_dir)` and use `zero_to_fp32.py` to recover weights.\"\n            )\n            self.assertTrue(msg in str(cm.exception))\n\n    def test_autofill_dsconfig(self):\n        deepspeed_plugin = DeepSpeedPlugin(\n            hf_ds_config=self.ds_config_file[ZERO3],\n            zero3_init_flag=True,\n        )\n        del deepspeed_plugin.deepspeed_config[\"bf16\"]\n        del deepspeed_plugin.deepspeed_config[\"fp16\"]\n\n        with mockenv_context(**self.dist_env):\n            accelerator = Accelerator(deepspeed_plugin=deepspeed_plugin)\n            train_set = RegressionDataset(length=80)\n            eval_set = RegressionDataset(length=20)\n            train_dataloader = DataLoader(train_set, batch_size=16, shuffle=True)\n            eval_dataloader = DataLoader(eval_set, batch_size=32, shuffle=False)\n            model = AutoModelForCausalLM.from_pretrained(\"gpt2\")\n            dummy_optimizer = DummyOptim(params=model.parameters(), lr=5e-5, weight_decay=1e-4)\n            dummy_lr_scheduler = DummyScheduler(dummy_optimizer, warmup_num_steps=10, total_num_steps=1000)\n            hidden_size = model.config.hidden_size\n            model, _, train_dataloader, eval_dataloader, _ = accelerator.prepare(\n                model, dummy_optimizer, train_dataloader, eval_dataloader, dummy_lr_scheduler\n            )\n            self.assertEqual(accelerator.deepspeed_config[\"train_micro_batch_size_per_gpu\"], 16)\n            self.assertEqual(accelerator.deepspeed_config[\"train_batch_size\"], 16)\n\n            self.assertEqual(accelerator.deepspeed_config[\"optimizer\"][\"params\"][\"lr\"], 5e-5)\n            self.assertEqual(accelerator.deepspeed_config[\"optimizer\"][\"params\"][\"weight_decay\"], 1e-4)\n\n            self.assertEqual(accelerator.deepspeed_config[\"scheduler\"][\"params\"][\"warmup_min_lr\"], 0.0)\n            self.assertEqual(accelerator.deepspeed_config[\"scheduler\"][\"params\"][\"warmup_max_lr\"], 5e-5)\n            self.assertEqual(accelerator.deepspeed_config[\"scheduler\"][\"params\"][\"warmup_num_steps\"], 10)\n\n            self.assertEqual(accelerator.deepspeed_config[\"gradient_clipping\"], 1.0)\n            self.assertEqual(\n                accelerator.deepspeed_config[\"zero_optimization\"][\"reduce_bucket_size\"], hidden_size * hidden_size\n            )\n            self.assertEqual(\n                accelerator.deepspeed_config[\"zero_optimization\"][\"stage3_prefetch_bucket_size\"],\n                0.9 * hidden_size * hidden_size,\n            )\n            self.assertEqual(\n                accelerator.deepspeed_config[\"zero_optimization\"][\"stage3_param_persistence_threshold\"],\n                10 * hidden_size,\n            )\n            self.assertFalse(\n                accelerator.deepspeed_config[\"zero_optimization\"][\"stage3_gather_16bit_weights_on_model_save\"]\n            )\n\n    @parameterized.expand([FP16, BF16], name_func=parameterized_custom_name_func)\n    def test_autofill_dsconfig_from_ds_plugin(self, dtype):\n        ds_config = self.ds_config_dict[\"zero3\"]\n        if dtype == BF16:\n            del ds_config[\"fp16\"]\n        else:\n            del ds_config[\"bf16\"]\n        ds_config[dtype][\"enabled\"] = \"auto\"\n        ds_config[\"zero_optimization\"][\"stage\"] = \"auto\"\n        ds_config[\"zero_optimization\"][\"stage3_gather_16bit_weights_on_model_save\"] = \"auto\"\n        ds_config[\"zero_optimization\"][\"offload_optimizer\"][\"device\"] = \"auto\"\n        ds_config[\"zero_optimization\"][\"offload_param\"][\"device\"] = \"auto\"\n        ds_config[\"gradient_accumulation_steps\"] = \"auto\"\n        ds_config[\"gradient_clipping\"] = \"auto\"\n\n        deepspeed_plugin = DeepSpeedPlugin(\n            hf_ds_config=ds_config,\n            zero3_init_flag=True,\n            gradient_accumulation_steps=1,\n            gradient_clipping=1.0,\n            zero_stage=2,\n            offload_optimizer_device=\"cpu\",\n            offload_param_device=\"cpu\",\n            zero3_save_16bit_model=True,\n        )\n\n        with mockenv_context(**self.dist_env):\n            accelerator = Accelerator(deepspeed_plugin=deepspeed_plugin, mixed_precision=dtype)\n            deepspeed_plugin = accelerator.state.deepspeed_plugin\n            self.assertEqual(deepspeed_plugin.deepspeed_config[\"gradient_clipping\"], 1.0)\n            self.assertEqual(deepspeed_plugin.deepspeed_config[\"gradient_accumulation_steps\"], 1)\n            self.assertEqual(deepspeed_plugin.deepspeed_config[\"zero_optimization\"][\"stage\"], 2)\n            self.assertEqual(\n                deepspeed_plugin.deepspeed_config[\"zero_optimization\"][\"offload_optimizer\"][\"device\"], \"cpu\"\n            )\n            self.assertEqual(deepspeed_plugin.deepspeed_config[\"zero_optimization\"][\"offload_param\"][\"device\"], \"cpu\")\n            self.assertTrue(\n                deepspeed_plugin.deepspeed_config[\"zero_optimization\"][\"stage3_gather_16bit_weights_on_model_save\"]\n            )\n            self.assertTrue(deepspeed_plugin.deepspeed_config[dtype][\"enabled\"])\n\n        AcceleratorState._reset_state(True)\n        diff_dtype = \"bf16\" if dtype == \"fp16\" else \"fp16\"\n        with mockenv_context(**self.dist_env):\n            with self.assertRaises(ValueError) as cm:\n                accelerator = Accelerator(deepspeed_plugin=deepspeed_plugin, mixed_precision=diff_dtype)\n            self.assertTrue(\n                f\"`--mixed_precision` arg cannot be set to `{diff_dtype}` when `{dtype}` is set in the DeepSpeed config file.\"\n                in str(cm.exception)\n            )\n\n    def test_ds_config_assertions(self):\n        ambiguous_env = self.dist_env.copy()\n        ambiguous_env[\n            \"ACCELERATE_CONFIG_DS_FIELDS\"\n        ] = \"gradient_accumulation_steps,gradient_clipping,zero_stage,offload_optimizer_device,offload_param_device,zero3_save_16bit_model,mixed_precision\"\n\n        with mockenv_context(**ambiguous_env):\n            with self.assertRaises(ValueError) as cm:\n                deepspeed_plugin = DeepSpeedPlugin(\n                    hf_ds_config=self.ds_config_file[ZERO3],\n                    zero3_init_flag=True,\n                    gradient_accumulation_steps=1,\n                    gradient_clipping=1.0,\n                    zero_stage=ZERO2,\n                    offload_optimizer_device=\"cpu\",\n                    offload_param_device=\"cpu\",\n                    zero3_save_16bit_model=True,\n                )\n                _ = Accelerator(deepspeed_plugin=deepspeed_plugin, mixed_precision=FP16)\n            self.assertTrue(\n                \"If you are using an accelerate config file, remove others config variables mentioned in the above specified list.\"\n                in str(cm.exception)\n            )\n\n    @parameterized.expand(stages, name_func=parameterized_custom_name_func)\n    def test_ds_config(self, stage):\n        deepspeed_plugin = DeepSpeedPlugin(\n            hf_ds_config=self.ds_config_file[stage],\n            zero3_init_flag=True,\n        )\n        self.assertEqual(deepspeed_plugin.zero_stage, int(stage.replace(\"zero\", \"\")))\n\n    def test_basic_run(self):\n        mod_file = inspect.getfile(accelerate.test_utils)\n        test_file_path = os.path.sep.join(\n            mod_file.split(os.path.sep)[:-1] + [\"scripts\", \"external_deps\", \"test_performance.py\"]\n        )\n        with tempfile.TemporaryDirectory() as dirpath:\n            cmd = [\n                \"accelerate\",\n                \"launch\",\n                \"--num_processes=1\",\n                \"--num_machines=1\",\n                \"--machine_rank=0\",\n                \"--mixed_precision=fp16\",\n                \"--use_deepspeed\",\n                \"--gradient_accumulation_steps=1\",\n                \"--zero_stage=2\",\n                \"--offload_optimizer_device=none\",\n                \"--offload_param_device=none\",\n                test_file_path,\n                \"--model_name_or_path=distilbert-base-uncased\",\n                \"--num_epochs=1\",\n                f\"--output_dir={dirpath}\",\n            ]\n            with patch_environment(omp_num_threads=1):\n                execute_subprocess_async(cmd, env=os.environ.copy())\n\n\n@require_deepspeed\n@require_multi_gpu\n@slow\nclass DeepSpeedIntegrationTest(TempDirTestCase):\n    def setUp(self):\n        super().setUp()\n        self._test_file_path = inspect.getfile(self.__class__)\n        path = Path(self._test_file_path).resolve()\n        self.test_file_dir_str = str(path.parents[0])\n\n        self.ds_config_file = dict(\n            zero2=f\"{self.test_file_dir_str}/ds_config_zero2.json\",\n            zero3=f\"{self.test_file_dir_str}/ds_config_zero3.json\",\n        )\n\n        self.stages = [1, 2, 3]\n        self.zero3_offload_config = False\n        self.performance_lower_bound = 0.82\n        self.peak_memory_usage_upper_bound = {\n            \"multi_gpu_fp16\": 3200,\n            \"deepspeed_stage_1_fp16\": 1600,\n            \"deepspeed_stage_2_fp16\": 2500,\n            \"deepspeed_stage_3_zero_init_fp16\": 2800,\n            # Disabling below test as it overwhelms the RAM memory usage\n            # on CI self-hosted runner leading to tests getting killed.\n            # \"deepspeed_stage_3_cpu_offload_fp16\": 1900,\n        }\n        self.n_train = 160\n        self.n_val = 160\n\n        mod_file = inspect.getfile(accelerate.test_utils)\n        self.test_scripts_folder = os.path.sep.join(mod_file.split(os.path.sep)[:-1] + [\"scripts\", \"external_deps\"])\n\n    def test_performance(self):\n        self.test_file_path = os.path.join(self.test_scripts_folder, \"test_performance.py\")\n        cmd = [\n            \"accelerate\",\n            \"launch\",\n            \"--num_processes=2\",\n            \"--num_machines=1\",\n            \"--machine_rank=0\",\n            \"--mixed_precision=fp16\",\n            \"--use_deepspeed\",\n            \"--gradient_accumulation_steps=1\",\n            \"--gradient_clipping=1\",\n            \"--zero3_init_flag=True\",\n            \"--zero3_save_16bit_model=True\",\n        ]\n        for stage in self.stages:\n            if stage == 1:\n                continue\n            cmd_stage = cmd.copy()\n            cmd_stage.extend([f\"--zero_stage={stage}\"])\n            cmd_stage.extend([\"--offload_optimizer_device=none\", \"--offload_param_device=none\"])\n            if self.zero3_offload_config:\n                with io.open(self.ds_config_file[ZERO3], \"r\", encoding=\"utf-8\") as f:\n                    ds_config = json.load(f)\n                    del ds_config[\"bf16\"]\n                    del ds_config[\"optimizer\"][\"params\"][\"torch_adam\"]\n                    del ds_config[\"optimizer\"][\"params\"][\"adam_w_mode\"]\n                    ds_config[\"fp16\"][\"enabled\"] = True\n                    ds_config_path = os.path.join(self.tmpdir, \"ds_config.json\")\n                    with open(ds_config_path, \"w\") as out_file:\n                        json.dump(ds_config, out_file)\n\n                cmd_stage.extend([f\"--deepspeed_config_file={ds_config_path}\"])\n\n            cmd_stage.extend(\n                [\n                    self.test_file_path,\n                    f\"--output_dir={self.tmpdir}\",\n                    f\"--performance_lower_bound={self.performance_lower_bound}\",\n                ]\n            )\n            with patch_environment(omp_num_threads=1):\n                execute_subprocess_async(cmd_stage, env=os.environ.copy())\n\n    def test_checkpointing(self):\n        self.test_file_path = os.path.join(self.test_scripts_folder, \"test_checkpointing.py\")\n        cmd = [\n            \"accelerate\",\n            \"launch\",\n            \"--num_processes=2\",\n            \"--num_machines=1\",\n            \"--machine_rank=0\",\n            \"--mixed_precision=fp16\",\n            \"--use_deepspeed\",\n            \"--gradient_accumulation_steps=1\",\n            \"--gradient_clipping=1\",\n            \"--zero3_init_flag=True\",\n            \"--zero3_save_16bit_model=True\",\n        ]\n        for stage in self.stages:\n            if stage == 1:\n                continue\n            cmd_stage = cmd.copy()\n            cmd_stage.extend([f\"--zero_stage={stage}\"])\n            cmd_stage.extend([\"--offload_optimizer_device=none\", \"--offload_param_device=none\"])\n            if self.zero3_offload_config:\n                with io.open(self.ds_config_file[ZERO3], \"r\", encoding=\"utf-8\") as f:\n                    ds_config = json.load(f)\n                    del ds_config[\"bf16\"]\n                    del ds_config[\"optimizer\"][\"params\"][\"torch_adam\"]\n                    del ds_config[\"optimizer\"][\"params\"][\"adam_w_mode\"]\n                    ds_config[\"fp16\"][\"enabled\"] = True\n                    ds_config_path = os.path.join(self.tmpdir, \"ds_config.json\")\n                    with open(ds_config_path, \"w\") as out_file:\n                        json.dump(ds_config, out_file)\n\n                cmd_stage.extend([f\"--deepspeed_config_file={ds_config_path}\"])\n\n            cmd_stage.extend(\n                [\n                    self.test_file_path,\n                    f\"--output_dir={self.tmpdir}\",\n                    \"--partial_train_epoch=1\",\n                ]\n            )\n            with patch_environment(omp_num_threads=1):\n                execute_subprocess_async(cmd_stage, env=os.environ.copy())\n\n            cmd_stage = cmd_stage[:-1]\n            resume_from_checkpoint = os.path.join(self.tmpdir, \"epoch_0\")\n            cmd_stage.extend(\n                [\n                    f\"--resume_from_checkpoint={resume_from_checkpoint}\",\n                ]\n            )\n            with patch_environment(omp_num_threads=1):\n                execute_subprocess_async(cmd_stage, env=os.environ.copy())\n\n    def test_peak_memory_usage(self):\n        self.test_file_path = os.path.join(self.test_scripts_folder, \"test_peak_memory_usage.py\")\n        cmd = [\n            \"accelerate\",\n            \"launch\",\n            \"--num_processes=2\",\n            \"--num_machines=1\",\n            \"--machine_rank=0\",\n        ]\n        for spec, peak_mem_upper_bound in self.peak_memory_usage_upper_bound.items():\n            cmd_stage = cmd.copy()\n            if \"fp16\" in spec:\n                cmd_stage.extend([\"--mixed_precision=fp16\"])\n\n            if \"multi_gpu\" in spec:\n                continue\n            else:\n                cmd_stage.extend(\n                    [\n                        \"--use_deepspeed\",\n                        \"--gradient_accumulation_steps=1\",\n                        \"--gradient_clipping=1\",\n                        \"--zero3_init_flag=True\",\n                        \"--zero3_save_16bit_model=True\",\n                    ]\n                )\n                for i in range(3):\n                    if f\"stage_{i+1}\" in spec:\n                        cmd_stage.extend([f\"--zero_stage={i+1}\"])\n                        break\n                cmd_stage.extend(\n                    [\n                        \"--offload_optimizer_device=none\",\n                        \"--offload_param_device=none\",\n                        \"--offload_optimizer_nvme_path=none\",\n                        \"--offload_param_nvme_path=none\",\n                    ]\n                )\n                if \"cpu_offload\" in spec:\n                    with io.open(self.ds_config_file[ZERO3], \"r\", encoding=\"utf-8\") as f:\n                        ds_config = json.load(f)\n                        del ds_config[\"bf16\"]\n                        del ds_config[\"fp16\"]\n                        del ds_config[\"optimizer\"][\"params\"][\"torch_adam\"]\n                        del ds_config[\"optimizer\"][\"params\"][\"adam_w_mode\"]\n                        ds_config_path = os.path.join(self.tmpdir, \"ds_config.json\")\n                        with open(ds_config_path, \"w\") as out_file:\n                            json.dump(ds_config, out_file)\n\n                    cmd_stage.extend([f\"--deepspeed_config_file={ds_config_path}\"])\n\n            cmd_stage.extend(\n                [\n                    self.test_file_path,\n                    f\"--output_dir={self.tmpdir}\",\n                    f\"--peak_memory_upper_bound={peak_mem_upper_bound}\",\n                    f\"--n_train={self.n_train}\",\n                    f\"--n_val={self.n_val}\",\n                ]\n            )\n            with patch_environment(omp_num_threads=1):\n                execute_subprocess_async(cmd_stage, env=os.environ.copy())\n", "{\n    \"fp16\": {\n        \"enabled\": \"auto\",\n        \"loss_scale\": 0,\n        \"loss_scale_window\": 1000,\n        \"initial_scale_power\": 16,\n        \"hysteresis\": 2,\n        \"min_loss_scale\": 1\n    },\n    \"bf16\": {\n        \"enabled\": \"auto\"\n    },\n    \"optimizer\": {\n        \"type\": \"AdamW\",\n        \"params\": {\n            \"lr\": \"auto\",\n            \"weight_decay\": \"auto\",\n            \"torch_adam\": true,\n            \"adam_w_mode\": true\n        }\n    },\n    \"scheduler\": {\n        \"type\": \"WarmupLR\",\n        \"params\": {\n            \"warmup_min_lr\": \"auto\",\n            \"warmup_max_lr\": \"auto\",\n            \"warmup_num_steps\": \"auto\"\n        }\n    },\n    \"zero_optimization\": {\n        \"stage\": 3,\n        \"offload_optimizer\": {\n            \"device\": \"cpu\",\n            \"pin_memory\": true\n        },\n        \"offload_param\": {\n            \"device\": \"cpu\",\n            \"pin_memory\": true\n        },\n        \"overlap_comm\": true,\n        \"contiguous_gradients\": true,\n        \"sub_group_size\": 1e9,\n        \"reduce_bucket_size\": \"auto\",\n        \"stage3_prefetch_bucket_size\": \"auto\",\n        \"stage3_param_persistence_threshold\": \"auto\",\n        \"stage3_max_live_parameters\": 1e9,\n        \"stage3_max_reuse_distance\": 1e9,\n        \"stage3_gather_16bit_weights_on_model_save\": \"auto\"\n    },\n    \"gradient_accumulation_steps\": 1,\n    \"gradient_clipping\": \"auto\",\n    \"steps_per_print\": 2000,\n    \"train_batch_size\": \"auto\",\n    \"train_micro_batch_size_per_gpu\": \"auto\",\n    \"wall_clock_breakdown\": false\n}", "echo \"hello world\"\necho \"this is a second command\"", "label,sentence1,sentence2\nequivalent,He said the foodservice pie business doesn 't fit the company 's long-term growth strategy .,\"\"\" The foodservice pie business does not fit our long-term growth strategy .\"\nnot_equivalent,Magnarelli said Racicot hated the Iraqi regime and looked forward to using his long years of training in the war .,\"His wife said he was \"\" 100 percent behind George Bush \"\" and looked forward to using his years of training in the war .\"\nnot_equivalent,\"The dollar was at 116.92 yen against the yen , flat on the session , and at 1.2891 against the Swiss franc , also flat .\",\"The dollar was at 116.78 yen JPY = , virtually flat on the session , and at 1.2871 against the Swiss franc CHF = , down 0.1 percent .\"\nequivalent,The AFL-CIO is waiting until October to decide if it will endorse a candidate .,The AFL-CIO announced Wednesday that it will decide in October whether to endorse a candidate before the primaries .\nnot_equivalent,No dates have been set for the civil or the criminal trial .,\"No dates have been set for the criminal or civil cases , but Shanley has pleaded not guilty .\"\nequivalent,Wal-Mart said it would check all of its million-plus domestic workers to ensure they were legally employed .,It has also said it would review all of its domestic employees more than 1 million to ensure they have legal status .\n", "label,sentence1,sentence2\nequivalent,He said the foodservice pie business doesn 't fit the company 's long-term growth strategy .,\"\"\" The foodservice pie business does not fit our long-term growth strategy .\"\nnot_equivalent,Magnarelli said Racicot hated the Iraqi regime and looked forward to using his long years of training in the war .,\"His wife said he was \"\" 100 percent behind George Bush \"\" and looked forward to using his years of training in the war .\"\nnot_equivalent,\"The dollar was at 116.92 yen against the yen , flat on the session , and at 1.2891 against the Swiss franc , also flat .\",\"The dollar was at 116.78 yen JPY = , virtually flat on the session , and at 1.2871 against the Swiss franc CHF = , down 0.1 percent .\"\nequivalent,The AFL-CIO is waiting until October to decide if it will endorse a candidate .,The AFL-CIO announced Wednesday that it will decide in October whether to endorse a candidate before the primaries .\nnot_equivalent,No dates have been set for the civil or the criminal trial .,\"No dates have been set for the criminal or civil cases , but Shanley has pleaded not guilty .\"\nequivalent,Wal-Mart said it would check all of its million-plus domestic workers to ensure they were legally employed .,It has also said it would review all of its domestic employees more than 1 million to ensure they have legal status .\n", "# Copyright 2022 The HuggingFace Team. All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nimport inspect\nimport os\n\nimport torch\nfrom transformers import AutoModel\nfrom transformers.testing_utils import mockenv_context\nfrom transformers.trainer_utils import set_seed\n\nimport accelerate\nfrom accelerate.accelerator import Accelerator\nfrom accelerate.state import AcceleratorState\nfrom accelerate.test_utils.testing import (\n    AccelerateTestCase,\n    TempDirTestCase,\n    execute_subprocess_async,\n    require_cuda,\n    require_fsdp,\n    require_multi_gpu,\n    slow,\n)\nfrom accelerate.utils.constants import (\n    FSDP_AUTO_WRAP_POLICY,\n    FSDP_BACKWARD_PREFETCH,\n    FSDP_SHARDING_STRATEGY,\n    FSDP_STATE_DICT_TYPE,\n)\nfrom accelerate.utils.dataclasses import FullyShardedDataParallelPlugin\nfrom accelerate.utils.other import patch_environment\n\n\nset_seed(42)\n\nBERT_BASE_CASED = \"bert-base-cased\"\nFP16 = \"fp16\"\nBF16 = \"bf16\"\ndtypes = [FP16, BF16]\n\n\n@require_fsdp\n@require_cuda\nclass FSDPPluginIntegration(AccelerateTestCase):\n    def setUp(self):\n        super().setUp()\n\n        self.dist_env = dict(\n            ACCELERATE_USE_FSDP=\"true\",\n            MASTER_ADDR=\"localhost\",\n            MASTER_PORT=\"10999\",\n            RANK=\"0\",\n            LOCAL_RANK=\"0\",\n            WORLD_SIZE=\"1\",\n        )\n\n    def test_sharding_strategy(self):\n        from torch.distributed.fsdp.fully_sharded_data_parallel import ShardingStrategy\n\n        for i, strategy in enumerate(FSDP_SHARDING_STRATEGY):\n            env = self.dist_env.copy()\n            env[\"FSDP_SHARDING_STRATEGY\"] = f\"{i + 1}\"\n            env[\"FSDP_SHARDING_STRATEGY_NAME\"] = strategy\n            with mockenv_context(**env):\n                fsdp_plugin = FullyShardedDataParallelPlugin()\n                self.assertEqual(fsdp_plugin.sharding_strategy, ShardingStrategy(i + 1))\n\n    def test_backward_prefetch(self):\n        from torch.distributed.fsdp.fully_sharded_data_parallel import BackwardPrefetch\n\n        for i, prefetch_policy in enumerate(FSDP_BACKWARD_PREFETCH):\n            env = self.dist_env.copy()\n            env[\"FSDP_BACKWARD_PREFETCH\"] = prefetch_policy\n            with mockenv_context(**env):\n                fsdp_plugin = FullyShardedDataParallelPlugin()\n                if prefetch_policy == \"NO_PREFETCH\":\n                    self.assertIsNone(fsdp_plugin.backward_prefetch)\n                else:\n                    self.assertEqual(fsdp_plugin.backward_prefetch, BackwardPrefetch(i + 1))\n\n    def test_state_dict_type(self):\n        from torch.distributed.fsdp.fully_sharded_data_parallel import StateDictType\n\n        for i, state_dict_type in enumerate(FSDP_STATE_DICT_TYPE):\n            env = self.dist_env.copy()\n            env[\"FSDP_STATE_DICT_TYPE\"] = state_dict_type\n            with mockenv_context(**env):\n                fsdp_plugin = FullyShardedDataParallelPlugin()\n                self.assertEqual(fsdp_plugin.state_dict_type, StateDictType(i + 1))\n                if state_dict_type == \"FULL_STATE_DICT\":\n                    self.assertTrue(fsdp_plugin.state_dict_config.offload_to_cpu)\n                    self.assertTrue(fsdp_plugin.state_dict_config.rank0_only)\n\n    def test_auto_wrap_policy(self):\n        model = AutoModel.from_pretrained(BERT_BASE_CASED)\n        for policy in FSDP_AUTO_WRAP_POLICY:\n            env = self.dist_env.copy()\n            env[\"FSDP_AUTO_WRAP_POLICY\"] = policy\n            if policy == \"TRANSFORMER_BASED_WRAP\":\n                env[\"FSDP_TRANSFORMER_CLS_TO_WRAP\"] = \"BertLayer\"\n            elif policy == \"SIZE_BASED_WRAP\":\n                env[\"FSDP_MIN_NUM_PARAMS\"] = \"2000\"\n            with mockenv_context(**env):\n                fsdp_plugin = FullyShardedDataParallelPlugin()\n                fsdp_plugin.set_auto_wrap_policy(model)\n                if policy == \"NO_WRAP\":\n                    self.assertIsNone(fsdp_plugin.auto_wrap_policy)\n                else:\n                    self.assertIsNotNone(fsdp_plugin.auto_wrap_policy)\n\n        env = self.dist_env.copy()\n        env[\"FSDP_AUTO_WRAP_POLICY\"] = \"TRANSFORMER_BASED_WRAP\"\n        env[\"FSDP_TRANSFORMER_CLS_TO_WRAP\"] = \"T5Layer\"\n        with mockenv_context(**env):\n            fsdp_plugin = FullyShardedDataParallelPlugin()\n            with self.assertRaises(Exception) as cm:\n                fsdp_plugin.set_auto_wrap_policy(model)\n            self.assertTrue(\"Could not find the transformer layer class to wrap in the model.\" in str(cm.exception))\n\n        env = self.dist_env.copy()\n        env[\"FSDP_AUTO_WRAP_POLICY\"] = \"SIZE_BASED_WRAP\"\n        env[\"FSDP_MIN_NUM_PARAMS\"] = \"0\"\n        with mockenv_context(**env):\n            fsdp_plugin = FullyShardedDataParallelPlugin()\n            fsdp_plugin.set_auto_wrap_policy(model)\n            self.assertIsNone(fsdp_plugin.auto_wrap_policy)\n\n    def test_mixed_precision(self):\n        from torch.distributed.fsdp.fully_sharded_data_parallel import MixedPrecision\n        from torch.distributed.fsdp.sharded_grad_scaler import ShardedGradScaler\n\n        for mp_dtype in dtypes:\n            env = self.dist_env.copy()\n            env[\"ACCELERATE_MIXED_PRECISION\"] = mp_dtype\n            with mockenv_context(**env):\n                accelerator = Accelerator()\n                if mp_dtype == \"fp16\":\n                    dtype = torch.float16\n                elif mp_dtype == \"bf16\":\n                    dtype = torch.bfloat16\n                mp_policy = MixedPrecision(param_dtype=dtype, reduce_dtype=dtype, buffer_dtype=dtype)\n                self.assertEqual(accelerator.state.fsdp_plugin.mixed_precision_policy, mp_policy)\n                if mp_dtype == FP16:\n                    self.assertTrue(isinstance(accelerator.scaler, ShardedGradScaler))\n                elif mp_dtype == BF16:\n                    self.assertIsNone(accelerator.scaler)\n                AcceleratorState._reset_state(True)\n\n    def test_cpu_offload(self):\n        from torch.distributed.fsdp.fully_sharded_data_parallel import CPUOffload\n\n        for flag in [True, False]:\n            env = self.dist_env.copy()\n            env[\"FSDP_OFFLOAD_PARAMS\"] = str(flag).lower()\n            with mockenv_context(**env):\n                fsdp_plugin = FullyShardedDataParallelPlugin()\n                self.assertEqual(fsdp_plugin.cpu_offload, CPUOffload(offload_params=flag))\n\n\n@require_fsdp\n@require_multi_gpu\n@slow\nclass FSDPIntegrationTest(TempDirTestCase):\n    def setUp(self):\n        super().setUp()\n        self.performance_lower_bound = 0.82\n        self.performance_configs = [\n            \"fsdp_shard_grad_op_transformer_based_wrap\",\n            \"fsdp_full_shard_transformer_based_wrap\",\n        ]\n        self.peak_memory_usage_upper_bound = {\n            \"multi_gpu_fp16\": 3200,\n            \"fsdp_shard_grad_op_transformer_based_wrap_fp16\": 2000,\n            \"fsdp_full_shard_transformer_based_wrap_fp16\": 1900,\n            # Disabling below test as it overwhelms the RAM memory usage\n            # on CI self-hosted runner leading to tests getting killed.\n            # \"fsdp_full_shard_cpu_offload_transformer_based_wrap_fp32\": 1500,  # fp16 was leading to indefinite hang\n        }\n        self.n_train = 160\n        self.n_val = 160\n\n        mod_file = inspect.getfile(accelerate.test_utils)\n        self.test_scripts_folder = os.path.sep.join(mod_file.split(os.path.sep)[:-1] + [\"scripts\", \"external_deps\"])\n\n    def test_performance(self):\n        self.test_file_path = os.path.join(self.test_scripts_folder, \"test_performance.py\")\n        cmd = [\"accelerate\", \"launch\", \"--num_processes=2\", \"--num_machines=1\", \"--machine_rank=0\", \"--use_fsdp\"]\n        for config in self.performance_configs:\n            cmd_config = cmd.copy()\n            for i, strategy in enumerate(FSDP_SHARDING_STRATEGY):\n                if strategy.lower() in config:\n                    cmd_config.append(f\"--fsdp_sharding_strategy={i+1}\")\n                    break\n\n            if \"fp32\" in config:\n                cmd_config.append(\"--mixed_precision=no\")\n            else:\n                cmd_config.append(\"--mixed_precision=fp16\")\n\n            if \"cpu_offload\" in config:\n                cmd_config.append(\"--fsdp_offload_params=True\")\n\n            for policy in FSDP_AUTO_WRAP_POLICY:\n                if policy.lower() in config:\n                    cmd_config.append(f\"--fsdp_auto_wrap_policy={policy}\")\n                    break\n\n            if policy == \"TRANSFORMER_BASED_WRAP\":\n                cmd_config.append(\"--fsdp_transformer_layer_cls_to_wrap=BertLayer\")\n            elif policy == \"SIZE_BASED_WRAP\":\n                cmd_config.append(\"--fsdp_min_num_params=2000\")\n\n            cmd_config.extend(\n                [\n                    self.test_file_path,\n                    f\"--output_dir={self.tmpdir}\",\n                    f\"--performance_lower_bound={self.performance_lower_bound}\",\n                ]\n            )\n            with patch_environment(omp_num_threads=1):\n                execute_subprocess_async(cmd_config, env=os.environ.copy())\n\n    def test_checkpointing(self):\n        self.test_file_path = os.path.join(self.test_scripts_folder, \"test_checkpointing.py\")\n        cmd = [\n            \"accelerate\",\n            \"launch\",\n            \"--num_processes=2\",\n            \"--num_machines=1\",\n            \"--machine_rank=0\",\n            \"--use_fsdp\",\n            \"--mixed_precision=fp16\",\n            \"--fsdp_transformer_layer_cls_to_wrap=BertLayer\",\n        ]\n\n        for i, strategy in enumerate(FSDP_SHARDING_STRATEGY):\n            cmd_config = cmd.copy()\n            cmd_config.append(f\"--fsdp_sharding_strategy={i+1}\")\n            if strategy != \"FULL_SHARD\":\n                continue\n            state_dict_config_index = len(cmd_config)\n            for state_dict_type in FSDP_STATE_DICT_TYPE:\n                cmd_config = cmd_config[:state_dict_config_index]\n                cmd_config.append(f\"--fsdp_state_dict_type={state_dict_type}\")\n                cmd_config.extend(\n                    [\n                        self.test_file_path,\n                        f\"--output_dir={self.tmpdir}\",\n                        \"--partial_train_epoch=1\",\n                    ]\n                )\n                with patch_environment(omp_num_threads=1):\n                    execute_subprocess_async(cmd_config, env=os.environ.copy())\n\n                cmd_config = cmd_config[:-1]\n                resume_from_checkpoint = os.path.join(self.tmpdir, \"epoch_0\")\n                cmd_config.extend(\n                    [\n                        f\"--resume_from_checkpoint={resume_from_checkpoint}\",\n                    ]\n                )\n                with patch_environment(omp_num_threads=1):\n                    execute_subprocess_async(cmd_config, env=os.environ.copy())\n\n    def test_peak_memory_usage(self):\n        self.test_file_path = os.path.join(self.test_scripts_folder, \"test_peak_memory_usage.py\")\n        cmd = [\n            \"accelerate\",\n            \"launch\",\n            \"--num_processes=2\",\n            \"--num_machines=1\",\n            \"--machine_rank=0\",\n        ]\n        for spec, peak_mem_upper_bound in self.peak_memory_usage_upper_bound.items():\n            cmd_config = cmd.copy()\n            if \"fp16\" in spec:\n                cmd_config.extend([\"--mixed_precision=fp16\"])\n            else:\n                cmd_config.extend([\"--mixed_precision=no\"])\n\n            if \"multi_gpu\" in spec:\n                continue\n            else:\n                cmd_config.extend([\"--use_fsdp\"])\n                for i, strategy in enumerate(FSDP_SHARDING_STRATEGY):\n                    if strategy.lower() in spec:\n                        cmd_config.append(f\"--fsdp_sharding_strategy={i+1}\")\n                        break\n\n                if \"cpu_offload\" in spec:\n                    cmd_config.append(\"--fsdp_offload_params=True\")\n\n                for policy in FSDP_AUTO_WRAP_POLICY:\n                    if policy.lower() in spec:\n                        cmd_config.append(f\"--fsdp_auto_wrap_policy={policy}\")\n                        break\n\n                if policy == \"TRANSFORMER_BASED_WRAP\":\n                    cmd_config.append(\"--fsdp_transformer_layer_cls_to_wrap=BertLayer\")\n                elif policy == \"SIZE_BASED_WRAP\":\n                    cmd_config.append(\"--fsdp_min_num_params=2000\")\n\n            cmd_config.extend(\n                [\n                    self.test_file_path,\n                    f\"--output_dir={self.tmpdir}\",\n                    f\"--peak_memory_upper_bound={peak_mem_upper_bound}\",\n                    f\"--n_train={self.n_train}\",\n                    f\"--n_val={self.n_val}\",\n                ]\n            )\n            with patch_environment(omp_num_threads=1):\n                execute_subprocess_async(cmd_config, env=os.environ.copy())\n", "This folder contains test configs for `accelerate config`. These should be generated for each major version\nand are written based on `accelerate config` and selecting the \"No distributed training\" option.", "compute_environment: LOCAL_MACHINE\ndeepspeed_config: {}\ndistributed_type: 'NO'\nfsdp_config: {}\nmachine_rank: 0\nmain_process_ip: null\nmain_process_port: null\nmain_training_function: main\nmixed_precision: 'no'\nnum_machines: 1\nnum_processes: 1\nuse_cpu: false", "compute_environment: LOCAL_MACHINE\ndeepspeed_config: {}\ndistributed_type: 'NO'\ndowncast_bf16: 'no'\nfsdp_config: {}\nmachine_rank: 0\nmain_process_ip: null\nmain_process_port: null\nmain_training_function: main\nmixed_precision: 'no'\nnum_machines: 1\nnum_processes: 1\nuse_cpu: false", "compute_environment: LOCAL_MACHINE\ndeepspeed_config: {}\ndistributed_type: 'NO'\ndowncast_bf16: 'no'\nfsdp_config: {}\ngpu_ids: all\nmachine_rank: 0\nmain_process_ip: null\nmain_process_port: null\nmain_training_function: main\nmegatron_lm_config: {}\nmixed_precision: 'no'\nnum_machines: 1\nnum_processes: 1\nrdzv_backend: static\nsame_network: true\nuse_cpu: false\ntpu_name: 'test-tpu'\ntpu_zone: 'us-central1-a'\ncommands: null\ncommand_file: tests/test_samples/test_command_file.sh", "<!---\nCopyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n# Generating the documentation\n\nTo generate the documentation, you first have to build it. Several packages are necessary to build the doc, \nyou can install them with the following command, at the root of the code repository:\n\n```bash\npip install -e \".[docs]\"\n```\n\nThen you need to install our special tool that builds the documentation:\n\n```bash\npip install git+https://github.com/huggingface/doc-builder\n```\n\n---\n**NOTE**\n\nYou only need to generate the documentation to inspect it locally (if you're planning changes and want to\ncheck how they look before committing for instance). You don't have to commit the built documentation.\n\n---\n\n## Building the documentation\n\nOnce you have setup the `doc-builder` and additional packages, you can generate the documentation by \ntyping the following command:\n\n```bash\ndoc-builder build accelerate docs/source/ --build_dir ~/tmp/test-build\n```\n\nYou can adapt the `--build_dir` to set any temporary folder that you prefer. This command will create it and generate\nthe MDX files that will be rendered as the documentation on the main website. You can inspect them in your favorite\nMarkdown editor.\n\n## Previewing the documentation\n\nTo preview the docs, first install the `watchdog` module with:\n\n```bash\npip install watchdog\n```\n\nThen run the following command:\n\n```bash\ndoc-builder preview {package_name} {path_to_docs}\n```\n\nFor example:\n\n```bash\ndoc-builder preview accelerate docs/source/\n```\n\nThe docs will be viewable at [http://localhost:3000](http://localhost:3000). You can also preview the docs once you have opened a PR. You will see a bot add a comment to a link where the documentation with your changes lives.\n\n---\n**NOTE**\n\nThe `preview` command only works with existing doc files. When you add a completely new file, you need to update `_toctree.yml` & restart `preview` command (`ctrl-c` to stop it & call `doc-builder preview ...` again).\n\n---\n\n## Adding a new element to the navigation bar\n\nAccepted files are Markdown (.md).\n\nCreate a file with its extension and put it in the source directory. You can then link it to the toc-tree by putting\nthe filename without the extension in the [`_toctree.yml`](https://github.com/huggingface/accelerate/blob/main/docs/source/_toctree.yml) file.\n\n## Renaming section headers and moving sections\n\nIt helps to keep the old links working when renaming the section header and/or moving sections from one document to another. This is because the old links are likely to be used in Issues, Forums, and Social media and it'd make for a much more superior user experience if users reading those months later could still easily navigate to the originally intended information.\n\nTherefore, we simply keep a little map of moved sections at the end of the document where the original section was. The key is to preserve the original anchor.\n\nSo if you renamed a section from: \"Section A\" to \"Section B\", then you can add at the end of the file:\n\n```\nSections that were moved:\n\n[ <a href=\"#section-b\">Section A</a><a id=\"section-a\"></a> ]\n```\nand of course, if you moved it to another file, then:\n\n```\nSections that were moved:\n\n[ <a href=\"../new-file#section-b\">Section A</a><a id=\"section-a\"></a> ]\n```\n\nUse the relative style to link to the new file so that the versioned docs continue to work.\n\n\n## Writing Documentation - Specification\n\nThe `huggingface/accelerate` documentation follows the\n[Google documentation](https://sphinxcontrib-napoleon.readthedocs.io/en/latest/example_google.html) style for docstrings,\nalthough we can write them directly in Markdown.\n\n### Adding a new tutorial\n\nAdding a new tutorial or section is done in two steps:\n\n- Add a new file under `./source`. This file can either be ReStructuredText (.rst) or Markdown (.md).\n- Link that file in `./source/_toctree.yml` on the correct toc-tree.\n\nMake sure to put your new file under the proper section. It's unlikely to go in the first section (*Get Started*), so\ndepending on the intended targets (beginners, more advanced users, or researchers) it should go in sections two, three, or\nfour.\n\n### Writing source documentation\n\nValues that should be put in `code` should either be surrounded by backticks: \\`like so\\`. Note that argument names\nand objects like True, None, or any strings should usually be put in `code`.\n\nWhen mentioning a class, function, or method, it is recommended to use our syntax for internal links so that our tool\nadds a link to its documentation with this syntax: \\[\\`XXXClass\\`\\] or \\[\\`function\\`\\]. This requires the class or \nfunction to be in the main package.\n\nIf you want to create a link to some internal class or function, you need to\nprovide its path. For instance: \\[\\`utils.gather\\`\\]. This will be converted into a link with\n`utils.gather` in the description. To get rid of the path and only keep the name of the object you are\nlinking to in the description, add a ~: \\[\\`~utils.gather\\`\\] will generate a link with `gather` in the description.\n\nThe same works for methods so you can either use \\[\\`XXXClass.method\\`\\] or \\[~\\`XXXClass.method\\`\\].\n\n#### Defining arguments in a method\n\nArguments should be defined with the `Args:` (or `Arguments:` or `Parameters:`) prefix, followed by a line return and\nan indentation. The argument should be followed by its type, with its shape if it is a tensor, a colon, and its\ndescription:\n\n```\n    Args:\n        n_layers (`int`): The number of layers of the model.\n```\n\nIf the description is too long to fit in one line (more than 119 characters in total), another indentation is necessary \nbefore writing the description after the argument.\n\nFinally, to maintain uniformity if any *one* description is too long to fit on one line, the \nrest of the parameters should follow suit and have an indention before their description.\n\nHere's an example showcasing everything so far:\n\n```\n    Args:\n        gradient_accumulation_steps (`int`, *optional*, default to 1):\n            The number of steps that should pass before gradients are accumulated. A number > 1 should be combined with `Accelerator.accumulate`.\n        cpu (`bool`, *optional*):\n            Whether or not to force the script to execute on CPU. Will ignore GPU available if set to `True` and force the execution on one process only.\n```\n\nFor optional arguments or arguments with defaults we follow the following syntax: imagine we have a function with the\nfollowing signature:\n\n```\ndef my_function(x: str = None, a: float = 1):\n```\n\nthen its documentation should look like this:\n\n```\n    Args:\n        x (`str`, *optional*):\n            This argument controls ... and has a description longer than 119 chars.\n        a (`float`, *optional*, defaults to 1):\n            This argument is used to ... and has a description longer than 119 chars.\n```\n\nNote that we always omit the \"defaults to \\`None\\`\" when None is the default for any argument. Also note that even\nif the first line describing your argument type and its default gets long, you can't break it on several lines. You can\nhowever write as many lines as you want in the indented description (see the example above with `input_ids`).\n\n#### Writing a multi-line code block\n\nMulti-line code blocks can be useful for displaying examples. They are done between two lines of three backticks as usual in Markdown:\n\n\n````\n```python\n# first line of code\n# second line\n# etc\n```\n````\n\n#### Writing a return block\n\nThe return block should be introduced with the `Returns:` prefix, followed by a line return and an indentation.\nThe first line should be the type of the return, followed by a line return. No need to indent further for the elements\nbuilding the return.\n\nHere's an example of a single value return:\n\n```\n    Returns:\n        `List[int]`: A list of integers in the range [0, 1] --- 1 for a special token, 0 for a sequence token.\n```\n\nHere's an example of a tuple return, comprising several objects:\n\n```\n    Returns:\n        `tuple(torch.FloatTensor)` comprising various elements depending on the configuration ([`BertConfig`]) and inputs:\n        - ** loss** (*optional*, returned when `masked_lm_labels` is provided) `torch.FloatTensor` of shape `(1,)` --\n          Total loss is the sum of the masked language modeling loss and the next sequence prediction (classification) loss.\n        - **prediction_scores** (`torch.FloatTensor` of shape `(batch_size, sequence_length, config.vocab_size)`) --\n          Prediction scores of the language modeling head (scores for each vocabulary token before SoftMax).\n```\n\n## Styling the docstring\n\nWe have an automatic script running with the `make style` comment that will make sure that:\n- the docstrings fully take advantage of the line width\n- all code examples are formatted using black, like the code of the Transformers library\n\nThis script may have some weird failures if you made a syntax mistake or if you uncover a bug. Therefore, it's\nrecommended to commit your changes before running `make style`, so you can revert the changes done by that script\neasily.\n\n## Writing documentation examples\n\nThe syntax for Example docstrings can look as follows:\n\n```\n    Example:\n\n    ```python\n    >>> import time\n    >>> from accelerate import Accelerator\n    >>> accelerator = Accelerator()\n    >>> if accelerator.is_main_process:\n    ...     time.sleep(2)\n    >>> else:\n    ...     print(\"I'm waiting for the main process to finish its sleep...\")\n    >>> accelerator.wait_for_everyone()\n    >>> # Should print on every process at the same time\n    >>> print(\"Everyone is here\")\n    ```\n```\n\nThe docstring should give a minimal, clear example of how the respective function \nis to be used in inference and also include the expected (ideally sensible)\noutput.\nOften, readers will try out the example before even going through the function \nor class definitions. Therefore, it is of utmost importance that the example \nworks as expected.", "# Minimal makefile for Sphinx documentation\n#\n\n# You can set these variables from the command line.\nSPHINXOPTS    =\nSPHINXBUILD   = sphinx-build\nSOURCEDIR     = source\nBUILDDIR      = _build\n\n# Put it first so that \"make\" without argument is like \"make help\".\nhelp:\n\t@$(SPHINXBUILD) -M help \"$(SOURCEDIR)\" \"$(BUILDDIR)\" $(SPHINXOPTS) $(O)\n\n.PHONY: help Makefile\n\n# Catch-all target: route all unknown targets to Sphinx using the new\n# \"make mode\" option.  $(O) is meant as a shortcut for $(SPHINXOPTS).\n%: Makefile\n\t@$(SPHINXBUILD) -M $@ \"$(SOURCEDIR)\" \"$(BUILDDIR)\" $(SPHINXOPTS) $(O)", "<!--Copyright 2021 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\nspecific language governing permissions and limitations under the License.\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n-->\n\n# Quick tour\n\nLet's have a look at the \ud83e\udd17 Accelerate main features and traps to avoid.\n\n## Main use\n\nTo use \ud83e\udd17 Accelerate in your own script, you have to change four things:\n\n1. Import the [`Accelerator`] main class and instantiate one in an `accelerator` object:\n\n```python\nfrom accelerate import Accelerator\n\naccelerator = Accelerator()\n```\n\nThis should happen as early as possible in your training script as it will initialize everything necessary for\ndistributed training. You don't need to indicate the kind of environment you are in (just one machine with a GPU, one\nmachines with several GPUs, several machines with multiple GPUs or a TPU), the library will detect this automatically.\n\n2. Remove the call `.to(device)` or `.cuda()` for your model and input data. The `accelerator` object\nwill handle this for you and place all those objects on the right device for you. If you know what you're doing, you\ncan leave those `.to(device)` calls but you should use the device provided by the `accelerator` object:\n`accelerator.device`.\n\nTo fully deactivate the automatic device placement, pass along `device_placement=False` when initializing your\n[`Accelerator`].\n\n<Tip warning={true}>\n\n    If you place your objects manually on the proper device, be careful to create your optimizer after putting your\n    model on `accelerator.device` or your training will fail on TPU.\n\n</Tip>\n\n3. Pass all objects relevant to training (optimizer, model, training dataloader, learning rate scheduler) to the\n[`~Accelerator.prepare`] method. This will make sure everything is ready for training.\n\n```python\nmodel, optimizer, train_dataloader, lr_scheduler = accelerator.prepare(\n    model, optimizer, train_dataloader, lr_scheduler\n)\n```\n\nIn particular, your training dataloader will be sharded across all GPUs/TPU cores available so that each one sees a\ndifferent portion of the training dataset. Also, the random states of all processes will be synchronized at the\nbeginning of each iteration through your dataloader, to make sure the data is shuffled the same way (if you decided to\nuse `shuffle=True` or any kind of random sampler).\n\n<Tip>\n\n    The actual batch size for your training will be the number of devices used multiplied by the batch size you set in\n    your script: for instance training on 4 GPUs with a batch size of 16 set when creating the training dataloader will\n    train at an actual batch size of 64.\n\n</Tip>\n\nAlternatively, you can use the option `split_batches=True` when creating and initializing your\n[`Accelerator`], in which case the batch size will always stay the same, whether you run your\nscript on 1, 2, 4, or 64 GPUs.\n\nYou should execute this instruction as soon as all objects for training are created, before starting your actual\ntraining loop.\n\n<Tip warning={true}>\n\n    You should only pass the learning rate scheduler to [`~Accelerator.prepare`] when the scheduler needs to be stepped\n    at each optimizer step.\n\n</Tip>\n\n<Tip warning={true}>\n\n    Your training dataloader may change length when going through this method: if you run on X GPUs, it will have its\n    length divided by X (since your actual batch size will be multiplied by X), unless you set\n    `split_batches=True`.\n\n</Tip>\n\nAny instruction using your training dataloader length (for instance if you want to log the number of total training\nsteps) should go after the call to [`~Accelerator.prepare`].\n\nYou can perfectly send your dataloader to [`~Accelerator.prepare`] on its own, but it's best to send the\nmodel and optimizer to [`~Accelerator.prepare`] together.\n\nYou may or may not want to send your validation dataloader to [`~Accelerator.prepare`], depending on\nwhether you want to run distributed evaluation or not (see below).\n\n4. Replace the line `loss.backward()` by `accelerator.backward(loss)`.\n\nAnd you're all set! With all these changes, your script will run on your local machine as well as on multiple GPUs or a\nTPU! You can either use your favorite tool to launch the distributed training, or you can use the \ud83e\udd17 Accelerate\nlauncher.\n\n\n## Distributed evaluation\n\nYou can perform regular evaluation in your training script, if you leave your validation dataloader out of the\n[`~Accelerator.prepare`] method. In this case, you will need to put the input data on the\n`accelerator.device` manually.\n\nTo perform distributed evaluation, send along your validation dataloader to the [`~Accelerator.prepare`]\nmethod:\n\n```python\nvalidation_dataloader = accelerator.prepare(validation_dataloader)\n```\n\nAs for your training dataloader, it will mean that (should you run your script on multiple devices) each device will\nonly see part of the evaluation data. This means you will need to group your predictions together. This is very easy to\ndo with the [`~Accelerator.gather_for_metrics`] method.\n\n```python\nfor inputs, targets in validation_dataloader:\n    predictions = model(inputs)\n    # Gather all predictions and targets\n    all_predictions, all_targets = accelerator.gather_for_metrics((predictions, targets))\n    # Example of use with a *Datasets.Metric*\n    metric.add_batch(all_predictions, all_targets)\n```\n\n<Tip warning={true}>\n\n    Similar to the training dataloader, passing your validation dataloader through\n    [`~Accelerator.prepare`] may change it: if you run on X GPUs, it will have its length divided by X\n    (since your actual batch size will be multiplied by X), unless you set `split_batches=True`.\n\n</Tip>\n\nAny instruction using your training dataloader length (for instance if you need the number of total training steps\nto create a learning rate scheduler) should go after the call to [`~Accelerator.prepare`]. \n\nSome data at the end of the dataset may be duplicated so the batch can be divided equally among all workers. As a result, metrics\nshould be calculated through the [`~Accelerator.gather_for_metrics`] method to automatically remove the duplicated data while gathering.\n\n<Tip>\n\n    If for some reason you don't wish to have this automatically done, [`~Accelerator.gather`] can be used instead to gather \n    the data across all processes and this can manually be done instead.\n\n</Tip>\n\n\n<Tip warning={true}>\n\n    The [`~Accelerator.gather`] and [`~Accelerator.gather_for_metrics`] methods require the tensors to be all the same size on each process. If\n    you have tensors of different sizes on each process (for instance when dynamically padding to the maximum length in\n    a batch), you should use the [`~Accelerator.pad_across_processes`] method to pad you tensor to the\n    biggest size across processes.\n\n</Tip>\n\n## Launching your distributed script\n\nYou can use the regular commands to launch your distributed training (like `torch.distributed.run` for\nPyTorch), they are fully compatible with \ud83e\udd17 Accelerate.\n\n\ud83e\udd17 Accelerate also provides a CLI tool that unifies all launchers, so you only have to remember one command. To use it,\njust run:\n\n```bash\naccelerate config\n```\n\non your machine and reply to the questions asked. This will save a *default_config.yaml* file in your cache folder for\n\ud83e\udd17 Accelerate. That cache folder is (with decreasing order of priority):\n\n- The content of your environment variable `HF_HOME` suffixed with *accelerate*.\n- If it does not exist, the content of your environment variable `XDG_CACHE_HOME` suffixed with\n  *huggingface/accelerate*.\n- If this does not exist either, the folder *~/.cache/huggingface/accelerate*\n\nYou can also specify with the flag `--config_file` the location of the file you want to save.\n\nOnce this is done, you can test everything is going well on your setup by running:\n\n```bash\naccelerate test\n```\n\nThis will launch a short script that will test the distributed environment. If it runs fine, you are ready for the next\nstep!\n\nNote that if you specified a location for the config file in the previous step, you need to pass it here as well:\n\n```bash\naccelerate test --config_file path_to_config.yaml\n```\n\nNow that this is done, you can run your script with the following command:\n\n```bash\naccelerate launch path_to_script.py --args_for_the_script\n```\n\nIf you stored the config file in a non-default location, you can indicate it to the launcher like this:\n\n```bash\naccelerate launch --config_file path_to_config.yaml path_to_script.py --args_for_the_script\n```\n\nYou can also override any of the arguments determined by your config file. \nTo see the complete list of parameters that you can pass in, run `accelerate launch -h`. \n\nCheck out the [Launch tutorial](basic_tutorials/launch) for more information about launching your scripts. \n\n\n## Launching training from a notebook\n\nIn Accelerate 0.3.0, a new [`notebook_launcher`] has been introduced to help you launch your training\nfunction from a notebook. This launcher supports launching a training with TPUs on Colab or Kaggle, as well as training\non several GPUs (if the machine on which you are running your notebook has them).\n\nJust define a function responsible for your whole training and/or evaluation in a cell of the notebook, then execute a\ncell with the following code:\n\n```python\nfrom accelerate import notebook_launcher\n\nnotebook_launcher(training_function)\n```\n\n<Tip warning={true}>\n\n    Your [`Accelerator`] object should only be defined inside the training function. This is because the\n    initialization should be done inside the launcher only.\n\n</Tip>\n\nCheck out the [Notebook Launcher tutorial](basic_tutorials/notebook) for more information about training on TPUs. \n\n\n## Training on TPU\n\nIf you want to launch your script on TPUs, there are a few caveats you should be aware of. Behind the scenes, the TPUs\nwill create a graph of all the operations happening in your training step (forward pass, backward pass and optimizer\nstep). This is why your first step of training will always be very long as building and compiling this graph for\noptimizations takes some time.\n\nThe good news is that this compilation will be cached so the second step and all the following will be much faster. The\nbad news is that it only applies if all of your steps do exactly the same operations, which implies:\n\n- having all tensors of the same length in all your batches\n- having static code (i.e., not a for loop of length that could change from step to step)\n\nHaving any of the things above change between two steps will trigger a new compilation which will, once again, take a\nlot of time. In practice, that means you must take special care to have all your tensors in your inputs of the same\nshape (so no dynamic padding for instance if you are in an NLP problem) and should not use layers with for loops that\nhave different lengths depending on the inputs (such as an LSTM) or the training will be excruciatingly slow.\n\nTo introduce special behavior in your script for TPUs you can check the `distributed_type` of your\n`accelerator`:\n\n```python docstyle-ignore\nfrom accelerate import DistributedType\n\nif accelerator.distributed_type == DistributedType.TPU:\n    # do something of static shape\nelse:\n    # go crazy and be dynamic\n```\n\nThe [NLP example](https://github.com/huggingface/accelerate/blob/main/examples/nlp_example.py) shows an example in a \nsituation with dynamic padding.\n\nOne last thing to pay close attention to: if your model has tied weights (such as language models which tie the weights\nof the embedding matrix with the weights of the decoder), moving this model to the TPU (either yourself or after you\npassed your model to [`~Accelerator.prepare`]) will break the tying. You will need to retie the weights\nafter. You can find an example of this in the [run_clm_no_trainer](https://github.com/huggingface/transformers/blob/master/examples/pytorch/language-modeling/run_clm.py) script in\nthe Transformers repository.\n\nCheck out the [TPU tutorial](concept_guides/training_tpu) for more information about training on TPUs. \n\n\n## Other caveats\n\nWe list here all smaller issues you could have in your script conversion and how to resolve them.\n\n### Execute a statement only on one processes\n\nSome of your instructions only need to run for one process on a given server: for instance a data download or a log\nstatement. To do this, wrap the statement in a test like this:\n\n```python docstyle-ignore\nif accelerator.is_local_main_process:\n    # Is executed once per server\n```\n\nAnother example is progress bars: to avoid having multiple progress bars in your output, you should only display one on\nthe local main process:\n\n```python\nfrom tqdm.auto import tqdm\n\nprogress_bar = tqdm(range(args.max_train_steps), disable=not accelerator.is_local_main_process)\n```\n\nThe *local* means per machine: if you are running your training on two servers with several GPUs, the instruction will\nbe executed once on each of those servers. If you need to execute something only once for all processes (and not per\nmachine) for instance, uploading the final model to the \ud83e\udd17 model hub, wrap it in a test like this:\n\n```python docstyle-ignore\nif accelerator.is_main_process:\n    # Is executed once only\n```\n\nFor printing statements you only want executed once per machine, you can just replace the `print` function by\n`accelerator.print`.\n\n\n### Defer execution\n\nWhen you run your usual script, instructions are executed in order. Using \ud83e\udd17 Accelerate to deploy your script on several\nGPUs at the same time introduces a complication: while each process executes all instructions in order, some may be\nfaster than others.\n\nYou might need to wait for all processes to have reached a certain point before executing a given instruction. For\ninstance, you shouldn't save a model before being sure every process is done with training. To do this, just write the\nfollowing line in your code:\n\n```\naccelerator.wait_for_everyone()\n```\n\nThis instruction will block all the processes that arrive first until all the other processes have reached that\npoint (if you run your script on just one GPU or CPU, this won't do anything).\n\n\n### Saving/loading a model\n\nSaving the model you trained might need a bit of adjustment: first you should wait for all processes to reach that\npoint in the script as shown above, and then, you should unwrap your model before saving it. This is because when going\nthrough the [`~Accelerator.prepare`] method, your model may have been placed inside a bigger model,\nwhich deals with the distributed training. This in turn means that saving your model state dictionary without taking\nany precaution will take that potential extra layer into account, and you will end up with weights you can't load back\nin your base model. The [`~Accelerator.save_model`] method will help you to achieve that. It will unwrap your model and save\nthe model state dictionnary.\n\nHere is an example:\n```\naccelerator.wait_for_everyone()\naccelerator.save_model(model, save_directory)\n```\nThe [`~Accelerator.save_model`] method can also save a model into sharded checkpoints or with safetensors format.\nHere is an example: \n\n```python\naccelerator.wait_for_everyone()\naccelerator.save_model(model, save_directory, max_shard_size=\"1GB\", safe_serialization=True)\n```\n\nIf your script contains logic to load a checkpoint, we also recommend you load your weights in the unwrapped model\n(this is only useful if you use the load function after making your model go through\n[`~Accelerator.prepare`]). Here is an example:\n\n```python\nunwrapped_model = accelerator.unwrap_model(model)\npath_to_checkpoint = os.path.join(save_directory,\"pytorch_model.bin\")\nunwrapped_model.load_state_dict(torch.load(path_to_checkpoint))\n```\n\nNote that since all the model parameters are references to tensors, this will load your weights inside `model`.\n\nIf you want to load a sharded checkpoint or a checkpoint with safetensors format into the model with a specific `device`, we recommend you to load it with [`~utils.load_checkpoint_in_model`] function. Here's an example:\n\n```python\nload_checkpoint_in_model(unwrapped_model, save_directory, device_map={\"\":device})\n```\n\n## Saving/loading entire states\n\nWhen training your model, you may want to save the current state of the model, optimizer, random generators, and potentially LR schedulers to be restored in the _same script_.\nYou can use [`~Accelerator.save_state`] and [`~Accelerator.load_state`] respectively to do so.\n\nTo further customize where and how states saved through [`~Accelerator.save_state`] the [`~utils.ProjectConfiguration`] class can be used. For example \nif `automatic_checkpoint_naming` is enabled each saved checkpoint will be located then at `Accelerator.project_dir/checkpoints/checkpoint_{checkpoint_number}`.\n\nIf you have registered any other stateful items to be stored through [`~Accelerator.register_for_checkpointing`] they will also be saved and/or loaded.\n\n<Tip>\n\n    Every object passed to [`~Accelerator.register_for_checkpointing`] must have a `load_state_dict` and `state_dict` function to be stored\n\n</Tip>\n\n\n### Gradient clipping\n\nIf you are using gradient clipping in your script, you should replace the calls to\n`torch.nn.utils.clip_grad_norm_` or `torch.nn.utils.clip_grad_value_` with [`~Accelerator.clip_grad_norm_`]\nand [`~Accelerator.clip_grad_value_`] respectively.\n\n\n### Mixed Precision training\n\nIf you are running your training in Mixed Precision with \ud83e\udd17 Accelerate, you will get the best result with your loss being\ncomputed inside your model (like in Transformer models for instance). Every computation outside of the model will be\nexecuted in full precision (which is generally what you want for loss computation, especially if it involves a\nsoftmax). However you might want to put your loss computation inside the [`~Accelerator.autocast`] context manager:\n\n```\nwith accelerator.autocast():\n    loss = complex_loss_function(outputs, target):\n```\n\nAnother caveat with Mixed Precision training is that the gradient will skip a few updates at the beginning and\nsometimes during training: because of the dynamic loss scaling strategy, there are points during training where the\ngradients have overflown, and the loss scaling factor is reduced to avoid this happening again at the next step.\n\nThis means that you may update your learning rate scheduler when there was no update, which is fine in general, but may\nhave an impact when you have very little training data, or if the first learning rate values of your scheduler are very\nimportant. In this case, you can skip the learning rate scheduler updates when the optimizer step was not done like\nthis:\n\n```\nif not accelerator.optimizer_step_was_skipped:\n    lr_scheduler.step()\n```\n\n### Gradient Accumulation \n\nTo perform gradient accumulation use [`~Accelerator.accumulate`] and specify a `gradient_accumulation_steps`. \nThis will also automatically ensure the gradients are synced or unsynced when on multi-device training, check if the step should\nactually be performed, and auto-scale the loss:\n\n```python\naccelerator = Accelerator(gradient_accumulation_steps=2)\nmodel, optimizer, training_dataloader = accelerator.prepare(model, optimizer, training_dataloader)\n\nfor input, label in training_dataloader:\n    with accelerator.accumulate(model):\n        predictions = model(input)\n        loss = loss_function(predictions, label)\n        accelerator.backward(loss)\n        optimizer.step()\n        scheduler.step()\n        optimizer.zero_grad()\n```\n\n### DeepSpeed\n\nDeepSpeed support is experimental, so the underlying API will evolve in the near future and may have some slight\nbreaking changes. In particular, \ud83e\udd17 Accelerate does not support DeepSpeed config you have written yourself yet, this\nwill be added in a next version.\n\n<Tip warning={true}>\n\n    The [`notebook_launcher`] does not support the DeepSpeed integration yet.\n\n</Tip>\n\n## Internal mechanism\n\nInternally, the library works by first analyzing the environment in which the script is launched to determine which\nkind of distributed setup is used, how many different processes there are and which one the current script is in. All\nthat information is stored in the [`~AcceleratorState`].\n\nThis class is initialized the first time you instantiate an [`~Accelerator`] as well as performing any\nspecific initialization your distributed setup needs. Its state is then uniquely shared through all instances of\n[`~state.AcceleratorState`].\n\nThen, when calling [`~Accelerator.prepare`], the library:\n\n- wraps your model(s) in the container adapted for the distributed setup,\n- wraps your optimizer(s) in a [`~optimizer.AcceleratedOptimizer`],\n- creates a new version of your dataloader(s) in a [`~data_loader.DataLoaderShard`].\n\nWhile the model(s) and optimizer(s) are just put in simple wrappers, the dataloader(s) are re-created. This is mostly\nbecause PyTorch does not let the user change the `batch_sampler` of a dataloader once it's been created and the\nlibrary handles the sharding of your data between processes by changing that `batch_sampler` to yield every other\n`num_processes` batches.\n\nThe [`~data_loader.DataLoaderShard`] subclasses `DataLoader` to add the following functionality:\n\n- it synchronizes the appropriate random number generator of all processes at each new iteration, to ensure any\n  randomization (like shuffling) is done the exact same way across processes.\n- it puts the batches on the proper device before yielding them (unless you have opted out of\n  `device_placement=True`).\n\nThe random number generator synchronization will by default synchronize:\n\n- the `generator` attribute of a given sampler (like the PyTorch `RandomSampler`) for PyTorch >= 1.6\n- the main random number generator in PyTorch <=1.5.1\n\nYou can choose which random number generator(s) to synchronize with the `rng_types` argument of the main\n[`Accelerator`]. In PyTorch >= 1.6, it is recommended to rely on a local `generator` to avoid\nsetting the same seed in the main random number generator in all processes.\n\n<Tip warning={true}>\n\n    Synchronization of the main torch (or CUDA or XLA) random number generator will affect any other potential random\n    artifacts you could have in your dataset (like random data augmentation) in the sense that all processes will get\n    the same random numbers from the torch random modules (so will apply the same random data augmentation if it's\n    controlled by torch).\n\n</Tip>\n\n<Tip>\n\n    The randomization part of your custom sampler, batch sampler or iterable dataset should be done using a local\n    `torch.Generator` object (in PyTorch >= 1.6), see the traditional `RandomSampler`, as an example.\n\n</Tip>\n\nFor more details about the internals, see the [Internals page](package_reference/torch_wrappers).\n", "<!--Copyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\nspecific language governing permissions and limitations under the License.\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n-->\n\n# Accelerate\n\n\ud83e\udd17 Accelerate is a library that enables the same PyTorch code to be run across any distributed configuration by adding just four lines of code! In short, training and inference at scale made simple, efficient and adaptable.\n\n```diff\n+ from accelerate import Accelerator\n+ accelerator = Accelerator()\n\n+ model, optimizer, training_dataloader, scheduler = accelerator.prepare(\n+     model, optimizer, training_dataloader, scheduler\n+ )\n\n  for batch in training_dataloader:\n      optimizer.zero_grad()\n      inputs, targets = batch\n      inputs = inputs.to(device)\n      targets = targets.to(device)\n      outputs = model(inputs)\n      loss = loss_function(outputs, targets)\n+     accelerator.backward(loss)\n      optimizer.step()\n      scheduler.step()\n```\n\nBuilt on `torch_xla` and `torch.distributed`, \ud83e\udd17 Accelerate takes care of the heavy lifting, so you don't have to write any custom code to adapt to these platforms.\nConvert existing codebases to utilize [DeepSpeed](usage_guides/deepspeed), perform [fully sharded data parallelism](usage_guides/fsdp), and have automatic support for mixed-precision training! \n\n<Tip> \n\n  To get a better idea of this process, make sure to check out the [Tutorials](basic_tutorials/overview)! \n\n</Tip>\n\n\nThis code can then be launched on any system through Accelerate's CLI interface:\n```bash\naccelerate launch {my_script.py}\n```\n\n<div class=\"mt-10\">\n  <div class=\"w-full flex flex-col space-y-4 md:space-y-0 md:grid md:grid-cols-2 md:gap-y-4 md:gap-x-5\">\n    <a class=\"!no-underline border dark:border-gray-700 p-5 rounded-lg shadow hover:shadow-lg\" href=\"./basic_tutorials/overview\"\n      ><div class=\"w-full text-center bg-gradient-to-br from-blue-400 to-blue-500 rounded-lg py-1.5 font-semibold mb-5 text-white text-lg leading-relaxed\">Tutorials</div>\n      <p class=\"text-gray-700\">Learn the basics and become familiar with using \ud83e\udd17 Accelerate. Start here if you are using \ud83e\udd17 Accelerate for the first time!</p>\n    </a>\n    <a class=\"!no-underline border dark:border-gray-700 p-5 rounded-lg shadow hover:shadow-lg\" href=\"./usage_guides/explore\"\n      ><div class=\"w-full text-center bg-gradient-to-br from-indigo-400 to-indigo-500 rounded-lg py-1.5 font-semibold mb-5 text-white text-lg leading-relaxed\">How-to guides</div>\n      <p class=\"text-gray-700\">Practical guides to help you achieve a specific goal. Take a look at these guides to learn how to use \ud83e\udd17 Accelerate to solve real-world problems.</p>\n    </a>\n    <a class=\"!no-underline border dark:border-gray-700 p-5 rounded-lg shadow hover:shadow-lg\" href=\"./concept_guides/gradient_synchronization\"\n      ><div class=\"w-full text-center bg-gradient-to-br from-pink-400 to-pink-500 rounded-lg py-1.5 font-semibold mb-5 text-white text-lg leading-relaxed\">Conceptual guides</div>\n      <p class=\"text-gray-700\">High-level explanations for building a better understanding of important topics such as avoiding subtle nuances and pitfalls in distributed training and DeepSpeed.</p>\n   </a>\n    <a class=\"!no-underline border dark:border-gray-700 p-5 rounded-lg shadow hover:shadow-lg\" href=\"./package_reference/accelerator\"\n      ><div class=\"w-full text-center bg-gradient-to-br from-purple-400 to-purple-500 rounded-lg py-1.5 font-semibold mb-5 text-white text-lg leading-relaxed\">Reference</div>\n      <p class=\"text-gray-700\">Technical descriptions of how \ud83e\udd17 Accelerate classes and methods work.</p>\n    </a>\n  </div>\n</div>\n", "- sections:\n  - local: index\n    title: \ud83e\udd17 Accelerate\n  - local: basic_tutorials/install\n    title: Installation\n  - local: quicktour\n    title: Quicktour\n  title: Getting started\n- sections:\n  - local: basic_tutorials/overview\n    title: Overview\n  - local: basic_tutorials/migration\n    title: Migrating to \ud83e\udd17 Accelerate\n  - local: basic_tutorials/launch\n    title: Launching distributed code\n  - local: basic_tutorials/notebook\n    title: Launching distributed training from Jupyter Notebooks\n  title: Tutorials\n- sections:\n  - local: usage_guides/explore\n    title: Start Here!\n  - local: usage_guides/training_zoo\n    title: Example Zoo\n  - local: usage_guides/big_modeling\n    title: How to perform inference on large models with small resources\n  - local: usage_guides/quantization\n    title: How to quantize model \n  - local: usage_guides/distributed_inference\n    title: How to perform distributed inference with normal resources\n  - local: usage_guides/gradient_accumulation\n    title: Performing gradient accumulation\n  - local: usage_guides/local_sgd\n    title: Accelerating training with local SGD\n  - local: usage_guides/checkpoint\n    title: Saving and loading training states\n  - local: usage_guides/tracking\n    title: Using experiment trackers\n  - local: usage_guides/debug\n    title: Debugging timeout errors\n  - local: usage_guides/memory\n    title: How to avoid CUDA Out-of-Memory\n  - local: usage_guides/mps\n    title: How to use Apple Silicon M1 GPUs\n  - local: usage_guides/deepspeed\n    title: How to use DeepSpeed\n  - local: usage_guides/fsdp\n    title: How to use Fully Sharded Data Parallelism\n  - local: usage_guides/megatron_lm\n    title: How to use Megatron-LM\n  - local: usage_guides/sagemaker\n    title: How to use \ud83e\udd17 Accelerate with SageMaker\n  - local: usage_guides/ipex\n    title: How to use \ud83e\udd17 Accelerate with Intel\u00ae Extension for PyTorch for cpu\n  title: How-To Guides\n- sections:\n  - local: concept_guides/performance\n    title: Comparing performance across distributed setups\n  - local: concept_guides/deferring_execution\n    title: Executing and deferring jobs\n  - local: concept_guides/gradient_synchronization\n    title: Gradient synchronization\n  - local: concept_guides/training_tpu\n    title: TPU best practices\n  title: Concepts and fundamentals\n- sections: \n  - local: package_reference/accelerator\n    title: Main Accelerator class\n  - local: package_reference/state\n    title: Stateful configuration classes\n  - local: package_reference/cli\n    title: The Command Line\n  - local: package_reference/torch_wrappers\n    title: Torch wrapper classes\n  - local: package_reference/tracking\n    title: Experiment trackers\n  - local: package_reference/launchers\n    title: Distributed launchers\n  - local: package_reference/deepspeed\n    title: DeepSpeed utilities\n  - local: package_reference/logging\n    title: Logging\n  - local: package_reference/big_modeling\n    title: Working with large models\n  - local: package_reference/kwargs\n    title: Kwargs handlers\n  - local: package_reference/utilities\n    title: Utility functions and classes\n  - local: package_reference/megatron_lm\n    title: Megatron-LM Utilities\n  - local: package_reference/fsdp\n    title: Fully Sharded Data Parallelism Utilities\n  title: \"Reference\"\n", "<!--Copyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\nspecific language governing permissions and limitations under the License.\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n-->\n\n# Accelerated PyTorch Training on Mac\n\nWith PyTorch v1.12 release, developers and researchers can take advantage of Apple silicon GPUs for significantly faster model training. \nThis unlocks the ability to perform machine learning workflows like prototyping and fine-tuning locally, right on Mac.\nApple's Metal Performance Shaders (MPS) as a backend for PyTorch enables this and can be used via the new `\"mps\"` device. \nThis will map computational graphs and primitives on the MPS Graph framework and tuned kernels provided by MPS.\nFor more information please refer official documents [Introducing Accelerated PyTorch Training on Mac](https://pytorch.org/blog/introducing-accelerated-pytorch-training-on-mac/)\nand [MPS BACKEND](https://pytorch.org/docs/stable/notes/mps.html).\n\n### Benefits of Training and Inference using Apple Silicon Chips\n\n1. Enables users to train larger networks or batch sizes locally\n2. Reduces data retrieval latency and provides the GPU with direct access to the full memory store due to unified memory architecture. \nTherefore, improving end-to-end performance.\n3. Reduces costs associated with cloud-based development or the need for additional local GPUs.\n\n**Pre-requisites**: To install torch with mps support, \nplease follow this nice medium article [GPU-Acceleration Comes to PyTorch on M1 Macs](https://medium.com/towards-data-science/gpu-acceleration-comes-to-pytorch-on-m1-macs-195c399efcc1).\n\n\n## How it works out of the box\nIt is enabled by default on MacOs machines with MPS enabled Apple Silicon GPUs.\nTo disable it, pass `--cpu` flag to `accelerate launch` command or answer the corresponding question when answering the `accelerate config` questionnaire.\n\nYou can directly run the following script to test it out on MPS enabled Apple Silicon machines:\n```bash\naccelerate launch /examples/cv_example.py --data_dir images\n```\n\n## A few caveats to be aware of\n\n1. We strongly recommend to install PyTorch >= 1.13 (nightly version at the time of writing) on your MacOS machine. \nIt has major fixes related to model correctness and performance improvements for transformer based models.\nPlease refer to https://github.com/pytorch/pytorch/issues/82707 for more details.\n2. Distributed setups `gloo` and `nccl` are not working with `mps` device. \nThis means that currently only single GPU of `mps` device type can be used.\n\nFinally, please, remember that, \ud83e\udd17 `Accelerate` only integrates MPS backend, therefore if you\nhave any problems or questions with regards to MPS backend usage, please, file an issue with [PyTorch GitHub](https://github.com/pytorch/pytorch/issues).", "<!--Copyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\nspecific language governing permissions and limitations under the License.\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n-->\n\n# Checkpointing\n\nWhen training a PyTorch model with \ud83e\udd17 Accelerate, you may often want to save and continue a state of training. Doing so requires\nsaving and loading the model, optimizer, RNG generators, and the GradScaler. Inside \ud83e\udd17 Accelerate are two convenience functions to achieve this quickly:\n- Use [`~Accelerator.save_state`] for saving everything mentioned above to a folder location\n- Use [`~Accelerator.load_state`] for loading everything stored from an earlier `save_state`\n\nTo further customize where and how states are saved through [`~Accelerator.save_state`] the [`~utils.ProjectConfiguration`] class can be used. For example \nif `automatic_checkpoint_naming` is enabled each saved checkpoint will be located then at `Accelerator.project_dir/checkpoints/checkpoint_{checkpoint_number}`.\n\nIt should be noted that the expectation is that those states come from the same training script, they should not be from two separate scripts.\n\n- By using [`~Accelerator.register_for_checkpointing`], you can register custom objects to be automatically stored or loaded from the two prior functions,\nso long as the object has a `state_dict` **and** a `load_state_dict` functionality. This could include objects such as a learning rate scheduler. \n\n\nBelow is a brief example using checkpointing to save and reload a state during training:\n\n```python\nfrom accelerate import Accelerator\nimport torch\n\naccelerator = Accelerator(project_dir=\"my/save/path\")\n\nmy_scheduler = torch.optim.lr_scheduler.StepLR(my_optimizer, step_size=1, gamma=0.99)\nmy_model, my_optimizer, my_training_dataloader = accelerator.prepare(my_model, my_optimizer, my_training_dataloader)\n\n# Register the LR scheduler\naccelerator.register_for_checkpointing(my_scheduler)\n\n# Save the starting state\naccelerator.save_state()\n\ndevice = accelerator.device\nmy_model.to(device)\n\n# Perform training\nfor epoch in range(num_epochs):\n    for batch in my_training_dataloader:\n        my_optimizer.zero_grad()\n        inputs, targets = batch\n        inputs = inputs.to(device)\n        targets = targets.to(device)\n        outputs = my_model(inputs)\n        loss = my_loss_function(outputs, targets)\n        accelerator.backward(loss)\n        my_optimizer.step()\n    my_scheduler.step()\n\n# Restore the previous state\naccelerator.load_state(\"my/save/path/checkpointing/checkpoint_0\")\n```\n\n## Restoring the state of the DataLoader \n\nAfter resuming from a checkpoint, it may also be desirable to resume from a particular point in the active `DataLoader` if \nthe state was saved during the middle of an epoch. You can use [`~Accelerator.skip_first_batches`] to do so. \n\n```python\nfrom accelerate import Accelerator\n\naccelerator = Accelerator(project_dir=\"my/save/path\")\n\ntrain_dataloader = accelerator.prepare(train_dataloader)\naccelerator.load_state(\"my_state\")\n\n# Assume the checkpoint was saved 100 steps into the epoch\nskipped_dataloader = accelerator.skip_first_batches(train_dataloader, 100)\n\n# After the first iteration, go back to `train_dataloader`\n\n# First epoch\nfor batch in skipped_dataloader:\n    # Do something\n    pass\n\n# Second epoch\nfor batch in train_dataloader:\n    # Do something\n    pass\n```\n", "<!--Copyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\nspecific language governing permissions and limitations under the License.\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n-->\n\n# Debugging Distributed Operations\n\nWhen running scripts in a distributed fashion, often functions such as [`Accelerator.gather`] and [`Accelerator.reduce`] (and others) are neccessary to grab tensors across devices and perform certain operations on them. However, if the tensors which are being grabbed are not the proper shapes then this will result in your code hanging forever. The only sign that exists of this truly happening is hitting a timeout exception from `torch.distributed`, but this can get quite costly as usually the timeout is 10 minutes.\n\nAccelerate now has a `debug` mode which adds a neglible amount of time to each operation, but allows it to verify that the inputs you are bringing in can *actually* perform the operation you want **without** hitting this timeout problem!\n\n## Visualizing the problem\n\nTo have a tangible example of this issue, let's take the following setup (on 2 GPUs):\n\n```python\nfrom accelerate import PartialState\n\nstate = PartialState()\nif state.process_index == 0:\n    tensor = torch.tensor([[0.0, 1, 2, 3, 4]]).to(state.device)\nelse:\n    tensor = torch.tensor([[[0.0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]]).to(state.device)\n\nbroadcast_tensor = broadcast(tensor)\nprint(broadcast_tensor)\n```\n\nWe've created a single tensor on each device, with two radically different shapes. With this setup if we want to perform an operation such as [`utils.broadcast`], we would forever hit a timeout because `torch.distributed` requires that these operations have the **exact same shape** across all processes for it to work.\n\nIf you run this yourself, you will find that `broadcast_tensor` can be printed on the main process, but its results won't quite be right, and then it will just hang never printing it on any of the other processes:\n\n```\n>>> tensor([[0, 1, 2, 3, 4]], device='cuda:0')\n```\n\n## The solution\n\nBy enabling Accelerate's operational debug mode, Accelerate will properly find and catch errors such as this and provide a very clear traceback immediatly: \n\n```\nTraceback (most recent call last):\n  File \"/home/zach_mueller_huggingface_co/test.py\", line 18, in <module>\n    main()\n  File \"/home/zach_mueller_huggingface_co/test.py\", line 15, in main\n        main()broadcast_tensor = broadcast(tensor)\n  File \"/home/zach_mueller_huggingface_co/accelerate/src/accelerate/utils/operations.py\", line 303, in wrapper\n    broadcast_tensor = broadcast(tensor)\naccelerate.utils.operations.DistributedOperationException: Cannot apply desired operation due to shape mismatches. All shapes across devices must be valid.\n\nOperation: `accelerate.utils.operations.broadcast`\nInput shapes:\n  - Process 0: [1, 5]\n  - Process 1: [1, 2, 5]\n```\n\nThis explains that the shapes across our devices were *not* the same, and that we should ensure that they match properly to be compatible. Typically this means that there is either an extra dimension, or certain dimensions are incompatible with the operation.\n\nTo enable this please do one of the following:\n\nEnable it through the questionarre during `accelerate config` (recommended)\n\nFrom the CLI: \n\n```\naccelerate launch --debug {my_script.py} --arg1 --arg2\n```\n\nAs an environmental variable (which avoids the need for `accelerate launch`):\n\n```\nACCELERATE_DEBUG_MODE=\"1\" accelerate launch {my_script.py} --arg1 --arg2\n```\n\nManually changing the `config.yaml` file:\n\n```diff\n compute_environment: LOCAL_MACHINE\n+debug: true\n```\n\n\n\n", "<!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\nspecific language governing permissions and limitations under the License.\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n-->\n\n# Using Local SGD with \ud83e\udd17 Accelerate\n\nLocal SGD is a technique for distributed training where gradients are not synchronized every step. Thus, each process updates its own version of the model weights and after a given number of steps these weights are synchronized by averaging across all processes. This improves communication efficiency and can lead to substantial training speed up especially when a computer lacks a faster interconnect such as NVLink.\nUnlike gradient accumulation (where improving communication efficiency requires increasing the effective batch size), Local SGD does not require changing a batch size or a learning rate / schedule. However, if necessary, Local SGD can be combined with gradient accumulation as well.\n\nIn this tutorial you will see how to quickly setup  Local SGD \ud83e\udd17 Accelerate. Compared to a standard Accelerate setup, this requires only two extra lines of code.\n\nThis example will use a very simplistic PyTorch training loop that performs gradient accumulation every two batches:\n\n```python\ndevice = \"cuda\"\nmodel.to(device)\n\ngradient_accumulation_steps = 2\n\nfor index, batch in enumerate(training_dataloader):\n    inputs, targets = batch\n    inputs = inputs.to(device)\n    targets = targets.to(device)\n    outputs = model(inputs)\n    loss = loss_function(outputs, targets)\n    loss = loss / gradient_accumulation_steps\n    loss.backward()\n    if (index + 1) % gradient_accumulation_steps == 0:\n        optimizer.step()\n        scheduler.step()\n        optimizer.zero_grad()\n```\n\n## Converting it to \ud83e\udd17 Accelerate\n\nFirst the code shown earlier will be converted to use \ud83e\udd17 Accelerate  with neither a LocalSGD or a gradient accumulation helper:\n\n```diff\n+ from accelerate import Accelerator\n+ accelerator = Accelerator()\n\n+ model, optimizer, training_dataloader, scheduler = accelerator.prepare(\n+     model, optimizer, training_dataloader, scheduler\n+ )\n\n  for index, batch in enumerate(training_dataloader):\n      inputs, targets = batch\n-     inputs = inputs.to(device)\n-     targets = targets.to(device)\n      outputs = model(inputs)\n      loss = loss_function(outputs, targets)\n      loss = loss / gradient_accumulation_steps\n+     accelerator.backward(loss)\n      if (index+1) % gradient_accumulation_steps == 0:\n          optimizer.step()\n          scheduler.step()\n```\n\n## Letting \ud83e\udd17 Accelerate handle model synchronization \n\nAll that is left now is to let \ud83e\udd17 Accelerate handle model parameter synchronization **and** the gradient accumulation for us. For simplicity let us assume we need to synchronize every 8 steps. This is\nachieved by adding one `with LocalSGD` statement and one call `local_sgd.step()` after every optimizer step:\n\n```diff\n+local_sgd_steps=8\n\n+with LocalSGD(accelerator=accelerator, model=model, local_sgd_steps=8, enabled=True) as local_sgd:\n    for batch in training_dataloader:\n        with accelerator.accumulate(model):\n            inputs, targets = batch\n            outputs = model(inputs)\n            loss = loss_function(outputs, targets)\n            accelerator.backward(loss)\n            optimizer.step()\n            scheduler.step()\n            optimizer.zero_grad()\n+           local_sgd.step()\n```\n\nUnder the hood, the Local SGD code **disables** automatic gradient synchornization (but accumulation still works as expected!). Instead it averages model parameters every `local_sgd_steps` steps (as well as in the end of the training loop).\n\n## Limitations\n\nThe current implementation works only with basic multi-GPU (or multi-CPU) training without, e.g., [DeepSpeed.](https://github.com/microsoft/DeepSpeed).\n\n## References\n\n    Although we are not aware of the true origins of this simple approach, the idea of local SGD is quite old and goes\n    back to at least:\n\n    Zhang, J., De Sa, C., Mitliagkas, I., & R\u00e9, C. (2016). [Parallel SGD: When does averaging help?. arXiv preprint\n    arXiv:1606.07365.](https://arxiv.org/abs/1606.07365)\n\n    We credit the term Local SGD to the following paper (but there might be earlier references we are not aware of).\n\n    Stich, Sebastian Urban. [\"Local SGD Converges Fast and Communicates Little.\" ICLR 2019-International Conference on\n    Learning Representations. No. CONF. 2019.](https://arxiv.org/abs/1805.09767)\n", "<!--Copyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\nspecific language governing permissions and limitations under the License.\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n-->\n\n# Fully Sharded Data Parallel\n\nTo accelerate training huge models on larger batch sizes, we can use a fully sharded data parallel model.\nThis type of data parallel paradigm enables fitting more data and larger models by sharding the optimizer states, gradients and parameters.\nTo read more about it and the benefits, check out the [Fully Sharded Data Parallel blog](https://pytorch.org/blog/introducing-pytorch-fully-sharded-data-parallel-api/).\nWe have integrated the latest PyTorch's Fully Sharded Data Parallel (FSDP) training feature.\nAll you need to do is enable it through the config.\n\n## How it works out of the box\n\nOn your machine(s) just run:\n\n```bash\naccelerate config\n```\n\nand answer the questions asked. This will generate a config file that will be used automatically to properly set the\ndefault options when doing\n\n```bash\naccelerate launch my_script.py --args_to_my_script\n```\n\nFor instance, here is how you would run the NLP example (from the root of the repo) with FSDP enabled:\n\n```bash\ncompute_environment: LOCAL_MACHINE\ndeepspeed_config: {}\ndistributed_type: FSDP\ndowncast_bf16: 'no'\nfsdp_config:\n  fsdp_auto_wrap_policy: TRANSFORMER_BASED_WRAP\n  fsdp_backward_prefetch_policy: BACKWARD_PRE\n  fsdp_offload_params: false\n  fsdp_sharding_strategy: 1\n  fsdp_state_dict_type: FULL_STATE_DICT\n  fsdp_transformer_layer_cls_to_wrap: GPT2Block\nmachine_rank: 0\nmain_process_ip: null\nmain_process_port: null\nmain_training_function: main\nmixed_precision: 'no'\nnum_machines: 1\nnum_processes: 2\nuse_cpu: false\n```\n\n```bash\naccelerate launch examples/nlp_example.py\n```\n\nCurrently, `Accelerate` supports the following config through the CLI:\n\n```bash\n`Sharding Strategy`: [1] FULL_SHARD (shards optimizer states, gradients and parameters), [2] SHARD_GRAD_OP (shards optimizer states and gradients), [3] NO_SHARD\n`Offload Params`: Decides Whether to offload parameters and gradients to CPU\n`Auto Wrap Policy`: [1] TRANSFORMER_BASED_WRAP, [2] SIZE_BASED_WRAP, [3] NO_WRAP [4] \"HYBRID_SHARD\" [5] \"HYBRID_SHARD_ZERO2\"\n`Transformer Layer Class to Wrap`: When using `TRANSFORMER_BASED_WRAP`, user specifies comma-separated string of transformer layer class names (case-sensitive) to wrap ,e.g, \n`BertLayer`, `GPTJBlock`, `T5Block`, `BertLayer,BertEmbeddings,BertSelfOutput`...\n`Min Num Params`: minimum number of parameters when using `SIZE_BASED_WRAP`\n`Backward Prefetch`: [1] BACKWARD_PRE, [2] BACKWARD_POST, [3] NO_PREFETCH\n`State Dict Type`: [1] FULL_STATE_DICT, [2] LOCAL_STATE_DICT, [3] SHARDED_STATE_DICT  \n`Use Orig Params`: If True, allows non-uniform `requires_grad` during init, which means support for interspersed frozen and trainable paramteres. \nUseful in cases such as parameter-efficient fine-tuning. \nPlease refer this [blog](https://dev-discuss.pytorch.org/t/rethinking-pytorch-fully-sharded-data-parallel-fsdp-from-first-principles/1019)\n`Sync Module States`: If True, each individually wrapped FSDP unit will broadcast module parameters from rank 0\n`Forward Prefetch`: If True, then FSDP explicitly prefetches the next upcoming all-gather while executing in the forward pass\n```\n\nFor additional and more nuanced control, you can specify other FSDP parameters via `FullyShardedDataParallelPlugin`. \nWhen creating `FullyShardedDataParallelPlugin` object, pass it the parameters that weren't part of the accelerate config or if you want to override them.\nThe FSDP parameters will be picked based on the accelerate config file or launch command arguments and other parameters that you will pass directly through the `FullyShardedDataParallelPlugin` object will set/override that.\n\nBelow is an example:\n\n```py\nfrom accelerate import FullyShardedDataParallelPlugin\nfrom torch.distributed.fsdp.fully_sharded_data_parallel import FullOptimStateDictConfig, FullStateDictConfig\n\nfsdp_plugin = FullyShardedDataParallelPlugin(\n    state_dict_config=FullStateDictConfig(offload_to_cpu=False, rank0_only=False),\n    optim_state_dict_config=FullOptimStateDictConfig(offload_to_cpu=False, rank0_only=False),\n)\n\naccelerator = Accelerator(fsdp_plugin=fsdp_plugin)\n```\n\n## Saving and loading\n\nThe new recommended way of checkpointing when using FSDP models is to use `SHARDED_STATE_DICT` as `StateDictType` when setting up the accelerate config.\nBelow is the code snippet to save using `save_state` utility of accelerate.\n\n```py\naccelerator.save_state(\"ckpt\")\n```\n\nInspect the ckeckpoint folder to see model and optimizer as shards per process:\n```\nls ckpt \n# optimizer_0  pytorch_model_0  random_states_0.pkl  random_states_1.pkl  scheduler.bin\n\ncd ckpt\n\nls optimizer_0\n# __0_0.distcp  __1_0.distcp\n\nls pytorch_model_0\n# __0_0.distcp  __1_0.distcp\n```\n\nTo load them back for resuming the training, use the `load_state` utility of accelerate\n\n```py\naccelerator.load_state(\"ckpt\")\n```\n\nWhen using transformers `save_pretrained`, pass `state_dict=accelerator.get_state_dict(model)` to save the model state dict. \n  Below is an example:\n\n```diff\n  unwrapped_model.save_pretrained(\n      args.output_dir,\n      is_main_process=accelerator.is_main_process,\n      save_function=accelerator.save,\n+     state_dict=accelerator.get_state_dict(model),\n)\n```\n\n### State Dict\n\n`accelerator.get_state_dict` will call the underlying `model.state_dict` implementation.  With a model wrapped by FSDP, the default behavior of `state_dict` is to gather all of the state in the rank 0 device.  This can cause CUDA out of memory errors if the parameters don't fit on a single GPU.\n\nTo avoid this, PyTorch provides a context manager that adjusts the behavior of `state_dict`.  To offload some of the state dict onto CPU, you can use the following code:\n\n```\nfrom torch.distributed.fsdp import FullyShardedDataParallel as FSDP, StateDictType, FullStateDictConfig\n\nfull_state_dict_config = FullStateDictConfig(offload_to_cpu=True, rank0_only=True)\nwith FSDP.state_dict_type(unwrapped_model, StateDictType.FULL_STATE_DICT, full_state_dict_config):\n    state = accelerator.get_state_dict(unwrapped_model)\n```\n\nYou can then pass `state` into the `save_pretrained` method.  There are several modes for `StateDictType` and `FullStateDictConfig` that you can use to control the behavior of `state_dict`.  For more information, see the [PyTorch documentation](https://pytorch.org/docs/stable/fsdp.html).\n\n## A few caveats to be aware of\n\n- PyTorch FSDP auto wraps sub-modules, flattens the parameters and shards the parameters in place.\n  Due to this, any optimizer created before model wrapping gets broken and occupies more memory.\n  Hence, it is highly recommended and efficient to prepare the model before creating the optimizer.\n  `Accelerate` will automatically wrap the model and create an optimizer for you in case of single model with a warning message.\n  > FSDP Warning: When using FSDP, it is efficient and recommended to call prepare for the model before creating the optimizer\n\nHowever, below is the recommended way to prepare model and optimizer while using FSDP:\n\n```diff\n  model = AutoModelForSequenceClassification.from_pretrained(\"bert-base-cased\", return_dict=True)\n+ model = accelerator.prepare(model)\n\n  optimizer = torch.optim.AdamW(params=model.parameters(), lr=lr)\n\n- model, optimizer, train_dataloader, eval_dataloader, lr_scheduler = accelerator.prepare(\n-        model, optimizer, train_dataloader, eval_dataloader, lr_scheduler\n-    )\n\n+ optimizer, train_dataloader, eval_dataloader, lr_scheduler = accelerator.prepare(\n+         optimizer, train_dataloader, eval_dataloader, lr_scheduler\n+    )\n```\n\n- In case of a single model, if you have created the optimizer with multiple parameter groups and called prepare with them together,\n  then the parameter groups will be lost and the following warning is displayed:\n  > FSDP Warning: When using FSDP, several parameter groups will be conflated into\n  > a single one due to nested module wrapping and parameter flattening.\n  \n  This is because parameter groups created before wrapping will have no meaning post wrapping due to parameter flattening of nested FSDP modules into 1D arrays (which can consume many layers).\n  For instance, below are the named parameters of an FSDP model on GPU 0 (When using 2 GPUs. Around 55M (110M/2) params in 1D arrays as this will have the 1st shard of the parameters). \n  Here, if one has applied no weight decay for [bias, LayerNorm.weight] the named parameters of an unwrapped BERT model, \n  it can't be applied to the below FSDP wrapped model as there are no named parameters with either of those strings and \n  the parameters of those layers are concatenated with parameters of various other layers.\n  ```\n  {\n    '_fsdp_wrapped_module.flat_param': torch.Size([494209]), \n    '_fsdp_wrapped_module._fpw_module.bert.embeddings.word_embeddings._fsdp_wrapped_module.flat_param': torch.Size([11720448]), \n    '_fsdp_wrapped_module._fpw_module.bert.encoder._fsdp_wrapped_module.flat_param': torch.Size([42527232])\n  }\n  ```\n\n\n- In case of multiple models, it is necessary to prepare the models before creating optimizers or else it will throw an error. \nThen pass the optimizers to the prepare call in the same order as corresponding models else `accelerator.save_state()` and `accelerator.load_state()` will result in wrong/unexpected behaviour.\n- This feature is incompatible with `--predict_with_generate` in the `run_translation.py` script of \ud83e\udd17 `Transformers` library.\n\nFor more control, users can leverage the `FullyShardedDataParallelPlugin`. After creating an instance of this class, users can pass it to the Accelerator class instantiation.\nFor more information on these options, please refer to the PyTorch [FullyShardedDataParallel](https://github.com/pytorch/pytorch/blob/0df2e863fbd5993a7b9e652910792bd21a516ff3/torch/distributed/fsdp/fully_sharded_data_parallel.py#L236) code.\n", "<!--Copyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\nspecific language governing permissions and limitations under the License.\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n-->\n\n# Handling big models for inference\n\nWhen loading a pre-trained model in PyTorch, the usual workflow looks like this:\n\n```py\nimport torch\n\nmy_model = ModelClass(...)\nstate_dict = torch.load(checkpoint_file)\nmy_model.load_state_dict(state_dict)\n```\n\nIn plain English, those steps are:\n1. Create the model with randomly initialized weights\n2. Load the model weights (in a dictionary usually called a state dict) from the disk\n3. Load those weights inside the model\n\nWhile this works very well for regularly sized models, this workflow has some clear limitations when we deal with a huge model: in step 1, we load a full version of the model in RAM, and spend some time randomly initializing the weights (which will be discarded in step 3). In step 2, we load another full version of the model in RAM, with the pre-trained weights. If you're loading a model with 6 billion parameters, this means you will need 24GB of RAM for each copy of the model, so 48GB in total (half of it to load the model in FP16).\n\n<Tip warning={true}>\n\n    This API is quite new and still in its experimental stage. While we strive to provide a stable API, it's possible some small parts of the public API will change in the future.\n\n</Tip>\n\n## How the Process Works: A Quick Overview\n\n<Youtube id=\"MWCSGj9jEAo\" />\n\n## How the Process Works: Working with Code\n\n### Instantiating an empty model\n\nThe first tool \ud83e\udd17 Accelerate introduces to help with big models is a context manager [`init_empty_weights`] that helps you initialize a model without using any RAM so that step 1 can be done on models of any size. Here is how it works:\n\n```py\nfrom accelerate import init_empty_weights\n\nwith init_empty_weights():\n    my_model = ModelClass(...)\n```\n\nFor instance:\n\n```py\nwith init_empty_weights():\n    model = nn.Sequential(*[nn.Linear(10000, 10000) for _ in range(1000)])\n```\n\ninitializes an empty model with a bit more than 100B parameters. Behind the scenes, this relies on the meta device introduced in PyTorch 1.9. During the initialization under the context manager, each time a parameter is created, it is instantly moved to that device.\n\n<Tip warning={true}>\n\n    You can't move a model initialized like this on CPU or another device directly, since it doesn't have any data. It's also very likely that a forward pass with that empty model will fail, as not all operations are supported on the meta device.\n\n</Tip>\n\n### Sharded checkpoints\n\nIt's possible your model is so big that even a single copy won't fit in RAM. That doesn't mean it can't be loaded: if you have one or several GPUs, this is more memory available to store your model. In this case, it's better if your checkpoint is split into several smaller files that we call checkpoint shards.\n\n\ud83e\udd17 Accelerate will handle sharded checkpoints as long as you follow the following format: your checkpoint should be in a folder, with several files containing the partial state dicts, and there should be an index in the JSON format that contains a dictionary mapping parameter names to the file containing their weights. You can easily shard your model with [`~Accelerator.save_model`]. For instance, we could have a folder containing:\n\n```bash\nfirst_state_dict.bin\nindex.json\nsecond_state_dict.bin\n```\n\nwith index.json being the following file:\n\n```\n{\n  \"linear1.weight\": \"first_state_dict.bin\",\n  \"linear1.bias\": \"first_state_dict.bin\",\n  \"linear2.weight\": \"second_state_dict.bin\",\n  \"linear2.bias\": \"second_state_dict.bin\"\n}\n```\n\nand `first_state_dict.bin` containing the weights for `\"linear1.weight\"` and `\"linear1.bias\"`, `second_state_dict.bin` the ones for `\"linear2.weight\"` and `\"linear2.bias\"`\n\n### Loading weights\n\nThe second tool \ud83e\udd17 Accelerate introduces is a function [`load_checkpoint_and_dispatch`], that will allow you to load a checkpoint inside your empty model. This supports full checkpoints (a single file containing the whole state dict) as well as sharded checkpoints. It will also automatically dispatch those weights across the devices you have available (GPUs, CPU RAM), so if you are loading a sharded checkpoint, the maximum RAM usage will be the size of the biggest shard.\n\nIf you want to use big model inference with \ud83e\udd17 Transformers models, check out this [documentation](https://huggingface.co/docs/transformers/main/en/main_classes/model#large-model-loading).\n\nHere is how we can use this to load the [GPT2-1.5B](https://huggingface.co/marcsun13/gpt2-xl-linear-sharded) model.\n\nLet's download the sharded version of this model.\n\n```bash\npip install huggingface_hub\n```\n\n```py\nfrom huggingface_hub import snapshot_download\ncheckpoint = \"marcsun13/gpt2-xl-linear-sharded\"\nweights_location = snapshot_download(repo_id=checkpoint)\n```\n\nIn order to initialize the model, we will use the library minGPT. \n\n```bash\ngit clone https://github.com/karpathy/minGPT.git\npip install minGPT/\n```\n\n```py\nfrom accelerate import init_empty_weights\nfrom mingpt.model import GPT\n\nmodel_config = GPT.get_default_config()\nmodel_config.model_type = 'gpt2-xl'\nmodel_config.vocab_size = 50257\nmodel_config.block_size = 1024\n\nwith init_empty_weights():\n    model = GPT(model_config)\n```\n\nThen, load the checkpoint we just downloaded with:\n\n```py\nfrom accelerate import load_checkpoint_and_dispatch\n\nmodel = load_checkpoint_and_dispatch(\n    model, checkpoint=weights_location, device_map=\"auto\", no_split_module_classes=['Block']\n)\n```\n\nBy passing `device_map=\"auto\"`, we tell \ud83e\udd17 Accelerate to determine automatically where to put each layer of the model depending on the available resources:\n- first, we use the maximum space available on the GPU(s)\n- if we still need space, we store the remaining weights on the CPU\n- if there is not enough RAM, we store the remaining weights on the hard drive as memory-mapped tensors\n\n`no_split_module_classes=[\"Block\"]` indicates that the modules that are `Block` should not be split on different devices. You should set here all blocks that include a residual connection of some kind.\n\nYou can see the `device_map` that \ud83e\udd17 Accelerate picked by accessing the `hf_device_map` attribute of your model:\n\n```py\nmodel.hf_device_map\n```\n\n```python out\n{'transformer.wte': 0,\n 'transformer.wpe': 0,\n 'transformer.drop': 0,\n 'transformer.h.0': 0,\n 'transformer.h.1': 0,\n 'transformer.h.2': 0,\n 'transformer.h.3': 0,\n 'transformer.h.4': 0,\n 'transformer.h.5': 0,\n 'transformer.h.6': 0,\n 'transformer.h.7': 0,\n 'transformer.h.8': 0,\n 'transformer.h.9': 0,\n 'transformer.h.10': 0,\n 'transformer.h.11': 0,\n 'transformer.h.12': 0,\n 'transformer.h.13': 0,\n 'transformer.h.14': 0,\n 'transformer.h.15': 0,\n 'transformer.h.16': 0, \n 'transformer.h.17': 0, \n 'transformer.h.18': 0, \n 'transformer.h.19': 0, \n 'transformer.h.20': 0, \n 'transformer.h.21': 0, \n 'transformer.h.22': 1, \n 'transformer.h.23': 1, \n 'transformer.h.24': 1, \n 'transformer.h.25': 1, \n 'transformer.h.26': 1, \n 'transformer.h.27': 1, \n 'transformer.h.28': 1, \n 'transformer.h.29': 1, \n 'transformer.h.30': 1, \n 'transformer.h.31': 1, \n 'transformer.h.32': 1, \n 'transformer.h.33': 1, \n 'transformer.h.34': 1, \n 'transformer.h.35': 1, \n 'transformer.h.36': 1, \n 'transformer.h.37': 1, \n 'transformer.h.38': 1, \n 'transformer.h.39': 1, \n 'transformer.h.40': 1, \n 'transformer.h.41': 1, \n 'transformer.h.42': 1, \n 'transformer.h.43': 1, \n 'transformer.h.44': 1, \n 'transformer.h.45': 1, \n 'transformer.h.46': 1, \n 'transformer.h.47': 1, \n 'transformer.ln_f': 1, \n 'lm_head': 1}\n ```\n\nYou can also design your `device_map` yourself if you prefer to explicitly decide where each layer should be. In this case, the command above becomes:\n\n```py\nmodel = load_checkpoint_and_dispatch(model, checkpoint=weights_location, device_map=my_device_map)\n```\n\n### Run the model\n\nNow that we have done this, our model lies across several devices, and maybe the hard drive. But it can still be used as a regular PyTorch model:\n\n```py\nfrom mingpt.bpe import BPETokenizer\ntokenizer = BPETokenizer()\ninputs = tokenizer(\"Hello, my name is\").to(0)\n\noutputs = model.generate(x1, max_new_tokens=10, do_sample=False)[0]\ntokenizer.decode(outputs.cpu().squeeze())\n```\n\nBehind the scenes, \ud83e\udd17 Accelerate added hooks to the model, so that:\n- at each layer, the inputs are put on the right device (so even if your model is spread across several GPUs, it works)\n- for the weights offloaded on the CPU, they are put on a GPU just before the forward pass and cleaned up just after\n- for the weights offloaded on the hard drive, they are loaded in RAM then put on a GPU just before the forward pass and cleaned up just after\n\nThis way, your model can run for inference even if it doesn't fit on one of the GPUs or the CPU RAM!\n\n<Tip warning={true}>\n\n    This only supports the inference of your model, not training. Most of the computation happens behind `torch.no_grad()` context managers to avoid spending some GPU memory with intermediate activations.\n\n</Tip>\n\n### Designing a device map\n\nYou can let \ud83e\udd17 Accelerate handle the device map computation by setting `device_map` to one of the supported options (`\"auto\"`, `\"balanced\"`, `\"balanced_low_0\"`, `\"sequential\"`) or create one yourself if you want more control over where each layer should go.\n\n<Tip>\n\n    You can derive all sizes of the model (and thus compute a `device_map`) on a model that is on the meta device.\n\n</Tip>\n\nAll the options will produce the same result when you don't have enough GPU memory to accommodate the whole model (which is to fit everything that can on the GPU, then offload weights on the CPU or even on the disk if there is not enough RAM). \n\nWhen you have more GPU memory available than the model size, here is the difference between each option:\n- `\"auto\"` and `\"balanced\"` evenly split the model on all available GPUs, making it possible for you to use a batch size greater than 1.\n- `\"balanced_low_0\"` evenly splits the model on all GPUs except the first one, and only puts on GPU 0 what does not fit on the others. This option is great when you need to use GPU 0 for some processing of the outputs, like when using the `generate` function for Transformers models\n- `\"sequential\"` will fit what it can on GPU 0, then move on GPU 1 and so forth (so won't use the last GPUs if it doesn't need to).\n\n<Tip>\n\n    The options `\"auto\"` and `\"balanced\"` produce the same results for now, but the behavior of `\"auto\"` might change in the future if we find a strategy that makes more sense, while `\"balanced\"` will stay stable.\n\n</Tip>\n\nFirst note that you can limit the memory used on each GPU by using the `max_memory` argument (available in [`infer_auto_device_map`] and in all functions using it). When setting `max_memory`, you should pass along a dictionary containing the GPU identifiers (for instance `0`, `1` etc.) and the `\"cpu\"` key for the maximum RAM you want to use for CPU offload. The values can either be an integer (in bytes) or a string representing a number with its unit, such as `\"10GiB\"` or `\"10GB\"`.\n\nHere is an example where we don't want to use more than 10GiB on each of the two GPUs and no more than 30GiB of CPU RAM for the model weights:\n\n```python\nfrom accelerate import infer_auto_device_map\n\ndevice_map = infer_auto_device_map(my_model, max_memory={0: \"10GiB\", 1: \"10GiB\", \"cpu\": \"30GiB\"})\n```\n\n<Tip warning={true}>\n\n    When a first allocation happens in PyTorch, it loads CUDA kernels which take about 1-2GB of memory depending on the GPU. Therefore you always have less usable memory than the actual size of the GPU. To see how much memory is actually used do `torch.ones(1).cuda()` and look at the memory usage.\n\n    Therefore when you create memory maps with `max_memory` make sure to adjust the available memory accordingly to avoid out-of-memory errors.\n\n</Tip>\n\nAdditionally, if you do some additional operations with your outputs without placing them back on the CPU (for instance inside the `generate` method of Transformers) and if you placed your inputs on a GPU, that GPU will consume more memory than the others (Accelerate always place the output back to the device of the input). Therefore if you would like to optimize the maximum batch size and you have many GPUs, give the first GPU less memory. For example, with BLOOM-176B on 8x80 A100 setup, the close-to-ideal map is:\n\n```python\nmax_memory = {0: \"30GIB\", 1: \"46GIB\", 2: \"46GIB\", 3: \"46GIB\", 4: \"46GIB\", 5: \"46GIB\", 6: \"46GIB\", 7: \"46GIB\"}\n```\nas you can see we gave the remaining 7 GPUs ~50% more memory than GPU 0.\n\nIf you opt to fully design the `device_map` yourself, it should be a dictionary with keys being module names of your model and values being a valid device identifier (for instance an integer for the GPUs) or `\"cpu\"` for CPU offload, `\"disk\"` for disk offload. The keys need to cover the whole model, you can then define your device map as you wish: for instance, if your model has two blocks (let's say `block1` and `block2`) which each contain three linear layers (let's say `linear1`, `linear2` and `linear3`), a valid device map can be:\n\n```python\ndevice_map = {\"block1\": 0, \"block2\": 1}\n```\n\nanother one that is valid could be:\n\n```python\ndevice_map = {\"block1\": 0, \"block2.linear1\": 0, \"block2.linear2\": 1, \"block2.linear3\": 1}\n```\n\nOn the other hand, this one is not valid as it does not cover every parameter of the model:\n\n```python\ndevice_map = {\"block1\": 0, \"block2.linear1\": 1, \"block2.linear2\": 1}\n```\n\n<Tip>\n\n    To be the most efficient, make sure your device map puts the parameters on the GPUs in a sequential manner (e.g. don't put one of the first weights on GPU 0, then weights on GPU 1 and the last weight back to GPU 0) to avoid making many transfers of data between the GPUs.\n\n</Tip>\n\n## Limits and further development\n\nWe are aware of the current limitations in the API:\n\n- While this could theoretically work on just one CPU with potential disk offload, you need at least one GPU to run this API. This will be fixed in further development.\n- [`infer_auto_device_map`] (or `device_map=\"auto\"` in [`load_checkpoint_and_dispatch`]) tries to maximize GPU and CPU RAM it sees available when you execute it. While PyTorch is very good at managing GPU RAM efficiently (and giving it back when not needed), it's not entirely true with Python and CPU RAM. Therefore, an automatically computed device map might be too intense on the CPU. Move a few modules to the disk device if you get crashes due to a lack of RAM.\n- [`infer_auto_device_map`] (or `device_map=\"auto\"` in [`load_checkpoint_and_dispatch`]) attributes devices sequentially (to avoid moving things back and forth) so if your first layer is bigger than the size of the GPU you have, it will end up with everything on the CPU/Disk.\n- [`load_checkpoint_and_dispatch`] and [`load_checkpoint_in_model`] do not perform any check on the correctness of your state dict compared to your model at the moment (this will be fixed in a future version), so you may get some weird errors if trying to load a checkpoint with mismatched or missing keys.\n- The model parallelism used when your model is split on several GPUs is naive and not optimized, meaning that only one GPU works at a given time and the other sits idle.\n- When weights are offloaded on the CPU/hard drive, there is no pre-fetching (yet, we will work on this for future versions) which means the weights are put on the GPU when they are needed and not before.\n- Hard-drive offloading might be very slow if the hardware you run on does not have fast communication between disk and CPU (like NVMes).\n", "<!--Copyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\nspecific language governing permissions and limitations under the License.\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n-->\n\n# Memory Utilities\n\nOne of the most frustrating errors when it comes to running training scripts is hitting \"CUDA Out-of-Memory\", \nas the entire script needs to be restarted, progress is lost, and typically a developer would want to simply\nstart their script and let it run.\n\n`Accelerate` provides a utility heavily based on [toma](https://github.com/BlackHC/toma) to give this capability.\n\n## find_executable_batch_size\n\nThis algorithm operates with exponential decay, decreasing the batch size in half after each failed run on some \ntraining script. To use it, restructure your training function to include an inner function that includes this wrapper, \nand build your dataloaders inside it. At a minimum, this could look like 4 new lines of code. \n> Note: The inner function *must* take in the batch size as the first parameter, but we do not pass one to it when called. The wrapper handles this for us\n\nIt should also be noted that anything which will consume CUDA memory and passed to the `accelerator` **must** be declared inside the inner function,\nsuch as models and optimizers.\n\n```diff\ndef training_function(args):\n    accelerator = Accelerator()\n\n+   @find_executable_batch_size(starting_batch_size=args.batch_size)\n+   def inner_training_loop(batch_size):\n+       nonlocal accelerator # Ensure they can be used in our context\n+       accelerator.free_memory() # Free all lingering references\n        model = get_model()\n        model.to(accelerator.device)\n        optimizer = get_optimizer()\n        train_dataloader, eval_dataloader = get_dataloaders(accelerator, batch_size)\n        lr_scheduler = get_scheduler(\n            optimizer, \n            num_training_steps=len(train_dataloader)*num_epochs\n        )\n        model, optimizer, train_dataloader, eval_dataloader, lr_scheduler = accelerator.prepare(\n            model, optimizer, train_dataloader, eval_dataloader, lr_scheduler\n        )\n        train(model, optimizer, train_dataloader, lr_scheduler)\n        validate(model, eval_dataloader)\n+   inner_training_loop()\n```\n\nTo find out more, check the documentation [here](../package_reference/utilities#accelerate.find_executable_batch_size).\n", "<!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\nspecific language governing permissions and limitations under the License.\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n-->\n\n# Quantization\n\n## `bitsandbytes` Integration\n\n\ud83e\udd17 Accelerate brings `bitsandbytes` quantization to your model. You can now load any pytorch model in 8-bit or 4-bit with a few lines of code.\n\nIf you want to use \ud83e\udd17 Transformers models with `bitsandbytes`, you should follow this [documentation](https://huggingface.co/docs/transformers/main_classes/quantization). \n\nTo learn more about how the `bitsandbytes` quantization works, check out the blog posts on [8-bit quantization](https://huggingface.co/blog/hf-bitsandbytes-integration) and [4-bit quantization](https://huggingface.co/blog/4bit-transformers-bitsandbytes).\n\n### Pre-Requisites\nYou will need to install the following requirements:\n\n- Install `bitsandbytes` library\n```bash\npip install bitsandbytes\n```\n- Install latest `accelerate` from source\n```bash\npip install git+https://github.com/huggingface/accelerate.git\n```\n- Install `minGPT` and `huggingface_hub` to run examples\n```bash\ngit clone https://github.com/karpathy/minGPT.git\npip install minGPT/\npip install huggingface_hub\n```\n\n### How it works\n\nFirst, we need to initialize our model. To save memory, we can initialize an empty model using the context manager [`init_empty_weights`]. \n\nLet's take the GPT2 model from minGPT library.\n```py\nfrom accelerate import init_empty_weights\nfrom mingpt.model import GPT\n\nmodel_config = GPT.get_default_config()\nmodel_config.model_type = 'gpt2-xl'\nmodel_config.vocab_size = 50257\nmodel_config.block_size = 1024\n\nwith init_empty_weights():\n    empty_model = GPT(model_config)\n```\n\nThen, we need to get the path to the weights of your model. The path can be the state_dict file (e.g. \"pytorch_model.bin\") or a folder containing the sharded checkpoints. \n\n```py\nfrom huggingface_hub import snapshot_download\nweights_location = snapshot_download(repo_id=\"marcsun13/gpt2-xl-linear-sharded\")\n```\n\nFinally, you need to set your quantization configuration with [`~utils.BnbQuantizationConfig`].\n\nHere's an example for 8-bit quantization:\n```py\nfrom accelerate.utils import BnbQuantizationConfig\nquantization_config = BnbQuantizationConfig(load_in_8bit=True, llm_int8_threshold = 6)\n```\n\nHere's an example for 4-bit quantization:\n```py\nfrom accelerate.utils import BnbQuantizationConfig\nquantization_config = BnbQuantizationConfig(load_in_4bit=True, bnb_4bit_compute_dtype=torch.bfloat16, bnb_4bit_use_double_quant=True, bnb_4bit_quant_type=\"nf4\")\n```\n\nTo quantize your empty model with the selected configuration, you need to use [`~utils.load_and_quantize_model`]. \n\n```py\nfrom accelerate.utils import load_and_quantize_model\nquantized_model = load_and_quantize_model(empty_model, weights_location=weights_location, quantization_config=quantization_config, device_map = \"auto\")\n```\n\n### Saving and loading 8-bit model\n\nYou can save your 8-bit model with accelerate using [`~Accelerator.save_model`]. \n\n```py\nfrom accelerate import Accelerator\naccelerate = Accelerator()\nnew_weights_location = \"path/to/save_directory\"\naccelerate.save_model(quantized_model, new_weights_location)\n\nquantized_model_from_saved = load_and_quantize_model(empty_model, weights_location=new_weights_location, quantization_config=quantization_config, device_map = \"auto\")\n```\n\nNote that 4-bit model serialization is currently not supported.\n\n### Offload modules to cpu and disk \n\nYou can offload some modules to cpu/disk if you don't have enough space on the GPU to store the entire model on your GPUs.\nThis uses big model inference under the hood. Check this [documentation](https://huggingface.co/docs/accelerate/usage_guides/big_modeling) for more details. \n\nFor 8-bit quantization, the selected modules will be converted to 8-bit precision. \n\nFor 4-bit quantization, the selected modules will be kept in `torch_dtype` that the user passed in `BnbQuantizationConfig`.  We will add support to convert these offloaded modules in 4-bit when 4-bit serialization will be possible. \n\n You just need to pass a custom `device_map` in order to offload modules on cpu/disk. The offload modules will be dispatched on the GPU when needed. Here's an example :\n\n```py\ndevice_map = {\n    \"transformer.wte\": 0,\n    \"transformer.wpe\": 0,\n    \"transformer.drop\": 0,\n    \"transformer.h\": \"cpu\",\n    \"transformer.ln_f\": \"disk\",\n    \"lm_head\": \"disk\",\n}\n```\n### Fine-tune a quantized model\n\nIt is not possible to perform pure 8bit or 4bit training on these models. However, you can train these models by leveraging parameter efficient fine tuning methods (PEFT) and train for example adapters on top of them. Please have a look at [peft](https://github.com/huggingface/peft) library for more details.\n\nCurrently, you can't add adapters on top of any quantized model. However, with the official support of adapters with \ud83e\udd17 Transformers models, you can fine-tune quantized models. If you want to finetune a \ud83e\udd17 Transformers model , follow this [documentation](https://huggingface.co/docs/transformers/main_classes/quantization) instead. Check out this [demo](https://colab.research.google.com/drive/1VoYNfYDKcKRQRor98Zbf2-9VQTtGJ24k?usp=sharing) on how to fine-tune a 4-bit \ud83e\udd17 Transformers model. \n\nNote that you don\u2019t need to pass `device_map` when loading the model for training. It will automatically load your model on your GPU. Please note that `device_map=auto` should be used for inference only.\n\n### Example demo - running GPT2 1.5b on a Google Colab\n\nCheck out the Google Colab [demo](https://colab.research.google.com/drive/1T1pOgewAWVpR9gKpaEWw4orOrzPFb3yM?usp=sharing) for running quantized models on a GTP2 model. The GPT2-1.5B model checkpoint is in FP32 which uses 6GB of memory. After quantization, it uses 1.6GB with 8-bit modules and 1.2GB with 4-bit modules.", "<!--Copyright 2023 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\nspecific language governing permissions and limitations under the License.\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n-->\n\n# Distributed Inference with \ud83e\udd17 Accelerate\n\nDistributed inference is a common use case, especially with natural language processing (NLP) models. Users often want to\nsend a number of different prompts, each to a different GPU, and then get the results back. This also has other cases\noutside of just NLP, however for this tutorial we will focus on just this idea of each GPU receiving a different prompt,\nand then returning the results.\n\n## The Problem\n\nNormally when doing this, users send the model to a specific device to load it from the CPU, and then move each prompt to a different device. \n\nA basic pipeline using the `diffusers` library might look something like so:\n\n```python\nimport torch\nimport torch.distributed as dist\nfrom diffusers import DiffusionPipeline\n\npipe = DiffusionPipeline.from_pretrained(\"runwayml/stable-diffusion-v1-5\", torch_dtype=torch.float16)\n```\nFollowed then by performing inference based on the specific prompt:\n\n```python\ndef run_inference(rank, world_size):\n    dist.init_process_group(\"nccl\", rank=rank, world_size=world_size)\n    pipe.to(rank)\n\n    if torch.distributed.get_rank() == 0:\n        prompt = \"a dog\"\n    elif torch.distributed.get_rank() == 1:\n        prompt = \"a cat\"\n\n    result = pipe(prompt).images[0]\n    result.save(f\"result_{rank}.png\")\n```\nOne will notice how we have to check the rank to know what prompt to send, which can be a bit tedious.\n\nA user might then also think that with \ud83e\udd17 Accelerate, using the `Accelerator` to prepare a dataloader for such a task might also be \na simple way to manage this. (To learn more, check out the relvent section in the [Quick Tour](../quicktour#distributed-evaluation))\n\nCan it manage it? Yes. Does it add unneeded extra code however: also yes.\n\n## The Solution\n\nWith \ud83e\udd17 Accelerate, we can simplify this process by using the [`Accelerator.split_between_processes`] context manager (which also exists in `PartialState` and `AcceleratorState`). \nThis function will automatically split whatever data you pass to it (be it a prompt, a set of tensors, a dictionary of the prior data, etc.) across all the processes (with a potential\nto be padded) for you to use right away.\n\nLet's rewrite the above example using this context manager:\n\n```python\nfrom accelerate import PartialState  # Can also be Accelerator or AcceleratorState\nfrom diffusers import DiffusionPipeline\n\npipe = DiffusionPipeline.from_pretrained(\"runwayml/stable-diffusion-v1-5\", torch_dtype=torch.float16)\ndistributed_state = PartialState()\npipe.to(distributed_state.device)\n\n# Assume two processes\nwith distributed_state.split_between_processes([\"a dog\", \"a cat\"]) as prompt:\n    result = pipe(prompt).images[0]\n    result.save(f\"result_{distributed_state.process_index}.png\")\n```\n\nAnd then to launch the code, we can use the \ud83e\udd17 Accelerate:\n\nIf you have generated a config file to be used using `accelerate config`:\n\n```bash\naccelerate launch distributed_inference.py\n```\n\nIf you have a specific config file you want to use:\n\n```bash\naccelerate launch --config_file my_config.json distributed_inference.py\n```\n\nOr if don't want to make any config files and launch on two GPUs:\n\n> Note: You will get some warnings about values being guessed based on your system. To remove these you can do `accelerate config default` or go through `accelerate config` to create a config file.\n\n```bash\naccelerate launch --num_processes 2 distributed_inference.py\n```\n\nWe've now reduced the boilerplate code needed to split this data to a few lines of code quite easily.\n\nBut what if we have an odd distribution of prompts to GPUs? For example, what if we have 3 prompts, but only 2 GPUs? \n\nUnder the context manager, the first GPU would receive the first two prompts and the second GPU the third, ensuring that \nall prompts are split and no overhead is needed.\n\n*However*, what if we then wanted to do something with the results of *all the GPUs*? (Say gather them all and perform some kind of post processing)\nYou can pass in `apply_padding=True` to ensure that the lists of prompts are padded to the same length, with extra data being taken \nfrom the last sample. This way all GPUs will have the same number of prompts, and you can then gather the results.\n\n<Tip>\n\nThis is only needed when trying to perform an action such as gathering the results, where the data on each device \nneeds to be the same length. Basic inference does not require this.\n\n</Tip>\n\nFor instance:\n\n```python\nfrom accelerate import PartialState  # Can also be Accelerator or AcceleratorStaet\nfrom diffusers import DiffusionPipeline\n\npipe = DiffusionPipeline.from_pretrained(\"runwayml/stable-diffusion-v1-5\", torch_dtype=torch.float16)\ndistributed_state = PartialState()\npipe.to(distributed_state.device)\n\n# Assume two processes\nwith distributed_state.split_between_processes([\"a dog\", \"a cat\", \"a chicken\"], apply_padding=True) as prompt:\n    result = pipe(prompt).images\n```\n\nOn the first GPU, the prompts will be `[\"a dog\", \"a cat\"]`, and on the second GPU it will be `[\"a chicken\", \"a chicken\"]`.\nMake sure to drop the final sample, as it will be a duplicate of the previous one.\n", "<!--Copyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\nspecific language governing permissions and limitations under the License.\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n-->\n\n\n# Megatron-LM\n\n[Megatron-LM](https://github.com/NVIDIA/Megatron-LM) enables training large transformer language models at scale.\nIt provides efficient tensor, pipeline and sequence based model parallelism for pre-training transformer based\nLanguage Models such as [GPT](https://arxiv.org/abs/2005.14165) (Decoder Only), [BERT](https://arxiv.org/pdf/1810.04805.pdf) (Encoder Only) and [T5](https://arxiv.org/abs/1910.10683) (Encoder-Decoder).\nFor detailed information and how things work behind the scene please refer the github [repo](https://github.com/NVIDIA/Megatron-LM).\n\n## What is integrated?\n\nAccelerate integrates following feature of Megatron-LM to enable large scale pre-training/finetuning\nof BERT (Encoder), GPT (Decoder) or T5 models (Encoder and Decoder):\n\na. **Tensor Parallelism (TP)**: Reduces memory footprint without much additional communication on intra-node ranks.\nEach tensor is split into multiple chunks with each shard residing on separate GPU. At each step, the same mini-batch of data is processed\nindependently and in parallel by each shard followed by syncing across all GPUs (`all-reduce` operation). \nIn a simple transformer layer, this leads to 2 `all-reduces` in the forward path and 2 in the backward path.\nFor more details, please refer research paper [Megatron-LM: Training Multi-Billion Parameter Language Models Using\nModel Parallelism](https://arxiv.org/pdf/1909.08053.pdf) and \nthis section of \ud83e\udd17 blogpost [The Technology Behind BLOOM Training](https://huggingface.co/blog/bloom-megatron-deepspeed#tensor-parallelism).\n\n\nb. **Pipeline Parallelism (PP)**: Reduces memory footprint and enables large scale training via inter-node parallelization. \nReduces the bubble of naive PP via PipeDream-Flush schedule/1F1B schedule and Interleaved 1F1B schedule. \nLayers are distributed uniformly across PP stages. For example, if a model has `24` layers and we have `4` GPUs for\npipeline parallelism, each GPU will have `6` layers (24/4). For more details on schedules to reduce the idle time of PP,\nplease refer to the research paper [Efficient Large-Scale Language Model Training on GPU Clusters\nUsing Megatron-LM](https://arxiv.org/pdf/2104.04473.pdf) and \nthis section of \ud83e\udd17 blogpost [The Technology Behind BLOOM Training](https://huggingface.co/blog/bloom-megatron-deepspeed#pipeline-parallelism).\n\nc. **Sequence Parallelism (SP)**: Reduces memory footprint without any additional communication. Only applicable when using TP.\nIt reduces activation memory required as it prevents the same copies to be on the tensor parallel ranks \npost `all-reduce` by replacing then with `reduce-scatter` and `no-op` operation would be replaced by `all-gather`. \nAs `all-reduce = reduce-scatter + all-gather`, this saves a ton of activation memory at no added communication cost. \nTo put it simply, it shards the outputs of each transformer layer along sequence dimension, e.g., \nif the sequence length is `1024` and the TP size is `4`, each GPU will have `256` tokens (1024/4) for each sample. \nThis increases the batch size that can be supported for training. For more details, please refer to the research paper\n[Reducing Activation Recomputation in Large Transformer Models](https://arxiv.org/pdf/2205.05198.pdf). \n\nd. **Data Parallelism (DP)** via Distributed Optimizer: Reduces the memory footprint by sharding optimizer states and gradients across DP ranks\n(versus the traditional method of replicating the optimizer state across data parallel ranks). \nFor example, when using Adam optimizer with mixed-precision training, each parameter accounts for 12 bytes of memory.\nThis gets distributed equally across the GPUs, i.e., each parameter would account for 3 bytes (12/4) if we have 4 GPUs.\nFor more details, please refer the research paper [ZeRO: Memory Optimizations Toward Training Trillion\nParameter Models](https://arxiv.org/pdf/1910.02054.pdf) and following section of \ud83e\udd17 blog \n[The Technology Behind BLOOM Training](https://huggingface.co/blog/bloom-megatron-deepspeed#zero-data-parallelism).\n\ne. **Selective Activation Recomputation**: Reduces the memory footprint of activations significantly via smart activation checkpointing.\nIt doesn't store activations occupying large memory while being fast to recompute thereby achieving great tradeoff between memory and recomputation.\nFor example, for GPT-3, this leads to 70% reduction in required memory for activations at the expense of\nonly 2.7% FLOPs overhead for recomputation of activations. For more details, please refer to the research paper \n[Reducing Activation Recomputation in Large Transformer Models](https://arxiv.org/pdf/2205.05198.pdf).\n\nf. **Fused Kernels**: Fused Softmax, Mixed Precision Fused Layer Norm and  Fused gradient accumulation to weight gradient computation of linear layer.\nPyTorch JIT compiled Fused GeLU and Fused Bias+Dropout+Residual addition.\n\ng. **Support for Indexed datasets**: Efficient binary format of datasets for large scale training. Support for the `mmap`, `cached` index file and the `lazy` loader format.\n\nh. **Checkpoint reshaping and interoperability**: Utility for reshaping Megatron-LM checkpoints of variable \ntensor and pipeline parallel sizes to the beloved \ud83e\udd17 Transformers sharded checkpoints as it has great support with plethora of tools\nsuch as \ud83e\udd17 Accelerate Big Model Inference, Megatron-DeepSpeed Inference etc. \nSupport is also available for converting \ud83e\udd17 Transformers sharded checkpoints to Megatron-LM checkpoint of variable tensor and pipeline parallel sizes\nfor large scale training.  \n\n\n## Pre-Requisites \n\nYou will need to install the latest pytorch, cuda, nccl, and NVIDIA [APEX](https://github.com/NVIDIA/apex#quick-start) releases and the nltk library.\nSee [documentation](https://github.com/NVIDIA/Megatron-LM#setup) for more details. \nAnother way to setup the environment is to pull an NVIDIA PyTorch Container that comes with all the required installations from NGC.\n\nBelow is a step-by-step method to set up the conda environment:\n\n1. Create a virtual environment\n```\nconda create --name ml\n```\n\n2. Assuming that the machine has CUDA 11.3 installed, installing the corresponding PyTorch GPU Version\n```\nconda install pytorch torchvision torchaudio cudatoolkit=11.3 -c pytorch\n```\n\n3. Install Nvidia APEX\n```\ngit clone https://github.com/NVIDIA/apex\ncd apex\npip install -v --disable-pip-version-check --no-cache-dir --global-option=\"--cpp_ext\" --global-option=\"--cuda_ext\" ./\ncd ..\n```\n\n4. Installing Megatron-LM\n\n```\npip install git+https://github.com/huggingface/Megatron-LM.git\n```\n\n## Accelerate Megatron-LM Plugin\n\nImportant features are directly supported via the `accelerate config` command. \nAn example of thr corresponding questions for using Megatron-LM features is shown below:\n\n```bash\n:~$ accelerate config --config_file \"megatron_gpt_config.yaml\"\nIn which compute environment are you running? ([0] This machine, [1] AWS (Amazon SageMaker)): 0\nWhich type of machine are you using? ([0] No distributed training, [1] multi-CPU, [2] multi-GPU, [3] TPU): 2\nHow many different machines will you use (use more than 1 for multi-node training)? [1]: \nDo you want to use DeepSpeed? [yes/NO]: \nDo you want to use FullyShardedDataParallel? [yes/NO]: \nDo you want to use Megatron-LM ? [yes/NO]: yes\nWhat is the Tensor Parallelism degree/size? [1]:2\nDo you want to enable Sequence Parallelism? [YES/no]: \nWhat is the Pipeline Parallelism degree/size? [1]:2\nWhat is the number of micro-batches? [1]:2\nDo you want to enable selective activation recomputation? [YES/no]: \nDo you want to use distributed optimizer which shards optimizer state and gradients across data pralellel ranks? [YES/no]: \nWhat is the gradient clipping value based on global L2 Norm (0 to disable)? [1.0]: \nHow many GPU(s) should be used for distributed training? [1]:4\nDo you wish to use FP16 or BF16 (mixed precision)? [NO/fp16/bf16]: bf16\n```\n\nThe resulting config is shown below:\n\n```\n~$ cat megatron_gpt_config.yaml \ncompute_environment: LOCAL_MACHINE\ndeepspeed_config: {}\ndistributed_type: MEGATRON_LM\ndowncast_bf16: 'no'\nfsdp_config: {}\nmachine_rank: 0\nmain_process_ip: null\nmain_process_port: null\nmain_training_function: main\nmegatron_lm_config:\n  megatron_lm_gradient_clipping: 1.0\n  megatron_lm_num_micro_batches: 2\n  megatron_lm_pp_degree: 2\n  megatron_lm_recompute_activations: true\n  megatron_lm_sequence_parallelism: true\n  megatron_lm_tp_degree: 2\n  megatron_lm_use_distributed_optimizer: true\nmixed_precision: bf16\nnum_machines: 1\nnum_processes: 4\nrdzv_backend: static\nsame_network: true\nuse_cpu: false\n```\n\nWe will take the example of GPT pre-training. The minimal changes required to the official `run_clm_no_trainer.py` \nto use Megatron-LM are as follows:\n\n1. As Megatron-LM uses its own implementation of Optimizer, the corresponding scheduler compatible with it needs to be used.\nAs such, support for only the Megatron-LM's scheduler is present. User will need to create `accelerate.utils.MegatronLMDummyScheduler`.\nExample is given below:\n\n```python\nfrom accelerate.utils import MegatronLMDummyScheduler\n\nif accelerator.distributed_type == DistributedType.MEGATRON_LM:\n    lr_scheduler = MegatronLMDummyScheduler(\n        optimizer=optimizer,\n        total_num_steps=args.max_train_steps,\n        warmup_num_steps=args.num_warmup_steps,\n    )\nelse:\n    lr_scheduler = get_scheduler(\n        name=args.lr_scheduler_type,\n        optimizer=optimizer,\n        num_warmup_steps=args.num_warmup_steps * args.gradient_accumulation_steps,\n        num_training_steps=args.max_train_steps * args.gradient_accumulation_steps,\n    )\n```\n\n2. Getting the details of the total batch size now needs to be cognization of tensor and pipeline parallel sizes.\nExample of getting the effective total batch size is shown below:\n\n```python\nif accelerator.distributed_type == DistributedType.MEGATRON_LM:\n    total_batch_size = accelerator.state.megatron_lm_plugin.global_batch_size\nelse:\n    total_batch_size = args.per_device_train_batch_size * accelerator.num_processes * args.gradient_accumulation_steps\n```\n\n3. When using Megatron-LM, the losses are already averaged across the data parallel group\n\n```python\nif accelerator.distributed_type == DistributedType.MEGATRON_LM:\n    losses.append(loss)\nelse:\n    losses.append(accelerator.gather_for_metrics(loss.repeat(args.per_device_eval_batch_size)))\n\nif accelerator.distributed_type == DistributedType.MEGATRON_LM:\n    losses = torch.tensor(losses)\nelse:\n    losses = torch.cat(losses)\n```\n\n4. For Megatron-LM, we need to save the model using `accelerator.save_state`\n\n```python\nif accelerator.distributed_type == DistributedType.MEGATRON_LM:\n    accelerator.save_state(args.output_dir)\nelse:\n    unwrapped_model = accelerator.unwrap_model(model)\n    unwrapped_model.save_pretrained(\n        args.output_dir, is_main_process=accelerator.is_main_process, save_function=accelerator.save\n    )\n```\n\nThat's it! We are good to go \ud83d\ude80. Please find the example script in the examples folder at the path `accelerate/examples/by_feature/megatron_lm_gpt_pretraining.py`.\nLet's run it for `gpt-large` model architecture using 4 A100-80GB GPUs.\n\n```bash\naccelerate launch --config_file megatron_gpt_config.yaml \\\nexamples/by_feature/megatron_lm_gpt_pretraining.py \\\n--config_name \"gpt2-large\" \\\n--tokenizer_name \"gpt2-large\" \\\n--dataset_name wikitext \\\n--dataset_config_name wikitext-2-raw-v1 \\\n--block_size 1024 \\\n--learning_rate 5e-5 \\\n--per_device_train_batch_size 24 \\\n--per_device_eval_batch_size 24 \\\n--num_train_epochs 5 \\\n--with_tracking \\\n--report_to \"wandb\" \\\n--output_dir \"awesome_model\"\n```\n\nBelow are some important excerpts from the output logs:\n\n```bash\nLoading extension module fused_dense_cuda...\n>>> done with compiling and loading fused kernels. Compilation time: 3.569 seconds\n > padded vocab (size: 50257) with 175 dummy tokens (new size: 50432)\nBuilding gpt model in the pre-training mode.\nThe Megatron LM model weights are initialized at random in `accelerator.prepare`. Please use `accelerator.load_checkpoint` to load a pre-trained checkpoint matching the distributed setup.\nPreparing dataloader\nPreparing dataloader\nPreparing model\n > number of parameters on (tensor, pipeline) model parallel rank (1, 0): 210753280\n > number of parameters on (tensor, pipeline) model parallel rank (1, 1): 209445120\n > number of parameters on (tensor, pipeline) model parallel rank (0, 0): 210753280\n > number of parameters on (tensor, pipeline) model parallel rank (0, 1): 209445120\nPreparing optimizer\nPreparing scheduler\n> learning rate decay style: linear\n10/10/2022 22:57:22 - INFO - __main__ - ***** Running training *****\n10/10/2022 22:57:22 - INFO - __main__ -   Num examples = 2318\n10/10/2022 22:57:22 - INFO - __main__ -   Num Epochs = 5\n10/10/2022 22:57:22 - INFO - __main__ -   Instantaneous batch size per device = 24\n10/10/2022 22:57:22 - INFO - __main__ -   Total train batch size (w. parallel, distributed & accumulation) = 48\n10/10/2022 22:57:22 - INFO - __main__ -   Gradient Accumulation steps = 1\n10/10/2022 22:57:22 - INFO - __main__ -   Total optimization steps = 245\n 20%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d                                                 | 49/245 [01:04<04:09,  1.27s/it]\n 10/10/2022 22:58:29 - INFO - __main__ - epoch 0: perplexity: 1222.1594275215962 eval_loss: 7.10837459564209\n 40%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a                                     | 98/245 [02:10<03:07,  1.28s/it]\n 10/10/2022 22:59:35 - INFO - __main__ - epoch 1: perplexity: 894.5236583794557 eval_loss: 6.796291351318359\n 60%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c                        | 147/245 [03:16<02:05,  1.28s/it]\n 10/10/2022 23:00:40 - INFO - __main__ - epoch 2: perplexity: 702.8458788508042 eval_loss: 6.555137634277344\n 80%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a            | 196/245 [04:22<01:02,  1.28s/it]\n 10/10/2022 23:01:46 - INFO - __main__ - epoch 3: perplexity: 600.3220028695281 eval_loss: 6.39746618270874\n100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 245/245 [05:27<00:00,  1.28s/it]\n```\n\nThere are a large number of other options/features that one can set using `accelerate.utils.MegatronLMPlugin`.\n\n## Advanced features to leverage writing custom train step and Megatron-LM Indexed Datasets\n\nFor leveraging more features, please go through below details.\n\n1. Below is an example of changes required to customize the Train Step while using Megatron-LM. \nYou will implement the `accelerate.utils.AbstractTrainStep` or inherit from their corresponding children \n`accelerate.utils.GPTTrainStep`, `accelerate.utils.BertTrainStep` or `accelerate.utils.T5TrainStep`.\n\n```python\nfrom accelerate.utils import MegatronLMDummyScheduler, GPTTrainStep, avg_losses_across_data_parallel_group\n\n\n# Custom loss function for the Megatron model\nclass GPTTrainStepWithCustomLoss(GPTTrainStep):\n    def __init__(self, megatron_args, **kwargs):\n        super().__init__(megatron_args)\n        self.kwargs = kwargs\n\n    def get_loss_func(self):\n        def loss_func(inputs, loss_mask, output_tensor):\n            batch_size, seq_length = output_tensor.shape\n            losses = output_tensor.float()\n            loss_mask = loss_mask.view(-1).float()\n            loss = losses.view(-1) * loss_mask\n\n            # Resize and average loss per sample\n            loss_per_sample = loss.view(batch_size, seq_length).sum(axis=1)\n            loss_mask_per_sample = loss_mask.view(batch_size, seq_length).sum(axis=1)\n            loss_per_sample = loss_per_sample / loss_mask_per_sample\n\n            # Calculate and scale weighting\n            weights = torch.stack([(inputs == kt).float() for kt in self.kwargs[\"keytoken_ids\"]]).sum(axis=[0, 2])\n            weights = 1.0 + self.kwargs[\"alpha\"] * weights\n            # Calculate weighted average\n            weighted_loss = (loss_per_sample * weights).mean()\n\n            # Reduce loss across data parallel groups\n            averaged_loss = avg_losses_across_data_parallel_group([weighted_loss])\n\n            return weighted_loss, {\"lm loss\": averaged_loss[0]}\n\n        return loss_func\n\n    def get_forward_step_func(self):\n        def forward_step(data_iterator, model):\n            \"\"\"Forward step.\"\"\"\n            # Get the batch.\n            tokens, labels, loss_mask, attention_mask, position_ids = self.get_batch(data_iterator)\n            output_tensor = model(tokens, position_ids, attention_mask, labels=labels)\n\n            return output_tensor, partial(self.loss_func, tokens, loss_mask)\n\n        return forward_step\n\n\ndef main():\n    # Custom loss function for the Megatron model\n    keytoken_ids = []\n    keywords = [\"plt\", \"pd\", \"sk\", \"fit\", \"predict\", \" plt\", \" pd\", \" sk\", \" fit\", \" predict\"]\n    for keyword in keywords:\n        ids = tokenizer([keyword]).input_ids[0]\n        if len(ids) == 1:\n            keytoken_ids.append(ids[0])\n    accelerator.print(f\"Keytoken ids: {keytoken_ids}\")\n    accelerator.state.megatron_lm_plugin.custom_train_step_class = GPTTrainStepWithCustomLoss\n    accelerator.state.megatron_lm_plugin.custom_train_step_kwargs = {\n        \"keytoken_ids\": keytoken_ids,\n        \"alpha\": 0.25,\n    }\n```\n\n2. For using the Megatron-LM datasets, a few more changes are required. Dataloaders for these datasets\nare available only on rank 0 of each tensor parallel group. As such, there are rank where dataloader won't be\navaiable and this requires tweaks to the training loop. Being able to do all this shows how\nfelixble and extensible \ud83e\udd17 Accelerate is. The changes required are as follows.\n\na. For Megatron-LM indexed datasets, we need to use `MegatronLMDummyDataLoader` \nand pass the required dataset args to it such as `data_path`, `seq_length` etc. \nSee [here](https://github.com/NVIDIA/Megatron-LM/blob/main/megatron/arguments.py#L804) for the list of available args. \n    \n```python\nfrom accelerate.utils import MegatronLMDummyDataLoader\n\nmegatron_dataloader_config = {\n    \"data_path\": args.data_path,\n    \"splits_string\": args.splits_string,\n    \"seq_length\": args.block_size,\n    \"micro_batch_size\": args.per_device_train_batch_size,\n}\nmegatron_dataloader = MegatronLMDummyDataLoader(**megatron_dataloader_config)\naccelerator.state.megatron_lm_plugin.megatron_dataset_flag = True\n```\n\nb. `megatron_dataloader` is repeated 3 times to get training, validation and test dataloaders\nas per the `args.splits_string` proportions\n    \n```python\nmodel, optimizer, lr_scheduler, train_dataloader, eval_dataloader, _ = accelerator.prepare(\n    model, optimizer, lr_scheduler, megatron_dataloader, megatron_dataloader, megatron_dataloader\n)\n```\n\nc. Changes to training and evaluation loops as dataloader is only available on tensor parallel ranks 0\nSo, we need to iterate only if the dataloader isn't `None` else provide empty dict\nAs such, we loop using `while` loop and break when `completed_steps` is equal to `args.max_train_steps`\nThis is similar to the Megatron-LM setup wherein user has to provide `max_train_steps` when using Megaton-LM indexed datasets.\nThis displays how flexible and extensible \ud83e\udd17 Accelerate is.\n\n```python\nwhile completed_steps < args.max_train_steps:\n    model.train()\n    batch = next(train_dataloader) if train_dataloader is not None else {}\n    outputs = model(**batch)\n    loss = outputs.loss\n    ...\n\n    if completed_steps % eval_interval == 0:\n        eval_completed_steps = 0\n        losses = []\n        while eval_completed_steps < eval_iters:\n            model.eval()\n            with torch.no_grad():\n                batch = next(eval_dataloader) if eval_dataloader is not None else {}\n                outputs = model(**batch)\n```\n\n    \n## Utility for Checkpoint reshaping and interoperability\n\n1. The scripts for these are present in \ud83e\udd17 Transformers library under respective models. \nCurrently, it is available for GPT model [checkpoint_reshaping_and_interoperability.py](https://github.com/huggingface/transformers/blob/main/src/transformers/models/megatron_gpt2/checkpoint_reshaping_and_interoperability.py)\n\n2. Below is an example of conversion of checkpoint from Megatron-LM to universal \ud83e\udd17 Transformers sharded checkpoint.\n```bash\npython checkpoint_reshaping_and_interoperability.py \\\n--convert_checkpoint_from_megatron_to_transformers \\\n--load_path \"gpt/iter_0005000\" \\\n--save_path \"gpt/trfs_checkpoint\" \\\n--max_shard_size \"200MB\" \\\n--tokenizer_name \"gpt2\" \\\n--print-checkpoint-structure\n```\n\n3. Conversion of checkpoint from transformers to megatron with `tp_size=2`, `pp_size=2` and `dp_size=2`.\n```bash\npython checkpoint_utils/megatgron_gpt2/checkpoint_reshaping_and_interoperability.py \\\n--load_path \"gpt/trfs_checkpoint\" \\\n--save_path \"gpt/megatron_lm_checkpoint\" \\\n--target_tensor_model_parallel_size 2 \\\n--target_pipeline_model_parallel_size 2 \\\n--target_data_parallel_size 2 \\\n--target_params_dtype \"bf16\" \\\n--make_vocab_size_divisible_by 128 \\\n--use_distributed_optimizer \\\n--print-checkpoint-structure\n```\n\n## Megatron-LM GPT models support returning logits and `megatron_generate` function for text generation\n\n1. Returning logits require setting `require_logits=True` in MegatronLMPlugin as shown below. \nThese would be available on the in the last stage of pipeline.\n```python\nmegatron_lm_plugin = MegatronLMPlugin(return_logits=True)\n```\n\n2. `megatron_generate` method for Megatron-LM GPT model: This will use Tensor and Pipeline Parallelism to complete \ngenerations for a batch of inputs when using greedy with/without top_k/top_p sampling and for individual prompt inputs when using beam search decoding. \nOnly a subset of features of transformers generate is supported. This will help in using large models via tensor and pipeline parallelism \nfor generation (already does key-value caching and uses fused kernels by default).\nThis requires data parallel size to be 1, sequence parallelism and activation checkpointing to be disabled.\nIt also requires specifying path to tokenizer's vocab file and merges file. \nBelow example shows how to configure and use `megatron_generate` method for Megatron-LM GPT model.\n```python\n# specifying tokenizer's vocab and merges file\nvocab_file = os.path.join(args.resume_from_checkpoint, \"vocab.json\")\nmerge_file = os.path.join(args.resume_from_checkpoint, \"merges.txt\")\nother_megatron_args = {\"vocab_file\": vocab_file, \"merge_file\": merge_file}\nmegatron_lm_plugin = MegatronLMPlugin(other_megatron_args=other_megatron_args)\n\n# inference using `megatron_generate` functionality\ntokenizer.pad_token = tokenizer.eos_token\nmax_new_tokens = 64\nbatch_texts = [\n    \"Are you human?\",\n    \"The purpose of life is\",\n    \"The arsenal was constructed at the request of\",\n    \"How are you doing these days?\",\n]\nbatch_encodings = tokenizer(batch_texts, return_tensors=\"pt\", padding=True)\n\n# top-p sampling\ngenerated_tokens = model.megatron_generate(\n    batch_encodings[\"input_ids\"],\n    batch_encodings[\"attention_mask\"],\n    max_new_tokens=max_new_tokens,\n    top_p=0.8,\n    top_p_decay=0.5,\n    temperature=0.9,\n)\ndecoded_preds = tokenizer.batch_decode(generated_tokens.cpu().numpy())\naccelerator.print(decoded_preds)\n\n# top-k sampling\ngenerated_tokens = model.megatron_generate(\n    batch_encodings[\"input_ids\"],\n    batch_encodings[\"attention_mask\"],\n    max_new_tokens=max_new_tokens,\n    top_k=50,\n    temperature=0.9,\n)\ndecoded_preds = tokenizer.batch_decode(generated_tokens.cpu().numpy())\naccelerator.print(decoded_preds)\n\n# adding `bos` token at the start\ngenerated_tokens = model.megatron_generate(\n    batch_encodings[\"input_ids\"], batch_encodings[\"attention_mask\"], max_new_tokens=max_new_tokens, add_BOS=True\n)\ndecoded_preds = tokenizer.batch_decode(generated_tokens.cpu().numpy())\naccelerator.print(decoded_preds)\n\n# beam search => only takes single prompt\nbatch_texts = [\"The purpose of life is\"]\nbatch_encodings = tokenizer(batch_texts, return_tensors=\"pt\", padding=True)\ngenerated_tokens = model.megatron_generate(\n    batch_encodings[\"input_ids\"],\n    batch_encodings[\"attention_mask\"],\n    max_new_tokens=max_new_tokens,\n    num_beams=20,\n    length_penalty=1.5,\n)\ndecoded_preds = tokenizer.batch_decode(generated_tokens.cpu().numpy())\naccelerator.print(decoded_preds)\n```\n\n3. An end-to-end example of using `megatron_generate` method for Megatron-LM GPT model is available at\n[megatron_gpt2_generation.py](https://github.com/pacman100/accelerate-megatron-test/blob/main/src/inference/megatron_gpt2_generation.py) with \nconfig file [megatron_lm_gpt_generate_config.yaml](https://github.com/pacman100/accelerate-megatron-test/blob/main/src/Configs/megatron_lm_gpt_generate_config.yaml).\nThe bash script with accelerate launch command is available at [megatron_lm_gpt_generate.sh](https://github.com/pacman100/accelerate-megatron-test/blob/main/megatron_lm_gpt_generate.sh).\nThe output logs of the script are available at [megatron_lm_gpt_generate.log](https://github.com/pacman100/accelerate-megatron-test/blob/main/output_logs/megatron_lm_gpt_generate.log).\n\n## Support for ROPE and ALiBi Positional embeddings and Multi-Query Attention\n\n1. For ROPE/ALiBi attention, pass `position_embedding_type` with `(\"absolute\" | \"rotary\" | \"alibi\")` to `MegatronLMPlugin` as shown below.\n```python\nother_megatron_args = {\"position_embedding_type\": \"alibi\"}\nmegatron_lm_plugin = MegatronLMPlugin(other_megatron_args=other_megatron_args)\n```\n\n2. For Multi-Query Attention, pass `attention_head_type` with `(\"multihead\" | \"multiquery\")` to `MegatronLMPlugin` as shown below.\n```python\nother_megatron_args = {\"attention_head_type\": \"multiquery\"}\nmegatron_lm_plugin = MegatronLMPlugin(other_megatron_args=other_megatron_args)\n```\n\n## Caveats\n\n1. Supports Transformers GPT2, Megatron-BERT and T5 models.\nThis covers Decoder only, Encode only and Encoder-Decoder model classes.\n\n2. Only loss is returned from model forward pass as \nthere is quite complex interplay of pipeline, tensor and data parallelsim behind the scenes.\nThe `model(**batch_data)` call return loss(es) averaged across the data parallel ranks.\nThis is fine for most cases wherein pre-training jobs are run using Megatron-LM features and\nyou can easily compute the `perplexity` using the loss. \nFor GPT model, returning logits in addition to loss(es) is supported. \nThese logits aren't gathered across data prallel ranks. Use `accelerator.utils.gather_across_data_parallel_groups`\nto gather logits across data parallel ranks. These logits along with labels can be used for computing various \nperformance metrics. \n\n3. The main process is the last rank as the losses/logits are available in the last stage of pipeline.\n`accelerator.is_main_process` and `accelerator.is_local_main_process` return `True` for last rank when using \nMegatron-LM integration.\n\n4. In `accelerator.prepare` call, a Megatron-LM model corresponding to a given Transformers model is created\nwith random weights. Please use `accelerator.load_state` to load the Megatron-LM checkpoint with matching TP, PP and DP partitions.\n\n5. Currently, checkpoint reshaping and interoperability support is only available for GPT. \nSoon it will be extended to BERT and T5.\n\n6. `gradient_accumulation_steps` needs to be 1. When using Megatron-LM, micro batches in pipeline parallelism \nsetting is synonymous with gradient accumulation. \n\n7. When using Megatron-LM, use `accelerator.save_state` and `accelerator.load_state` for saving and loading checkpoints.\n\n8. Below are the mapping from Megatron-LM model architectures to the the equivalent \ud83e\udd17 transformers model architectures.\nOnly these \ud83e\udd17 transformers model architectures are supported.\n\na. Megatron-LM [BertModel](https://github.com/NVIDIA/Megatron-LM/blob/main/megatron/model/bert_model.py) : \n\ud83e\udd17 transformers models with `megatron-bert` in config's model type, e.g., \n[MegatronBERT](https://huggingface.co/docs/transformers/model_doc/megatron-bert)\n    \nb. Megatron-LM [GPTModel](https://github.com/NVIDIA/Megatron-LM/blob/main/megatron/model/gpt_model.py) : \n\ud83e\udd17 transformers models with `gpt2` in config's model type, e.g., \n[OpenAI GPT2](https://huggingface.co/docs/transformers/model_doc/gpt2)\n   \nc. Megatron-LM [T5Model](https://github.com/NVIDIA/Megatron-LM/blob/main/megatron/model/t5_model.py) : \n\ud83e\udd17 transformers models with `t5` in  config's model type, e.g., \n[T5](https://huggingface.co/docs/transformers/model_doc/t5) and \n[MT5](https://huggingface.co/docs/transformers/model_doc/mt5)", "<!--Copyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\nspecific language governing permissions and limitations under the License.\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n-->\n\n# DeepSpeed \n\n[DeepSpeed](https://github.com/microsoft/DeepSpeed) implements everything described in the [ZeRO paper](https://arxiv.org/abs/1910.02054). Currently, it provides full support for:\n\n1. Optimizer state partitioning (ZeRO stage 1)\n2. Gradient partitioning (ZeRO stage 2)\n3. Parameter partitioning (ZeRO stage 3)\n4. Custom mixed precision training handling\n5. A range of fast CUDA-extension-based optimizers\n6. ZeRO-Offload to CPU and Disk/NVMe\n\nZeRO-Offload has its own dedicated paper: [ZeRO-Offload: Democratizing Billion-Scale Model Training](https://arxiv.org/abs/2101.06840). And NVMe-support is described in the paper [ZeRO-Infinity: Breaking the GPU\nMemory Wall for Extreme Scale Deep Learning](https://arxiv.org/abs/2104.07857).\n\nDeepSpeed ZeRO-2 is primarily used only for training, as its features are of no use to inference.\n\nDeepSpeed ZeRO-3 can be used for inference as well since it allows huge models to be loaded on multiple GPUs, which\nwon't be possible on a single GPU.\n\n\ud83e\udd17 Accelerate integrates [DeepSpeed](https://github.com/microsoft/DeepSpeed) via 2 options:\n\n1. Integration of the DeepSpeed features via `deepspeed config file` specification in `accelerate config` . You just supply your custom config file or use our template. Most of\n   this document is focused on this feature. This supports all the core features of DeepSpeed and gives user a lot of flexibility. \n   User may have to change a few lines of code depending on the config.\n2. Integration via `deepspeed_plugin`.This supports subset of the DeepSpeed features and uses default options for the rest of the configurations. \n   User need not change any code and is good for those who are fine with most of the default settings of DeepSpeed.\n\n## What is integrated?\n\nTraining:\n\n1. DeepSpeed ZeRO training supports the full ZeRO stages 1, 2 and 3 as well as CPU/Disk offload of optimizer states, gradients and parameters. \nBelow is a short description of Data Parallelism using ZeRO - Zero Redundancy Optimizer along with diagram from this [blog post](https://www.microsoft.com/en-us/research/blog/zero-deepspeed-new-system-optimizations-enable-training-models-with-over-100-billion-parameters/)\n![ZeRO Data Parallelism](https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/parallelism-zero.png)\n\n(Source: [link](https://www.microsoft.com/en-us/research/blog/zero-deepspeed-new-system-optimizations-enable-training-models-with-over-100-billion-parameters/))\n\n a. **Stage 1** : Shards optimizer states across data parallel workers/GPUs\n\n b. **Stage 2** : Shards optimizer states + gradients across data parallel workers/GPUs\n\n c. **Stage 3**: Shards optimizer states + gradients + model parameters across data parallel workers/GPUs\n\n d. **Optimizer Offload**: Offloads the gradients + optimizer states to CPU/Disk building on top of ZERO Stage 2\n\n e. **Param Offload**: Offloads the model parameters to CPU/Disk building on top of ZERO Stage 3\n\n<u>Note</u>: With respect to Disk Offload, the disk should be an NVME for decent speed but it technically works on any Disk\n\nInference:\n\n1. DeepSpeed ZeRO Inference supports ZeRO stage 3 with ZeRO-Infinity. It uses the same ZeRO protocol as training, but\n   it doesn't use an optimizer and a lr scheduler and only stage 3 is relevant. For more details see:\n   [deepspeed-zero-inference](#deepspeed-zero-inference).\n\n\n## How it works?\n\n**Pre-Requisites**: Install DeepSpeed version >=0.6.5. Please refer to the [DeepSpeed Installation details](https://github.com/microsoft/DeepSpeed#installation)\nfor more information.\n\nWe will first look at easy to use integration via `accelerate config`. \nFollowed by more flexible and feature rich `deepspeed config file` integration. \n\n### Accelerate DeepSpeed Plugin\nOn your machine(s) just run:\n\n```bash\naccelerate config\n```\n\nand answer the questions asked. It will ask whether you want to use a config file for DeepSpeed to which you should answer no. Then answer the following questions to generate a basic DeepSpeed config.\nThis will generate a config file that will be used automatically to properly set the\ndefault options when doing\n\n```bash\naccelerate launch my_script.py --args_to_my_script\n```\n\nFor instance, here is how you would run the NLP example `examples/nlp_example.py` (from the root of the repo) with DeepSpeed Plugin:\n\n**ZeRO Stage-2 DeepSpeed Plugin Example**\n```bash\ncompute_environment: LOCAL_MACHINE\ndeepspeed_config:\n gradient_accumulation_steps: 1\n gradient_clipping: 1.0\n offload_optimizer_device: none\n offload_param_device: none\n zero3_init_flag: true\n zero_stage: 2\ndistributed_type: DEEPSPEED\nfsdp_config: {}\nmachine_rank: 0\nmain_process_ip: null\nmain_process_port: null\nmain_training_function: main\nmixed_precision: fp16\nnum_machines: 1\nnum_processes: 2\nuse_cpu: false\n```\n\n```bash\naccelerate launch examples/nlp_example.py --mixed_precision fp16\n```\n\n**ZeRO Stage-3 with CPU Offload DeepSpeed Plugin Example**\n```bash\ncompute_environment: LOCAL_MACHINE\ndeepspeed_config:\n  gradient_accumulation_steps: 1\n  gradient_clipping: 1.0\n  offload_optimizer_device: cpu\n  offload_param_device: cpu\n  zero3_init_flag: true\n  zero3_save_16bit_model: true\n  zero_stage: 3\ndistributed_type: DEEPSPEED\nfsdp_config: {}\nmachine_rank: 0\nmain_process_ip: null\nmain_process_port: null\nmain_training_function: main\nmixed_precision: fp16\nnum_machines: 1\nnum_processes: 2\nuse_cpu: false\n```\n\n```bash\naccelerate launch examples/nlp_example.py --mixed_precision fp16\n```\n\nCurrently, `Accelerate` supports following config through the CLI:\n\n```bash\n`zero_stage`: [0] Disabled, [1] optimizer state partitioning, [2] optimizer+gradient state partitioning and [3] optimizer+gradient+parameter partitioning\n`gradient_accumulation_steps`: Number of training steps to accumulate gradients before averaging and applying them.\n`gradient_clipping`: Enable gradient clipping with value.\n`offload_optimizer_device`: [none] Disable optimizer offloading, [cpu] offload optimizer to CPU, [nvme] offload optimizer to NVMe SSD. Only applicable with ZeRO >= Stage-2.\n`offload_param_device`: [none] Disable parameter offloading, [cpu] offload parameters to CPU, [nvme] offload parameters to NVMe SSD. Only applicable with ZeRO Stage-3.\n`zero3_init_flag`: Decides whether to enable `deepspeed.zero.Init` for constructing massive models. Only applicable with ZeRO Stage-3.\n`zero3_save_16bit_model`: Decides whether to save 16-bit model weights when using ZeRO Stage-3.\n`mixed_precision`: `no` for FP32 training, `fp16` for FP16 mixed-precision training and `bf16` for BF16 mixed-precision training. \n```\nTo be able to tweak more options, you will need to use a DeepSpeed config file.\n\n### DeepSpeed Config File\nOn your machine(s) just run:\n\n```bash\naccelerate config\n```\n\nand answer the questions asked. It will ask whether you want to use a config file for deepspeed to which you answer yes \nand provide the path to the deepspeed config file. \nThis will generate a config file that will be used automatically to properly set the\ndefault options when doing\n\n```bash\naccelerate launch my_script.py --args_to_my_script\n```\n\nFor instance, here is how you would run the NLP example `examples/by_feature/deepspeed_with_config_support.py` (from the root of the repo) with DeepSpeed Config File:\n\n**ZeRO Stage-2 DeepSpeed Config File Example**\n```bash\ncompute_environment: LOCAL_MACHINE\ndeepspeed_config:\n deepspeed_config_file: /home/ubuntu/accelerate/examples/configs/deepspeed_config_templates/zero_stage2_config.json\n zero3_init_flag: true\ndistributed_type: DEEPSPEED\nfsdp_config: {}\nmachine_rank: 0\nmain_process_ip: null\nmain_process_port: null\nmain_training_function: main\nmixed_precision: fp16\nnum_machines: 1\nnum_processes: 2\nuse_cpu: false\n```\n\nwith the contents of `zero_stage2_config.json` being:\n```json\n{\n    \"fp16\": {\n        \"enabled\": true,\n        \"loss_scale\": 0,\n        \"loss_scale_window\": 1000,\n        \"initial_scale_power\": 16,\n        \"hysteresis\": 2,\n        \"min_loss_scale\": 1\n    },\n    \"optimizer\": {\n        \"type\": \"AdamW\",\n        \"params\": {\n            \"lr\": \"auto\",\n            \"weight_decay\": \"auto\",\n            \"torch_adam\": true,\n            \"adam_w_mode\": true\n        }\n    },\n    \"scheduler\": {\n        \"type\": \"WarmupDecayLR\",\n        \"params\": {\n            \"warmup_min_lr\": \"auto\",\n            \"warmup_max_lr\": \"auto\",\n            \"warmup_num_steps\": \"auto\",\n            \"total_num_steps\": \"auto\"\n        }\n    },\n    \"zero_optimization\": {\n        \"stage\": 2,\n        \"allgather_partitions\": true,\n        \"allgather_bucket_size\": 2e8,\n        \"overlap_comm\": true,\n        \"reduce_scatter\": true,\n        \"reduce_bucket_size\": \"auto\",\n        \"contiguous_gradients\": true\n    },\n    \"gradient_accumulation_steps\": 1,\n    \"gradient_clipping\": \"auto\",\n    \"steps_per_print\": 2000,\n    \"train_batch_size\": \"auto\",\n    \"train_micro_batch_size_per_gpu\": \"auto\",\n    \"wall_clock_breakdown\": false\n}\n```\n\n```bash\naccelerate launch examples/by_feature/deepspeed_with_config_support.py \\\n--config_name \"gpt2-large\" \\\n--tokenizer_name \"gpt2-large\" \\\n--dataset_name \"wikitext\" \\\n--dataset_config_name \"wikitext-2-raw-v1\" \\\n--block_size 128 \\\n--output_dir \"./clm/clm_deepspeed_stage2_accelerate\" \\\n--learning_rate 5e-4 \\\n--per_device_train_batch_size 24 \\\n--per_device_eval_batch_size 24 \\\n--num_train_epochs 3 \\\n--with_tracking \\\n--report_to \"wandb\"\\\n```\n\n**ZeRO Stage-3 with CPU offload DeepSpeed Config File Example**\n```bash\ncompute_environment: LOCAL_MACHINE\ndeepspeed_config:\n deepspeed_config_file: /home/ubuntu/accelerate/examples/configs/deepspeed_config_templates/zero_stage3_offload_config.json\n zero3_init_flag: true\ndistributed_type: DEEPSPEED\nfsdp_config: {}\nmachine_rank: 0\nmain_process_ip: null\nmain_process_port: null\nmain_training_function: main\nmixed_precision: fp16\nnum_machines: 1\nnum_processes: 2\nuse_cpu: false\n```\nwith the contents of `zero_stage3_offload_config.json` being:\n```json\n{\n    \"fp16\": {\n        \"enabled\": true,\n        \"loss_scale\": 0,\n        \"loss_scale_window\": 1000,\n        \"initial_scale_power\": 16,\n        \"hysteresis\": 2,\n        \"min_loss_scale\": 1\n    },\n    \"optimizer\": {\n        \"type\": \"AdamW\",\n        \"params\": {\n            \"lr\": \"auto\",\n            \"weight_decay\": \"auto\"\n        }\n    },\n    \"scheduler\": {\n        \"type\": \"WarmupDecayLR\",\n        \"params\": {\n            \"warmup_min_lr\": \"auto\",\n            \"warmup_max_lr\": \"auto\",\n            \"warmup_num_steps\": \"auto\",\n            \"total_num_steps\": \"auto\"\n        }\n    },\n    \"zero_optimization\": {\n        \"stage\": 3,\n        \"offload_optimizer\": {\n            \"device\": \"cpu\",\n            \"pin_memory\": true\n        },\n        \"offload_param\": {\n            \"device\": \"cpu\",\n            \"pin_memory\": true\n        },\n        \"overlap_comm\": true,\n        \"contiguous_gradients\": true,\n        \"reduce_bucket_size\": \"auto\",\n        \"stage3_prefetch_bucket_size\": \"auto\",\n        \"stage3_param_persistence_threshold\": \"auto\",\n        \"sub_group_size\": 1e9,\n        \"stage3_max_live_parameters\": 1e9,\n        \"stage3_max_reuse_distance\": 1e9,\n        \"stage3_gather_16bit_weights_on_model_save\": \"auto\"\n    },\n    \"gradient_accumulation_steps\": 1,\n    \"gradient_clipping\": \"auto\",\n    \"steps_per_print\": 2000,\n    \"train_batch_size\": \"auto\",\n    \"train_micro_batch_size_per_gpu\": \"auto\",\n    \"wall_clock_breakdown\": false\n}\n```\n\n```bash\naccelerate launch examples/by_feature/deepspeed_with_config_support.py \\\n--config_name \"gpt2-large\" \\\n--tokenizer_name \"gpt2-large\" \\\n--dataset_name \"wikitext\" \\\n--dataset_config_name \"wikitext-2-raw-v1\" \\\n--block_size 128 \\\n--output_dir \"./clm/clm_deepspeed_stage3_offload_accelerate\" \\\n--learning_rate 5e-4 \\\n--per_device_train_batch_size 32 \\\n--per_device_eval_batch_size 32 \\\n--num_train_epochs 3 \\\n--with_tracking \\\n--report_to \"wandb\"\\\n```\n\n**Important code changes when using DeepSpeed Config File**\n\n1. DeepSpeed Optimizers and Schedulers. For more information on these, \nsee the [DeepSpeed Optimizers](https://deepspeed.readthedocs.io/en/latest/optimizers.html) and [DeepSpeed Schedulers](https://deepspeed.readthedocs.io/en/latest/schedulers.html) documentation.\nWe will look at the changes needed in the code when using these.\n   \n   a. DS Optim + DS Scheduler: The case when both `optimizer` and `scheduler` keys are present in the DeepSpeed config file.\n   In this situation, those will be used and the user has to use `accelerate.utils.DummyOptim` and `accelerate.utils.DummyScheduler` to replace the PyTorch/Custom optimizers and schedulers in their code.\n   Below is the snippet from `examples/by_feature/deepspeed_with_config_support.py` showing this:\n   ```python\n    # Creates Dummy Optimizer if `optimizer` was spcified in the config file else creates Adam Optimizer\n    optimizer_cls = (\n        torch.optim.AdamW\n        if accelerator.state.deepspeed_plugin is None\n        or \"optimizer\" not in accelerator.state.deepspeed_plugin.deepspeed_config\n        else DummyOptim\n    )\n    optimizer = optimizer_cls(optimizer_grouped_parameters, lr=args.learning_rate)\n\n    # Creates Dummy Scheduler if `scheduler` was spcified in the config file else creates `args.lr_scheduler_type` Scheduler\n    if (\n        accelerator.state.deepspeed_plugin is None\n        or \"scheduler\" not in accelerator.state.deepspeed_plugin.deepspeed_config\n    ):\n        lr_scheduler = get_scheduler(\n            name=args.lr_scheduler_type,\n            optimizer=optimizer,\n            num_warmup_steps=args.num_warmup_steps,\n            num_training_steps=args.max_train_steps,\n        )\n    else:\n        lr_scheduler = DummyScheduler(\n            optimizer, total_num_steps=args.max_train_steps, warmup_num_steps=args.num_warmup_steps\n        )\n   ```\n   b. Custom Optim + Custom Scheduler: The case when both `optimizer` and `scheduler` keys are absent in the DeepSpeed config file.\n   In this situation, no code changes are needed from the user and this is the case when using integration via DeepSpeed Plugin.\n   In the above example we can see that the code remains unchanged if the `optimizer` and `scheduler` keys are absent in the DeepSpeed config file.\n\n   c. Custom Optim + DS Scheduler: The case when only `scheduler` key is present in the DeepSpeed config file. \n   In this situation, the user has to use `accelerate.utils.DummyScheduler` to replace the PyTorch/Custom scheduler in their code. \n\n   d. DS Optim + Custom Scheduler: The case when only `optimizer` key is present in the DeepSpeed config file. \n   This will result in an error because you can only use DS Scheduler when using DS Optim.\n\n2. Notice the `auto` values in the above example DeepSpeed config files. These are automatically handled by `prepare` method \nbased on model, dataloaders, dummy optimizer and dummy schedulers provided to `prepare` method. \nOnly the `auto` fields specified in above examples are handled by `prepare` method and the rest have to be explicitly specified by the user.\n\n**Things to note when using DeepSpeed Config File**\n\nBelow is a sample script using `deepspeed_config_file` in different scenarios.\n\nCode `test.py`:\n\n```python\nfrom accelerate import Accelerator\nfrom accelerate.state import AcceleratorState\n\n\ndef main():\n    accelerator = Accelerator()\n    accelerator.print(f\"{AcceleratorState()}\")\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\n**Scenario 1**: Manually tampered accelerate config file having `deepspeed_config_file` along with other entries.\n\n1. Content of the `accelerate` config:\n\n```yaml\ncommand_file: null\ncommands: null\ncompute_environment: LOCAL_MACHINE\ndeepspeed_config:\n  gradient_accumulation_steps: 1\n  gradient_clipping: 1.0\n  offload_optimizer_device: 'cpu'\n  offload_param_device: 'cpu'\n  zero3_init_flag: true\n  zero3_save_16bit_model: true\n  zero_stage: 3\n  deepspeed_config_file: 'ds_config.json'\ndistributed_type: DEEPSPEED\ndowncast_bf16: 'no'\ndynamo_backend: 'NO'\nfsdp_config: {}\ngpu_ids: null\nmachine_rank: 0\nmain_process_ip: null\nmain_process_port: null\nmain_training_function: main\nmegatron_lm_config: {}\nnum_machines: 1\nnum_processes: 2\nrdzv_backend: static\nsame_network: true\ntpu_name: null\ntpu_zone: null\nuse_cpu: false\n```\n\n2. `ds_config.json`:\n\n```json\n{\n    \"bf16\": {\n        \"enabled\": true\n    },\n    \"zero_optimization\": {\n        \"stage\": 3,\n        \"stage3_gather_16bit_weights_on_model_save\": false,\n        \"offload_optimizer\": {\n            \"device\": \"none\"\n        },\n        \"offload_param\": {\n            \"device\": \"none\"\n        }\n    },\n    \"gradient_clipping\": 1.0,\n    \"train_batch_size\": \"auto\",\n    \"train_micro_batch_size_per_gpu\": \"auto\",\n    \"gradient_accumulation_steps\": 10,\n    \"steps_per_print\": 2000000\n}\n```\n\n3. Output of `accelerate launch test.py`:\n\n```bash\nValueError: When using `deepspeed_config_file`, the following accelerate config variables will be ignored: \n['gradient_accumulation_steps', 'gradient_clipping', 'zero_stage', 'offload_optimizer_device', 'offload_param_device', \n'zero3_save_16bit_model', 'mixed_precision'].\nPlease specify them appropriately in the DeepSpeed config file.\nIf you are using an accelerate config file, remove others config variables mentioned in the above specified list.\nThe easiest method is to create a new config following the questionnaire via `accelerate config`.\nIt will only ask for the necessary config variables when using `deepspeed_config_file`.\n```\n\n**Scenario 2**: Use the solution of the error to create new accelerate config and check that no ambiguity error is now thrown.\n\n1. Run `accelerate config`:\n\n```bash\n$ accelerate config\n-------------------------------------------------------------------------------------------------------------------------------\nIn which compute environment are you running?\nThis machine                                                                                                                   \n-------------------------------------------------------------------------------------------------------------------------------\nWhich type of machine are you using?                                                                                           \nmulti-GPU                                                                                                                      \nHow many different machines will you use (use more than 1 for multi-node training)? [1]:                                       \nDo you wish to optimize your script with torch dynamo?[yes/NO]:                                                                \nDo you want to use DeepSpeed? [yes/NO]: yes                                                                                    \nDo you want to specify a json file to a DeepSpeed config? [yes/NO]: yes                                                        \nPlease enter the path to the json DeepSpeed config file: ds_config.json                                                        \nDo you want to enable `deepspeed.zero.Init` when using ZeRO Stage-3 for constructing massive models? [yes/NO]: yes\nHow many GPU(s) should be used for distributed training? [1]:4\naccelerate configuration saved at ds_config_sample.yaml\n```\n\n2. Content of the `accelerate` config:\n\n```yaml\ncompute_environment: LOCAL_MACHINE\ndeepspeed_config:\n  deepspeed_config_file: ds_config.json\n  zero3_init_flag: true\ndistributed_type: DEEPSPEED\ndowncast_bf16: 'no'\ndynamo_backend: 'NO'\nfsdp_config: {}\nmachine_rank: 0\nmain_training_function: main\nmegatron_lm_config: {}\nnum_machines: 1\nnum_processes: 4\nrdzv_backend: static\nsame_network: true\nuse_cpu: false\n```\n\n3. Output of `accelerate launch test.py`:\n\n```bash\nDistributed environment: DEEPSPEED  Backend: nccl\nNum processes: 4\nProcess index: 0\nLocal process index: 0\nDevice: cuda:0\nMixed precision type: bf16\nds_config: {'bf16': {'enabled': True}, 'zero_optimization': {'stage': 3, 'stage3_gather_16bit_weights_on_model_save': False, 'offload_optimizer': {'device': 'none'}, 'offload_param': {'device': 'none'}}, 'gradient_clipping': 1.0, 'train_batch_size': 'auto', 'train_micro_batch_size_per_gpu': 'auto', 'gradient_accumulation_steps': 10, 'steps_per_print': inf, 'fp16': {'enabled': False}}\n```\n\n**Scenario 3**: Setting the `accelerate launch` command arguments related to DeepSpeed as `\"auto\"` in the DeepSpeed` configuration file and check that things work as expected.\n\n1. New `ds_config.json` with `\"auto\"` for the `accelerate launch` DeepSpeed command arguments:\n\n```json\n{\n    \"bf16\": {\n        \"enabled\": \"auto\"\n    },\n    \"zero_optimization\": {\n        \"stage\": \"auto\",\n        \"stage3_gather_16bit_weights_on_model_save\": \"auto\",\n        \"offload_optimizer\": {\n            \"device\": \"auto\"\n        },\n        \"offload_param\": {\n            \"device\": \"auto\"\n        }\n    },\n    \"gradient_clipping\": \"auto\",\n    \"train_batch_size\": \"auto\",\n    \"train_micro_batch_size_per_gpu\": \"auto\",\n    \"gradient_accumulation_steps\": \"auto\",\n    \"steps_per_print\": 2000000\n}\n```\n\n2. Output of `accelerate launch --mixed_precision=\"fp16\" --zero_stage=3 --gradient_accumulation_steps=5 --gradient_clipping=1.0 --offload_param_device=\"cpu\" --offload_optimizer_device=\"nvme\" --zero3_save_16bit_model=\"true\" test.py`:\n\n```bash\nDistributed environment: DEEPSPEED  Backend: nccl\nNum processes: 4\nProcess index: 0\nLocal process index: 0\nDevice: cuda:0\nMixed precision type: fp16\nds_config: {'bf16': {'enabled': False}, 'zero_optimization': {'stage': 3, 'stage3_gather_16bit_weights_on_model_save': True, 'offload_optimizer': {'device': 'nvme'}, 'offload_param': {'device': 'cpu'}}, 'gradient_clipping': 1.0, 'train_batch_size': 'auto', 'train_micro_batch_size_per_gpu': 'auto', 'gradient_accumulation_steps': 5, 'steps_per_print': inf, 'fp16': {'enabled': True, 'auto_cast': True}}\n```\n\n**Note**: Remaining `\"auto\"` values are handled in `accelerator.prepare()` call as explained in point 2 of \n`Important code changes when using DeepSpeed Config File`.\n\n## Saving and loading\n\n1. Saving and loading of models is unchanged for ZeRO Stage-1 and Stage-2.\n\n2. under ZeRO Stage-3, `state_dict` contains just the placeholders since the model weights are partitioned across multiple GPUs.\nZeRO Stage-3 has 2 options:\n\n   a. Saving the entire 16bit model weights to directly load later on using `model.load_state_dict(torch.load(pytorch_model.bin))`.\n   For this, either set `zero_optimization.stage3_gather_16bit_weights_on_model_save` to True in DeepSpeed Config file or set\n   `zero3_save_16bit_model` to True in DeepSpeed Plugin. \n   **Note that this option requires consolidation of the weights on one GPU it can be slow and memory demanding, so only use this feature when needed.**\n   Below is the snippet from `examples/by_feature/deepspeed_with_config_support.py` showing this:\n   ```python\n   unwrapped_model = accelerator.unwrap_model(model)\n\n   # New Code #\n   # Saves the whole/unpartitioned fp16 model when in ZeRO Stage-3 to the output directory if\n   # `stage3_gather_16bit_weights_on_model_save` is True in DeepSpeed Config file or\n   # `zero3_save_16bit_model` is True in DeepSpeed Plugin.\n   # For Zero Stages 1 and 2, models are saved as usual in the output directory.\n   # The model name saved is `pytorch_model.bin`\n   unwrapped_model.save_pretrained(\n       args.output_dir,\n       is_main_process=accelerator.is_main_process,\n       save_function=accelerator.save,\n       state_dict=accelerator.get_state_dict(model),\n   )\n   ```\n\n   b. To get 32bit weights, first save the model using `model.save_checkpoint()`.\n   Below is the snippet from `examples/by_feature/deepspeed_with_config_support.py` showing this:\n   ```python\n   success = model.save_checkpoint(PATH, ckpt_id, checkpoint_state_dict)\n   status_msg = \"checkpointing: PATH={}, ckpt_id={}\".format(PATH, ckpt_id)\n   if success:\n       logging.info(f\"Success {status_msg}\")\n   else:\n       logging.warning(f\"Failure {status_msg}\")\n   ``` \n   This will create ZeRO model and optimizer partitions along with `zero_to_fp32.py` script in checkpoint directory.\n   You can use this script to do offline consolidation.  \n   It requires no configuration files or GPUs. Here is an example of its usage:  \n   ```bash\n   $ cd /path/to/checkpoint_dir\n   $ ./zero_to_fp32.py . pytorch_model.bin\n   Processing zero checkpoint at global_step1\n   Detected checkpoint of type zero stage 3, world_size: 2\n   Saving fp32 state dict to pytorch_model.bin (total_numel=60506624)\n   ```\n   To get 32bit model for saving/inference, you can perform:\n   ```python\n   from deepspeed.utils.zero_to_fp32 import load_state_dict_from_zero_checkpoint\n\n   unwrapped_model = accelerator.unwrap_model(model)\n   fp32_model = load_state_dict_from_zero_checkpoint(unwrapped_model, checkpoint_dir)\n   ```\n   If you are only interested in the `state_dict`, you can do the following:\n   ```python\n   from deepspeed.utils.zero_to_fp32 import get_fp32_state_dict_from_zero_checkpoint\n\n   state_dict = get_fp32_state_dict_from_zero_checkpoint(checkpoint_dir)\n   ```\n   Note that all these functions require ~2x memory (general RAM) of the size of the final checkpoint.\n\n## ZeRO Inference\nDeepSpeed ZeRO Inference supports ZeRO stage 3 with ZeRO-Infinity. \nIt uses the same ZeRO protocol as training, but it doesn't use an optimizer and a lr scheduler and only stage 3 is relevant.\nWith accelerate integration, you just need to prepare the model and dataloader as shown below:\n\n```python\nmodel, eval_dataloader = accelerator.prepare(model, eval_dataloader)\n```\n\n## Few caveats to be aware of \n\n1. Current integration doesn\u2019t support Pipeline Parallelism of DeepSpeed.\n2. Current integration doesn\u2019t support `mpu`, limiting the tensor parallelism which is supported in Megatron-LM. \n3. Current integration doesn\u2019t support multiple models. \n\n## DeepSpeed Resources\n\nThe documentation for the internals related to deepspeed can be found [here](../package_reference/deepspeed).\n\n- [Project's github](https://github.com/microsoft/deepspeed)\n- [Usage docs](https://www.deepspeed.ai/getting-started/)\n- [API docs](https://deepspeed.readthedocs.io/en/latest/index.html)\n- [Blog posts](https://www.microsoft.com/en-us/research/search/?q=deepspeed)\n\nPapers:\n\n- [ZeRO: Memory Optimizations Toward Training Trillion Parameter Models](https://arxiv.org/abs/1910.02054)\n- [ZeRO-Offload: Democratizing Billion-Scale Model Training](https://arxiv.org/abs/2101.06840)\n- [ZeRO-Infinity: Breaking the GPU Memory Wall for Extreme Scale Deep Learning](https://arxiv.org/abs/2104.07857)\n\nFinally, please, remember that \ud83e\udd17 `Accelerate` only integrates DeepSpeed, therefore if you\nhave any problems or questions with regards to DeepSpeed usage, please, file an issue with [DeepSpeed GitHub](https://github.com/microsoft/DeepSpeed/issues).\n\n", "<!--Copyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\nspecific language governing permissions and limitations under the License.\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n-->\n\n# Tracking\n\nThere are a large number of experiment tracking API's available, however getting them all to work with in a multi-processing environment can oftentimes be complex.\n\ud83e\udd17 Accelerate provides a general tracking API that can be used to log useful items during your script through [`Accelerator.log`]\n\n## Integrated Trackers\n\nCurrently `Accelerate` supports four trackers out-of-the-box:\n\n- TensorBoard\n- WandB\n- CometML\n- MLFlow\n\nTo use any of them, pass in the selected type(s) to the `log_with` parameter in [`Accelerate`]:\n```python\nfrom accelerate import Accelerator\nfrom accelerate.utils import LoggerType\n\naccelerator = Accelerator(log_with=\"all\")  # For all available trackers in the environment\naccelerator = Accelerator(log_with=\"wandb\")\naccelerator = Accelerator(log_with=[\"wandb\", LoggerType.TENSORBOARD])\n```\n\nAt the start of your experiment [`Accelerator.init_trackers`] should be used to setup your project, and potentially add any experiment hyperparameters to be logged:\n```python\nhps = {\"num_iterations\": 5, \"learning_rate\": 1e-2}\naccelerator.init_trackers(\"my_project\", config=hps)\n```\n\nWhen you are ready to log any data, [`Accelerator.log`] should be used.\nA `step` can also be passed in to correlate the data with a particular step in the training loop.\n```python\naccelerator.log({\"train_loss\": 1.12, \"valid_loss\": 0.8}, step=1)\n```\n\nOnce you've finished training, make sure to run [`Accelerator.end_training`] so that all the trackers can run their finish functionalities if they have any.\n```python\naccelerator.end_training()\n```\n\n\nA full example is below:\n```python\nfrom accelerate import Accelerator\n\naccelerator = Accelerator(log_with=\"all\")\nconfig = {\n    \"num_iterations\": 5,\n    \"learning_rate\": 1e-2,\n    \"loss_function\": str(my_loss_function),\n}\n\naccelerator.init_trackers(\"example_project\", config=config)\n\nmy_model, my_optimizer, my_training_dataloader = accelerate.prepare(my_model, my_optimizer, my_training_dataloader)\ndevice = accelerator.device\nmy_model.to(device)\n\nfor iteration in config[\"num_iterations\"]:\n    for step, batch in my_training_dataloader:\n        my_optimizer.zero_grad()\n        inputs, targets = batch\n        inputs = inputs.to(device)\n        targets = targets.to(device)\n        outputs = my_model(inputs)\n        loss = my_loss_function(outputs, targets)\n        accelerator.backward(loss)\n        my_optimizer.step()\n        accelerator.log({\"training_loss\": loss}, step=step)\naccelerator.end_training()\n```\n\nIf a tracker requires a directory to save data to, such as `TensorBoard`, then pass the directory path to `project_dir`. The `project_dir` parameter is useful \nwhen there are other configurations to be combined with in the [`~utils.ProjectConfiguration`] data class. For example, you can save the TensorBoard data to `project_dir` and everything else can be logged in the `logging_dir` parameter of [`~utils.ProjectConfiguration`: \n\n```python\naccelerator = Accelerator(log_with=\"tensorboard\", project_dir=\".\")\n\n# use with ProjectConfiguration\nconfig = ProjectConfiguration(project_dir=\".\", logging_dir=\"another/directory\")\naccelerator = Accelerator(log_with=\"tensorboard\", project_config=config)\n```\n\n## Implementing Custom Trackers\n\nTo implement a new tracker to be used in `Accelerator`, a new one can be made through implementing the [`GeneralTracker`] class.\nEvery tracker must implement three functions and have three properties:\n  - `__init__`: \n    - Should store a `run_name` and initialize the tracker API of the integrated library. \n    - If a tracker stores their data locally (such as TensorBoard), a `logging_dir` parameter can be added.\n  - `store_init_configuration`: \n    - Should take in a `values` dictionary and store them as a one-time experiment configuration\n  - `log`: \n    - Should take in a `values` dictionary and a `step`, and should log them to the run\n\n  - `name` (`str`):\n    - A unique string name for the tracker, such as `\"wandb\"` for the wandb tracker. \n    - This will be used for interacting with this tracker specifically\n  - `requires_logging_directory` (`bool`):\n    - Whether a `logging_dir` is needed for this particular tracker and if it uses one.\n  - `tracker`: \n    - This should be implemented as a `@property` function \n    - Should return the internal tracking mechanism the library uses, such as the `run` object for `wandb`.\n\nEach method should also utilize the [`state.PartialState`] class if the logger should only be executed on the main process for instance.\n\nA brief example can be seen below with an integration with Weights and Biases, containing only the relevant information and logging just on \nthe main process:\n```python\nfrom accelerate.tracking import GeneralTracker, on_main_process\nfrom typing import Optional\n\nimport wandb\n\n\nclass MyCustomTracker(GeneralTracker):\n    name = \"wandb\"\n    requires_logging_directory = False\n\n    @on_main_process\n    def __init__(self, run_name: str):\n        self.run_name = run_name\n        run = wandb.init(self.run_name)\n\n    @property\n    def tracker(self):\n        return self.run.run\n\n    @on_main_process\n    def store_init_configuration(self, values: dict):\n        wandb.config(values)\n\n    @on_main_process\n    def log(self, values: dict, step: Optional[int] = None):\n        wandb.log(values, step=step)\n```\n\nWhen you are ready to build your `Accelerator` object, pass in an **instance** of your tracker to [`Accelerator.log_with`] to have it automatically\nbe used with the API:\n\n```python\ntracker = MyCustomTracker(\"some_run_name\")\naccelerator = Accelerator(log_with=tracker)\n```\n\nThese also can be mixed with existing trackers, including with `\"all\"`:\n\n```python\ntracker = MyCustomTracker(\"some_run_name\")\naccelerator = Accelerator(log_with=[tracker, \"all\"])\n```\n\n## Accessing the internal tracker \n\nIf some custom interactions with a tracker might be wanted directly, you can quickly access one using the \n[`Accelerator.get_tracker`] method. Just pass in the string corresponding to a tracker's `.name` attribute \nand it will return that tracker on the main process.\n\nThis example shows doing so with wandb:\n\n```python\nwandb_tracker = accelerator.get_tracker(\"wandb\")\n```\n\nFrom there you can interact with `wandb`'s `run` object like normal:\n\n```python\nwandb_run.log_artifact(some_artifact_to_log)\n```\n\n<Tip>\n  Trackers built in Accelerate will automatically execute on the correct process, \n  so if a tracker is only meant to be ran on the main process it will do so \n  automatically.\n</Tip>\n\nIf you want to truly remove Accelerate's wrapping entirely, you can \nachieve the same outcome with:\n\n```python\nwandb_tracker = accelerator.get_tracker(\"wandb\", unwrap=True)\nwith accelerator.on_main_process:\n    wandb_tracker.log_artifact(some_artifact_to_log)\n```\n\n\n## When a wrapper cannot work\n\nIf a library has an API that does not follow a strict `.log` with an overall dictionary such as Neptune.AI, logging can be done manually under an `if accelerator.is_main_process` statement:\n```diff\n  from accelerate import Accelerator\n+ import neptune.new as neptune\n\n  accelerator = Accelerator()\n+ run = neptune.init(...)\n\n  my_model, my_optimizer, my_training_dataloader = accelerate.prepare(my_model, my_optimizer, my_training_dataloader)\n  device = accelerator.device\n  my_model.to(device)\n\n  for iteration in config[\"num_iterations\"]:\n      for batch in my_training_dataloader:\n          my_optimizer.zero_grad()\n          inputs, targets = batch\n          inputs = inputs.to(device)\n          targets = targets.to(device)\n          outputs = my_model(inputs)\n          loss = my_loss_function(outputs, targets)\n          total_loss += loss\n          accelerator.backward(loss)\n          my_optimizer.step()\n+         if accelerator.is_main_process:\n+             run[\"logs/training/batch/loss\"].log(loss)\n```\n", "<!--Copyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\nspecific language governing permissions and limitations under the License.\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n-->\n\n# Learning how to incorporate \ud83e\udd17 Accelerate features quickly!\n\nPlease use the interactive tool below to help you get started with learning about a particular \nfeature of \ud83e\udd17 Accelerate and how to utilize it! It will provide you with a code diff, an explaination\ntowards what is going on, as well as provide you with some useful links to explore more within\nthe documentation!\n\nMost code examples start from the following python code before integrating \ud83e\udd17 Accelerate in some way:\n\n```python\nfor batch in dataloader:\n    optimizer.zero_grad()\n    inputs, targets = batch\n    inputs = inputs.to(device)\n    targets = targets.to(device)\n    outputs = model(inputs)\n    loss = loss_function(outputs, targets)\n    loss.backward()\n    optimizer.step()\n    scheduler.step()\n```\n\n<div class=\"block dark:hidden\">\n\t<iframe \n        src=\"https://muellerzr-accelerate-examples.hf.space?__theme=light\"\n        width=\"850\"\n        height=\"1600\"\n    ></iframe>\n</div>\n<div class=\"hidden dark:block\">\n    <iframe \n        src=\"https://muellerzr-accelerate-examples.hf.space?__theme=dark\"\n        width=\"850\"\n        height=\"1600\"\n    ></iframe>\n</div>\n", "<!--Copyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\nspecific language governing permissions and limitations under the License.\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n-->\n\n# Intel\u00ae Extension for PyTorch\n\n[IPEX](https://github.com/intel/intel-extension-for-pytorch) is optimized for CPUs with AVX-512 or above, and functionally works for CPUs with only AVX2. So, it is expected to bring performance benefit for Intel CPU generations with AVX-512 or above while CPUs with only AVX2 (e.g., AMD CPUs or older Intel CPUs) might result in a better performance under IPEX, but not guaranteed. IPEX provides performance optimizations for CPU training with both Float32 and BFloat16. The usage of BFloat16 is the main focus of the following sections.\n\nLow precision data type BFloat16 has been natively supported on the 3rd Generation Xeon\u00ae Scalable Processors (aka Cooper Lake) with AVX512 instruction set and will be supported on the next generation of Intel\u00ae Xeon\u00ae Scalable Processors with Intel\u00ae Advanced Matrix Extensions (Intel\u00ae AMX) instruction set with further boosted performance. The Auto Mixed Precision for CPU backend has been enabled since PyTorch-1.10. At the same time, the support of Auto Mixed Precision with BFloat16 for CPU and BFloat16 optimization of operators has been massively enabled in Intel\u00ae Extension for PyTorch, and partially upstreamed to PyTorch master branch. Users can get better performance and user experience with IPEX Auto Mixed Precision.\n\n## IPEX installation:\n\nIPEX release is following PyTorch, to install via pip:\n\n| PyTorch Version   | IPEX version   |\n| :---------------: | :----------:   |\n| 2.0               |  2.0.0         |\n| 1.13              |  1.13.0        |\n| 1.12              |  1.12.300      |\n| 1.11              |  1.11.200      |\n| 1.10              |  1.10.100      |\n\n```\npip install intel_extension_for_pytorch==<version_name> -f https://developer.intel.com/ipex-whl-stable-cpu\n```\n\nCheck more approaches for [IPEX installation](https://intel.github.io/intel-extension-for-pytorch/cpu/latest/tutorials/installation.html).\n\n\n## How It Works For Training optimization in CPU\n\n\ud83e\udd17 Accelerate has integrated [IPEX](https://github.com/intel/intel-extension-for-pytorch), all you need to do is enabling it through the config.\n\n**Scenario 1**: Acceleration of No distributed CPU training\n\nRun <u>accelerate config</u> on your machine:\n\n```bash\n$ accelerate config\n-----------------------------------------------------------------------------------------------------------------------------------------------------------\nIn which compute environment are you running?\nThis machine\n-----------------------------------------------------------------------------------------------------------------------------------------------------------\nWhich type of machine are you using?\nNo distributed training\nDo you want to run your training on CPU only (even if a GPU / Apple Silicon device is available)? [yes/NO]:yes\nDo you want to use Intel PyTorch Extension (IPEX) to speed up training on CPU? [yes/NO]:yes\nDo you wish to optimize your script with torch dynamo?[yes/NO]:NO\nDo you want to use DeepSpeed? [yes/NO]: NO\n-----------------------------------------------------------------------------------------------------------------------------------------------------------\nDo you wish to use FP16 or BF16 (mixed precision)?\nbf16\n```\nThis will generate a config file that will be used automatically to properly set the\ndefault options when doing\n\n```bash\naccelerate launch my_script.py --args_to_my_script\n```\n\nFor instance, here is how you would run the NLP example `examples/nlp_example.py` (from the root of the repo) with IPEX enabled.\ndefault_config.yaml that is generated after `accelerate config`\n\n```bash\ncompute_environment: LOCAL_MACHINE\ndistributed_type: 'NO'\ndowncast_bf16: 'no'\nipex_config:\n  ipex: true\nmachine_rank: 0\nmain_training_function: main\nmixed_precision: bf16\nnum_machines: 1\nnum_processes: 1\nrdzv_backend: static\nsame_network: true\ntpu_env: []\ntpu_use_cluster: false\ntpu_use_sudo: false\nuse_cpu: true\n```\n```bash\naccelerate launch examples/nlp_example.py\n```\n\n**Scenario 2**: Acceleration of distributed CPU training\nwe use Intel oneCCL for communication, combined with Intel\u00ae MPI library to deliver flexible, efficient, scalable cluster messaging on Intel\u00ae architecture. you could refer the [here](https://huggingface.co/docs/transformers/perf_train_cpu_many) for the installation guide\n\nRun <u>accelerate config</u> on your machine(node0):\n\n```bash\n$ accelerate config\n-----------------------------------------------------------------------------------------------------------------------------------------------------------\nIn which compute environment are you running?\nThis machine\n-----------------------------------------------------------------------------------------------------------------------------------------------------------\nWhich type of machine are you using?\nmulti-CPU\nHow many different machines will you use (use more than 1 for multi-node training)? [1]: 4\n-----------------------------------------------------------------------------------------------------------------------------------------------------------\nWhat is the rank of this machine?\n0\nWhat is the IP address of the machine that will host the main process? 36.112.23.24\nWhat is the port you will use to communicate with the main process? 29500\nAre all the machines on the same local network? Answer `no` if nodes are on the cloud and/or on different network hosts [YES/no]: yes\nDo you want to use Intel PyTorch Extension (IPEX) to speed up training on CPU? [yes/NO]:yes\nDo you wish to optimize your script with torch dynamo?[yes/NO]:NO\nHow many CPU(s) should be used for distributed training? [1]:16\n-----------------------------------------------------------------------------------------------------------------------------------------------------------\nDo you wish to use FP16 or BF16 (mixed precision)?\nbf16\n```\nFor instance, here is how you would run the NLP example `examples/nlp_example.py` (from the root of the repo) with IPEX enabled for distributed CPU training.\n\ndefault_config.yaml that is generated after `accelerate config`\n```bash\ncompute_environment: LOCAL_MACHINE\ndistributed_type: MULTI_CPU\ndowncast_bf16: 'no'\nipex_config:\n  ipex: true\nmachine_rank: 0\nmain_process_ip: 36.112.23.24\nmain_process_port: 29500\nmain_training_function: main\nmixed_precision: bf16\nnum_machines: 4\nnum_processes: 16\nrdzv_backend: static\nsame_network: true\ntpu_env: []\ntpu_use_cluster: false\ntpu_use_sudo: false\nuse_cpu: true\n```\n\nSet following env and using intel MPI to launch the training\n\nIn node0, you need to create a configuration file which contains the IP addresses of each node (for example hostfile) and pass that configuration file path as an argument.\n```bash\n$ cat hostfile\nxxx.xxx.xxx.xxx #node0 ip\nxxx.xxx.xxx.xxx #node1 ip\nxxx.xxx.xxx.xxx #node2 ip\nxxx.xxx.xxx.xxx #node3 ip\n```\nNow, run the following command in node0 and **16DDP** will be enabled in node0,node1,node2,node3 with BF16 mixed precision:\n```bash\noneccl_bindings_for_pytorch_path=$(python -c \"from oneccl_bindings_for_pytorch import cwd; print(cwd)\")\nsource $oneccl_bindings_for_pytorch_path/env/setvars.sh\nexport CCL_WORKER_COUNT=1\nexport MASTER_ADDR=xxx.xxx.xxx.xxx #node0 ip\nexport CCL_ATL_TRANSPORT=ofi\nmpirun -f hostfile -n 16 -ppn 4 accelerate launch examples/nlp_example.py\n```\n\n## Related Resources\n\n- [Project's github](https://github.com/intel/intel-extension-for-pytorch)\n- [API docs](https://intel.github.io/intel-extension-for-pytorch/cpu/latest/tutorials/api_doc.html)\n- [Tuning guide](https://intel.github.io/intel-extension-for-pytorch/cpu/latest/tutorials/performance_tuning/tuning_guide.html)\n- [Blogs & Publications](https://intel.github.io/intel-extension-for-pytorch/cpu/latest/tutorials/blogs_publications.html)\n\n", "<!--Copyright 2021 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\nspecific language governing permissions and limitations under the License.\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n-->\n\n# Amazon SageMaker\n\nHugging Face and Amazon introduced new [Hugging Face Deep Learning Containers (DLCs)](https://github.com/aws/deep-learning-containers/blob/master/available_images.md#huggingface-training-containers) to\nmake it easier than ever to train Hugging Face Transformer models in [Amazon SageMaker](https://aws.amazon.com/sagemaker/).\n\n## Getting Started\n\n### Setup & Installation\n\n\nBefore you can run your \ud83e\udd17 Accelerate scripts on Amazon SageMaker you need to sign up for an AWS account. If you do not\nhave an AWS account yet learn more [here](https://docs.aws.amazon.com/sagemaker/latest/dg/gs-set-up.html).\n\nAfter you have your AWS Account you need to install the `sagemaker` sdk for \ud83e\udd17 Accelerate with:\n\n```bash\npip install \"accelerate[sagemaker]\" --upgrade\n```\n\n\ud83e\udd17 Accelerate currently uses the \ud83e\udd17 DLCs, with `transformers`, `datasets` and `tokenizers` pre-installed. \ud83e\udd17\nAccelerate is not in the DLC yet (will soon be added!) so to use it within Amazon SageMaker you need to create a\n`requirements.txt` in the same directory where your training script is located and add it as dependency:\n\n```\naccelerate\n```\n\nYou should also add any other dependencies you have to this `requirements.txt`.\n\n\n### Configure \ud83e\udd17 Accelerate\n\nYou can configure the launch configuration for Amazon SageMaker the same as you do for non SageMaker training jobs with\nthe \ud83e\udd17 Accelerate CLI:\n\n```bash\naccelerate config\n# In which compute environment are you running? ([0] This machine, [1] AWS (Amazon SageMaker)): 1\n```\n\n\ud83e\udd17 Accelerate will go through a questionnaire about your Amazon SageMaker setup and create a config file you can edit.\n\n<Tip>\n\n    \ud83e\udd17 Accelerate is not saving any of your credentials.\n\n</Tip>\n\n### Prepare a \ud83e\udd17 Accelerate fine-tuning script\n\nThe training script is very similar to a training script you might run outside of SageMaker, but to save your model\nafter training you need to specify either `/opt/ml/model` or use `os.environ[\"SM_MODEL_DIR\"]` as your save\ndirectory. After training, artifacts in this directory are uploaded to S3:\n\n\n```diff\n- torch.save('/opt/ml/model`)\n+ accelerator.save('/opt/ml/model')\n```\n\n<Tip warning={true}>\n\n    SageMaker doesn\u2019t support argparse actions. If you want to use, for example, boolean hyperparameters, you need to\n    specify type as bool in your script and provide an explicit True or False value for this hyperparameter. [[REF]](https://sagemaker.readthedocs.io/en/stable/frameworks/pytorch/using_pytorch.html#prepare-a-pytorch-training-script).\n\n</Tip>\n\n### Launch Training\n\nYou can launch your training with \ud83e\udd17 Accelerate CLI with:\n\n```\naccelerate launch path_to_script.py --args_to_the_script\n```\n\nThis will launch your training script using your configuration. The only thing you have to do is provide all the\narguments needed by your training script as named arguments.\n\n**Examples**\n\n<Tip>\n\n    If you run one of the example scripts, don't forget to add `accelerator.save('/opt/ml/model')` to it.\n\n</Tip>\n\n```bash\naccelerate launch ./examples/sagemaker_example.py\n```\n\nOutputs:\n\n```\nConfiguring Amazon SageMaker environment\nConverting Arguments to Hyperparameters\nCreating Estimator\n2021-04-08 11:56:50 Starting - Starting the training job...\n2021-04-08 11:57:13 Starting - Launching requested ML instancesProfilerReport-1617883008: InProgress\n.........\n2021-04-08 11:58:54 Starting - Preparing the instances for training.........\n2021-04-08 12:00:24 Downloading - Downloading input data\n2021-04-08 12:00:24 Training - Downloading the training image..................\n2021-04-08 12:03:39 Training - Training image download completed. Training in progress..\n........\nepoch 0: {'accuracy': 0.7598039215686274, 'f1': 0.8178438661710037}\nepoch 1: {'accuracy': 0.8357843137254902, 'f1': 0.882249560632689}\nepoch 2: {'accuracy': 0.8406862745098039, 'f1': 0.8869565217391304}\n........\n2021-04-08 12:05:40 Uploading - Uploading generated training model\n2021-04-08 12:05:40 Completed - Training job completed\nTraining seconds: 331\nBillable seconds: 331\nYou can find your model data at: s3://your-bucket/accelerate-sagemaker-1-2021-04-08-11-56-47-108/output/model.tar.gz\n```\n\n## Advanced Features\n\n### Distributed Training: Data Parallelism\n\nSet up the accelerate config by running `accelerate config` and answer the SageMaker questions and set it up.\nTo use SageMaker DDP, select it when asked \n`What is the distributed mode? ([0] No distributed training, [1] data parallelism):`.\nExample config below:\n```yaml\nbase_job_name: accelerate-sagemaker-1\ncompute_environment: AMAZON_SAGEMAKER\ndistributed_type: DATA_PARALLEL\nec2_instance_type: ml.p3.16xlarge\niam_role_name: xxxxx\nimage_uri: null\nmixed_precision: fp16\nnum_machines: 1\nprofile: xxxxx\npy_version: py38\npytorch_version: 1.10.2\nregion: us-east-1\ntransformers_version: 4.17.0\nuse_cpu: false\n```\n\n### Distributed Training: Model Parallelism\n\n*currently in development, will be supported soon.*\n\n### Python packages and dependencies\n\n\ud83e\udd17 Accelerate currently uses the \ud83e\udd17 DLCs, with `transformers`, `datasets` and `tokenizers` pre-installed. If you\nwant to use different/other Python packages you can do this by adding them to the `requirements.txt`. These packages\nwill be installed before your training script is started.\n\n### Local Training: SageMaker Local mode\n\nThe local mode in the SageMaker SDK allows you to run your training script locally inside the HuggingFace DLC (Deep Learning container) \nor using your custom container image. This is useful for debugging and testing your training script inside the final container environment.\nLocal mode uses Docker compose (*Note: Docker Compose V2 is not supported yet*). The SDK will handle the authentication against ECR\nto pull the DLC to your local environment. You can emulate CPU (single and multi-instance) and GPU (single instance) SageMaker training jobs.\n\nTo use local mode, you need to set your `ec2_instance_type` to `local`.\n\n```yaml\nec2_instance_type: local\n```\n\n### Advanced configuration\n\nThe configuration allows you to override parameters for the [Estimator](https://sagemaker.readthedocs.io/en/stable/api/training/estimators.html).\nThese settings have to be applied in the config file and are not part of `accelerate config`. You can control many additional aspects of the training job, e.g. use Spot instances, enable network isolation and many more.\n\n```yaml\nadditional_args:\n  # enable network isolation to restrict internet access for containers\n  enable_network_isolation: True\n```\n\nYou can find all available configuration [here](https://sagemaker.readthedocs.io/en/stable/api/training/estimators.html).\n\n### Use Spot Instances\n\nYou can use Spot Instances e.g. using (see [Advanced configuration](#advanced-configuration)):\n```yaml\nadditional_args:\n  use_spot_instances: True\n  max_wait: 86400\n```\n\n*Note: Spot Instances are subject to be terminated and training to be continued from a checkpoint. This is not handled in \ud83e\udd17 Accelerate out of the box. Contact us if you would like this feature.*\n\n### Remote scripts: Use scripts located on Github\n\n*undecided if feature is needed. Contact us if you would like this feature.*", "<!--Copyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\nspecific language governing permissions and limitations under the License.\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n-->\n\n# Example Zoo\n\nBelow contains a non-exhuastive list of tutorials and scripts showcasing \ud83e\udd17 Accelerate\n\n## Official Accelerate Examples:\n\n### Basic Examples\n\nThese examples showcase the base features of Accelerate and are a great starting point\n\n- [Barebones NLP example](https://github.com/huggingface/accelerate/blob/main/examples/nlp_example.py)\n- [Barebones distributed NLP example in a Jupyter Notebook](https://github.com/huggingface/notebooks/blob/main/examples/accelerate_examples/simple_nlp_example.ipynb)\n- [Barebones computer vision example](https://github.com/huggingface/accelerate/blob/main/examples/cv_example.py)\n- [Barebones distributed computer vision example in a Jupyter Notebook](https://github.com/huggingface/notebooks/blob/main/examples/accelerate_examples/simple_cv_example.ipynb)\n- [Using Accelerate in Kaggle](https://www.kaggle.com/code/muellerzr/multi-gpu-and-accelerate)\n\n### Feature Specific Examples\n\nThese examples showcase specific features that the Accelerate framework offers\n\n- [Automatic memory-aware gradient accumulation](https://github.com/huggingface/accelerate/blob/main/examples/by_feature/automatic_gradient_accumulation.py)\n- [Checkpointing states](https://github.com/huggingface/accelerate/blob/main/examples/by_feature/checkpointing.py)\n- [Cross validation](https://github.com/huggingface/accelerate/blob/main/examples/by_feature/cross_validation.py)\n- [DeepSpeed](https://github.com/huggingface/accelerate/blob/main/examples/by_feature/deepspeed_with_config_support.py)\n- [Fully Sharded Data Parallelism](https://github.com/huggingface/accelerate/blob/main/examples/by_feature/fsdp_with_peak_mem_tracking.py)\n- [Gradient accumulation](https://github.com/huggingface/accelerate/blob/main/examples/by_feature/gradient_accumulation.py)\n- [Memory-aware batch size finder](https://github.com/huggingface/accelerate/blob/main/examples/by_feature/memory.py)\n- [Metric Computation](https://github.com/huggingface/accelerate/blob/main/examples/by_feature/multi_process_metrics.py)\n- [Using Trackers](https://github.com/huggingface/accelerate/blob/main/examples/by_feature/tracking.py)\n- [Using Megatron-LM](https://github.com/huggingface/accelerate/blob/main/examples/by_feature/megatron_lm_gpt_pretraining.py)\n\n### Full Examples \n\nThese examples showcase every feature in Accelerate at once that was shown in \"Feature Specific Examples\"\n\n- [Complete NLP example](https://github.com/huggingface/accelerate/blob/main/examples/complete_nlp_example.py)\n- [Complete computer vision example](https://github.com/huggingface/accelerate/blob/main/examples/complete_cv_example.py)\n- [Very complete and extensible vision example showcasing SLURM, hydra, and a very extensible usage of the framework](https://github.com/yuvalkirstain/PickScore)\n- [Causal language model fine-tuning example](https://github.com/huggingface/transformers/blob/main/examples/pytorch/language-modeling/run_clm_no_trainer.py)\n- [Masked language model fine-tuning example](https://github.com/huggingface/transformers/blob/main/examples/pytorch/language-modeling/run_mlm_no_trainer.py)\n- [Speech pretraining example](https://github.com/huggingface/transformers/blob/main/examples/pytorch/speech-pretraining/run_wav2vec2_pretraining_no_trainer.py)\n- [Translation fine-tuning example](https://github.com/huggingface/transformers/blob/main/examples/pytorch/translation/run_translation_no_trainer.py)\n- [Text classification fine-tuning example](https://github.com/huggingface/transformers/blob/main/examples/pytorch/text-classification/run_glue_no_trainer.py)\n- [Semantic segmentation fine-tuning example](https://github.com/huggingface/transformers/blob/main/examples/pytorch/semantic-segmentation/run_semantic_segmentation_no_trainer.py)\n- [Question answering fine-tuning example](https://github.com/huggingface/transformers/blob/main/examples/pytorch/question-answering/run_qa_no_trainer.py)\n- [Beam search question answering fine-tuning example](https://github.com/huggingface/transformers/blob/main/examples/pytorch/question-answering/run_qa_beam_search_no_trainer.py)\n- [Multiple choice question answering fine-tuning example](https://github.com/huggingface/transformers/blob/main/examples/pytorch/multiple-choice/run_swag_no_trainer.py)\n- [Named entity recognition fine-tuning example](https://github.com/huggingface/transformers/blob/main/examples/pytorch/token-classification/run_ner_no_trainer.py)\n- [Image classification fine-tuning example](https://github.com/huggingface/transformers/blob/main/examples/pytorch/image-classification/run_image_classification_no_trainer.py)\n- [Summarization fine-tuning example](https://github.com/huggingface/transformers/blob/main/examples/pytorch/summarization/run_summarization_no_trainer.py)\n- [End-to-end examples on how to use AWS SageMaker integration of Accelerate](https://github.com/huggingface/notebooks/blob/main/sagemaker/22_accelerate_sagemaker_examples/README.md)\n- [Megatron-LM examples for various NLp tasks](https://github.com/pacman100/accelerate-megatron-test) \n\n## Integration Examples \n\nThese are tutorials from libraries that integrate with \ud83e\udd17 Accelerate: \n\n> Don't find your integration here? Make a PR to include it!\n\n### Catalyst\n\n- [Distributed training tutorial with Catalyst](https://catalyst-team.github.io/catalyst/tutorials/ddp.html)\n\n### DALLE2-pytorch \n\n- [Fine-tuning DALLE2](https://github.com/lucidrains/DALLE2-pytorch#usage)\n\n### \ud83e\udd17 diffusers\n\n- [Performing textual inversion with diffusers](https://github.com/huggingface/diffusers/tree/main/examples/textual_inversion)\n- [Training DreamBooth with diffusers](https://github.com/huggingface/diffusers/tree/main/examples/dreambooth)\n\n### fastai \n\n- [Distributed training from Jupyter Notebooks with fastai](https://docs.fast.ai/tutorial.distributed.html)\n- [Basic distributed training examples with fastai](https://docs.fast.ai/examples/distributed_app_examples.html)\n\n### GradsFlow\n\n- [Auto Image Classification with GradsFlow](https://docs.gradsflow.com/en/latest/examples/nbs/01-ImageClassification/)\n\n### imagen-pytorch \n\n- [Fine-tuning Imagen](https://github.com/lucidrains/imagen-pytorch#usage)\n\n### Kornia\n\n- [Fine-tuning vision models with Kornia's Trainer](https://kornia.readthedocs.io/en/latest/get-started/training.html)\n\n### PyTorch Accelerated \n\n- [Quickstart distributed training tutorial with PyTorch Accelerated](https://pytorch-accelerated.readthedocs.io/en/latest/quickstart.html)\n\n### PyTorch3D\n\n- [Perform Deep Learning with 3D data](https://pytorch3d.org/tutorials/)\n\n### Stable-Dreamfusion\n\n- [Training with Stable-Dreamfusion to convert text to a 3D model](https://colab.research.google.com/drive/1MXT3yfOFvO0ooKEfiUUvTKwUkrrlCHpF?usp=sharing)\n\n### Tez \n\n- [Leaf disease detection with Tez and Accelerate](https://www.kaggle.com/code/abhishek/tez-faster-and-easier-training-for-leaf-detection/notebook)\n\n### trlx \n\n- [How to implement a sentiment learning task with trlx](https://github.com/CarperAI/trlx#example-how-to-add-a-task)\n\n### Comfy-UI\n\n- [Enabling using large Stable Diffusion Models in low-vram settings using Accelerate](https://github.com/comfyanonymous/ComfyUI/blob/master/comfy/model_management.py#L291-L296)\n\n\n## In Science\n\nBelow contains a non-exhaustive list of papers utilizing \ud83e\udd17 Accelerate. \n\n> Don't find your paper here? Make a PR to include it!\n\n* Yuval Kirstain, Adam Polyak, Uriel Singer, Shahbuland Matiana, Joe Penna, Omer Levy: \u201cPick-a-Pic: An Open Dataset of User Preferences for Text-to-Image Generation\u201d, 2023; [arXiv:2305.01569](http://arxiv.org/abs/2305.01569).\n* Lei Wang, Wanyu Xu, Yihuai Lan, Zhiqiang Hu, Yunshi Lan, Roy Ka-Wei Lee, Ee-Peng Lim: \u201cPlan-and-Solve Prompting: Improving Zero-Shot Chain-of-Thought Reasoning by Large Language Models\u201d, 2023; [arXiv:2305.04091](http://arxiv.org/abs/2305.04091).\n* Arthur C\u00e2mara, Claudia Hauff: \u201cMoving Stuff Around: A study on efficiency of moving documents into memory for Neural IR models\u201d, 2022; [arXiv:2205.08343](http://arxiv.org/abs/2205.08343).\n* Ying Sheng, Lianmin Zheng, Binhang Yuan, Zhuohan Li, Max Ryabinin, Daniel Y. Fu, Zhiqiang Xie, Beidi Chen, Clark Barrett, Joseph E. Gonzalez, Percy Liang, Christopher R\u00e9, Ion Stoica, Ce Zhang: \u201cHigh-throughput Generative Inference of Large Language Models with a Single GPU\u201d, 2023; [arXiv:2303.06865](http://arxiv.org/abs/2303.06865).\n* Peter Melchior, Yan Liang, ChangHoon Hahn, Andy Goulding: \u201cAutoencoding Galaxy Spectra I: Architecture\u201d, 2022; [arXiv:2211.07890](http://arxiv.org/abs/2211.07890).\n* Jiaao Chen, Aston Zhang, Mu Li, Alex Smola, Diyi Yang: \u201cA Cheaper and Better Diffusion Language Model with Soft-Masked Noise\u201d, 2023; [arXiv:2304.04746](http://arxiv.org/abs/2304.04746).\n* Ayaan Haque, Matthew Tancik, Alexei A. Efros, Aleksander Holynski, Angjoo Kanazawa: \u201cInstruct-NeRF2NeRF: Editing 3D Scenes with Instructions\u201d, 2023; [arXiv:2303.12789](http://arxiv.org/abs/2303.12789).\n* Luke Melas-Kyriazi, Christian Rupprecht, Iro Laina, Andrea Vedaldi: \u201cRealFusion: 360\u00b0 Reconstruction of Any Object from a Single Image\u201d, 2023; [arXiv:2302.10663](http://arxiv.org/abs/2302.10663).\n* Xiaoshi Wu, Keqiang Sun, Feng Zhu, Rui Zhao, Hongsheng Li: \u201cBetter Aligning Text-to-Image Models with Human Preference\u201d, 2023; [arXiv:2303.14420](http://arxiv.org/abs/2303.14420).\n* Yongliang Shen, Kaitao Song, Xu Tan, Dongsheng Li, Weiming Lu, Yueting Zhuang: \u201cHuggingGPT: Solving AI Tasks with ChatGPT and its Friends in HuggingFace\u201d, 2023; [arXiv:2303.17580](http://arxiv.org/abs/2303.17580).\n* Yue Yang, Wenlin Yao, Hongming Zhang, Xiaoyang Wang, Dong Yu, Jianshu Chen: \u201cZ-LaVI: Zero-Shot Language Solver Fueled by Visual Imagination\u201d, 2022; [arXiv:2210.12261](http://arxiv.org/abs/2210.12261).\n* Sheng-Yen Chou, Pin-Yu Chen, Tsung-Yi Ho: \u201cHow to Backdoor Diffusion Models?\u201d, 2022; [arXiv:2212.05400](http://arxiv.org/abs/2212.05400).\n* Junyoung Seo, Wooseok Jang, Min-Seop Kwak, Jaehoon Ko, Hyeonsu Kim, Junho Kim, Jin-Hwa Kim, Jiyoung Lee, Seungryong Kim: \u201cLet 2D Diffusion Model Know 3D-Consistency for Robust Text-to-3D Generation\u201d, 2023; [arXiv:2303.07937](http://arxiv.org/abs/2303.07937).\n* Or Patashnik, Daniel Garibi, Idan Azuri, Hadar Averbuch-Elor, Daniel Cohen-Or: \u201cLocalizing Object-level Shape Variations with Text-to-Image Diffusion Models\u201d, 2023; [arXiv:2303.11306](http://arxiv.org/abs/2303.11306).\n* D\u00eddac Sur\u00eds, Sachit Menon, Carl Vondrick: \u201cViperGPT: Visual Inference via Python Execution for Reasoning\u201d, 2023; [arXiv:2303.08128](http://arxiv.org/abs/2303.08128).\n* Chenyang Qi, Xiaodong Cun, Yong Zhang, Chenyang Lei, Xintao Wang, Ying Shan, Qifeng Chen: \u201cFateZero: Fusing Attentions for Zero-shot Text-based Video Editing\u201d, 2023; [arXiv:2303.09535](http://arxiv.org/abs/2303.09535).\n* Sean Welleck, Jiacheng Liu, Ximing Lu, Hannaneh Hajishirzi, Yejin Choi: \u201cNaturalProver: Grounded Mathematical Proof Generation with Language Models\u201d, 2022; [arXiv:2205.12910](http://arxiv.org/abs/2205.12910).\n* Elad Richardson, Gal Metzer, Yuval Alaluf, Raja Giryes, Daniel Cohen-Or: \u201cTEXTure: Text-Guided Texturing of 3D Shapes\u201d, 2023; [arXiv:2302.01721](http://arxiv.org/abs/2302.01721).\n* Puijin Cheng, Li Lin, Yijin Huang, Huaqing He, Wenhan Luo, Xiaoying Tang: \u201cLearning Enhancement From Degradation: A Diffusion Model For Fundus Image Enhancement\u201d, 2023; [arXiv:2303.04603](http://arxiv.org/abs/2303.04603).\n* Shun Shao, Yftah Ziser, Shay Cohen: \u201cErasure of Unaligned Attributes from Neural Representations\u201d, 2023; [arXiv:2302.02997](http://arxiv.org/abs/2302.02997).\n* Seonghyeon Ye, Hyeonbin Hwang, Sohee Yang, Hyeongu Yun, Yireun Kim, Minjoon Seo: \u201cIn-Context Instruction Learning\u201d, 2023; [arXiv:2302.14691](http://arxiv.org/abs/2302.14691).\n* Shikun Liu, Linxi Fan, Edward Johns, Zhiding Yu, Chaowei Xiao, Anima Anandkumar: \u201cPrismer: A Vision-Language Model with An Ensemble of Experts\u201d, 2023; [arXiv:2303.02506](http://arxiv.org/abs/2303.02506 ).\n* Haoyu Chen, Zhihua Wang, Yang Yang, Qilin Sun, Kede Ma: \u201cLearning a Deep Color Difference Metric for Photographic Images\u201d, 2023; [arXiv:2303.14964](http://arxiv.org/abs/2303.14964).\n* Van-Hoang Le, Hongyu Zhang: \u201cLog Parsing with Prompt-based Few-shot Learning\u201d, 2023; [arXiv:2302.07435](http://arxiv.org/abs/2302.07435).\n* Keito Kudo, Yoichi Aoki, Tatsuki Kuribayashi, Ana Brassard, Masashi Yoshikawa, Keisuke Sakaguchi, Kentaro Inui: \u201cDo Deep Neural Networks Capture Compositionality in Arithmetic Reasoning?\u201d, 2023; [arXiv:2302.07866](http://arxiv.org/abs/2302.07866).\n* Ruoyao Wang, Peter Jansen, Marc-Alexandre C\u00f4t\u00e9, Prithviraj Ammanabrolu: \u201cBehavior Cloned Transformers are Neurosymbolic Reasoners\u201d, 2022; [arXiv:2210.07382](http://arxiv.org/abs/2210.07382).\n* Martin Wessel, Tom\u00e1\u0161 Horych, Terry Ruas, Akiko Aizawa, Bela Gipp, Timo Spinde: \u201cIntroducing MBIB -- the first Media Bias Identification Benchmark Task and Dataset Collection\u201d, 2023; [arXiv:2304.13148](http://arxiv.org/abs/2304.13148 ). DOI: [https://dx.doi.org/10.1145/3539618.3591882 10.1145/3539618.3591882].\n* Hila Chefer, Yuval Alaluf, Yael Vinker, Lior Wolf, Daniel Cohen-Or: \u201cAttend-and-Excite: Attention-Based Semantic Guidance for Text-to-Image Diffusion Models\u201d, 2023; [arXiv:2301.13826](http://arxiv.org/abs/2301.13826).\n* Marcio Fonseca, Yftah Ziser, Shay B. Cohen: \u201cFactorizing Content and Budget Decisions in Abstractive Summarization of Long Documents\u201d, 2022; [arXiv:2205.12486](http://arxiv.org/abs/2205.12486).\n* Elad Richardson, Gal Metzer, Yuval Alaluf, Raja Giryes, Daniel Cohen-Or: \u201cTEXTure: Text-Guided Texturing of 3D Shapes\u201d, 2023; [arXiv:2302.01721](http://arxiv.org/abs/2302.01721).\n* Tianxing He, Jingyu Zhang, Tianle Wang, Sachin Kumar, Kyunghyun Cho, James Glass, Yulia Tsvetkov: \u201cOn the Blind Spots of Model-Based Evaluation Metrics for Text Generation\u201d, 2022; [arXiv:2212.10020](http://arxiv.org/abs/2212.10020).\n* Ori Ram, Yoav Levine, Itay Dalmedigos, Dor Muhlgay, Amnon Shashua, Kevin Leyton-Brown, Yoav Shoham: \u201cIn-Context Retrieval-Augmented Language Models\u201d, 2023; [arXiv:2302.00083](http://arxiv.org/abs/2302.00083).\n* Dacheng Li, Rulin Shao, Hongyi Wang, Han Guo, Eric P. Xing, Hao Zhang: \u201cMPCFormer: fast, performant and private Transformer inference with MPC\u201d, 2022; [arXiv:2211.01452](http://arxiv.org/abs/2211.01452).\n* Baolin Peng, Michel Galley, Pengcheng He, Chris Brockett, Lars Liden, Elnaz Nouri, Zhou Yu, Bill Dolan, Jianfeng Gao: \u201cGODEL: Large-Scale Pre-Training for Goal-Directed Dialog\u201d, 2022; [arXiv:2206.11309](http://arxiv.org/abs/2206.11309).\n* Egil R\u00f8nningstad, Erik Velldal, Lilja \u00d8vrelid: \u201cEntity-Level Sentiment Analysis (ELSA): An exploratory task survey\u201d, 2023, Proceedings of the 29th International Conference on Computational Linguistics, 2022, pages 6773-6783; [arXiv:2304.14241](http://arxiv.org/abs/2304.14241).\n* Charlie Snell, Ilya Kostrikov, Yi Su, Mengjiao Yang, Sergey Levine: \u201cOffline RL for Natural Language Generation with Implicit Language Q Learning\u201d, 2022; [arXiv:2206.11871](http://arxiv.org/abs/2206.11871).\n* Zhiruo Wang, Shuyan Zhou, Daniel Fried, Graham Neubig: \u201cExecution-Based Evaluation for Open-Domain Code Generation\u201d, 2022; [arXiv:2212.10481](http://arxiv.org/abs/2212.10481).\n* Minh-Long Luu, Zeyi Huang, Eric P. Xing, Yong Jae Lee, Haohan Wang: \u201cExpeditious Saliency-guided Mix-up through Random Gradient Thresholding\u201d, 2022; [arXiv:2212.04875](http://arxiv.org/abs/2212.04875).\n* Jun Hao Liew, Hanshu Yan, Daquan Zhou, Jiashi Feng: \u201cMagicMix: Semantic Mixing with Diffusion Models\u201d, 2022; [arXiv:2210.16056](http://arxiv.org/abs/2210.16056).\n* Yaqing Wang, Subhabrata Mukherjee, Xiaodong Liu, Jing Gao, Ahmed Hassan Awadallah, Jianfeng Gao: \u201cLiST: Lite Prompted Self-training Makes Parameter-Efficient Few-shot Learners\u201d, 2021; [arXiv:2110.06274](http://arxiv.org/abs/2110.06274).", "<!--Copyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\nspecific language governing permissions and limitations under the License.\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n-->\n\n# Performing gradient accumulation with \ud83e\udd17 Accelerate\n\nGradient accumulation is a technique where you can train on bigger batch sizes than \nyour machine would normally be able to fit into memory. This is done by accumulating gradients over\nseveral batches, and only stepping the optimizer after a certain number of batches have been performed.\n\nWhile technically standard gradient accumulation code would work fine in a distributed setup, it is not the most efficient\nmethod for doing so and you may experience considerable slowdowns!\n\nIn this tutorial you will see how to quickly setup gradient accumulation and perform it with the utilities provided in \ud83e\udd17 Accelerate,\nwhich can total to adding just one new line of code!\n\nThis example will use a very simplistic PyTorch training loop that performs gradient accumulation every two batches:\n\n```python\ndevice = \"cuda\"\nmodel.to(device)\n\ngradient_accumulation_steps = 2\n\nfor index, batch in enumerate(training_dataloader):\n    inputs, targets = batch\n    inputs = inputs.to(device)\n    targets = targets.to(device)\n    outputs = model(inputs)\n    loss = loss_function(outputs, targets)\n    loss = loss / gradient_accumulation_steps\n    loss.backward()\n    if (index + 1) % gradient_accumulation_steps == 0:\n        optimizer.step()\n        scheduler.step()\n        optimizer.zero_grad()\n```\n\n## Converting it to \ud83e\udd17 Accelerate\n\nFirst the code shown earlier will be converted to utilize \ud83e\udd17 Accelerate without the special gradient accumulation helper:\n\n```diff\n+ from accelerate import Accelerator\n+ accelerator = Accelerator()\n\n+ model, optimizer, training_dataloader, scheduler = accelerator.prepare(\n+     model, optimizer, training_dataloader, scheduler\n+ )\n\n  for index, batch in enumerate(training_dataloader):\n      inputs, targets = batch\n-     inputs = inputs.to(device)\n-     targets = targets.to(device)\n      outputs = model(inputs)\n      loss = loss_function(outputs, targets)\n      loss = loss / gradient_accumulation_steps\n+     accelerator.backward(loss)\n      if (index+1) % gradient_accumulation_steps == 0:\n          optimizer.step()\n          scheduler.step()\n          optimizer.zero_grad()\n```\n\n<Tip warning={true}>\n\n  In its current state, this code is not going to perform gradient accumulation efficiently due to a process called gradient synchronization. Read more about that in the [Concepts tutorial](../concept_guides/gradient_synchronization)!\n\n</Tip>\n\n## Letting \ud83e\udd17 Accelerate handle gradient accumulation\n\nAll that is left now is to let \ud83e\udd17 Accelerate handle the gradient accumulation for us. To do so you should pass in a `gradient_accumulation_steps` parameter to [`Accelerator`], dictating the number \nof steps to perform before each call to `step()` and how to automatically adjust the loss during the call to [`~Accelerator.backward`]:\n\n```diff\n  from accelerate import Accelerator\n- accelerator = Accelerator()\n+ accelerator = Accelerator(gradient_accumulation_steps=2)\n```\n\nAlternatively, you can pass in a `gradient_accumulation_plugin` parameter to the [`Accelerator`] object's `__init__`, which will allow you to further customize the gradient accumulation behavior. \nRead more about that in the [GradientAccumulationPlugin](../package_reference/accelerator#accelerate.utils.GradientAccumulationPlugin) docs.\n\nFrom here you can use the [`~Accelerator.accumulate`] context manager from inside your training loop to automatically perform the gradient accumulation for you!\nYou just wrap it around the entire training part of our code: \n\n```diff\n- for index, batch in enumerate(training_dataloader):\n+ for batch in training_dataloader:\n+     with accelerator.accumulate(model):\n          inputs, targets = batch\n          outputs = model(inputs)\n```\n\nYou can remove all the special checks for the step number and the loss adjustment:\n\n```diff\n- loss = loss / gradient_accumulation_steps\n  accelerator.backward(loss)\n- if (index+1) % gradient_accumulation_steps == 0:\n  optimizer.step()\n  scheduler.step()\n  optimizer.zero_grad()\n```\n\nAs you can see the [`Accelerator`] is able to keep track of the batch number you are on and it will automatically know whether to step through the prepared optimizer and how to adjust the loss. \n\n<Tip>\nTypically with gradient accumulation, you would need to adjust the number of steps to reflect the change in total batches you are \ntraining on. \ud83e\udd17 Accelerate automagically does this for you by default. Behind the scenes we instantiate a GradientAccumulationPlugin configured to do this.\n</Tip>\n\n## The finished code\n\nBelow is the finished implementation for performing gradient accumulation with \ud83e\udd17 Accelerate\n\n```python\nfor batch in training_dataloader:\n    with accelerator.accumulate(model):\n        inputs, targets = batch\n        outputs = model(inputs)\n        loss = loss_function(outputs, targets)\n        accelerator.backward(loss)\n        optimizer.step()\n        scheduler.step()\n        optimizer.zero_grad()\n```\n\nTo learn more about what magic this wraps around, read the [Gradient Synchronization concept guide](../concept_guides/gradient_synchronization)\n", "<!--Copyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\nspecific language governing permissions and limitations under the License.\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n-->\n\n# Launching Multi-GPU Training from a Jupyter Environment\n\nThis tutorial teaches you how to fine tune a computer vision model with \ud83e\udd17 Accelerate from a Jupyter Notebook on a distributed system.\nYou will also learn how to setup a few requirements needed for ensuring your environment is configured properly, your data has been prepared properly, and finally how to launch training.\n\n<Tip>\n\n    This tutorial is also available as a Jupyter Notebook [here](https://github.com/huggingface/notebooks/blob/main/examples/accelerate_examples/simple_cv_example.ipynb)\n\n</Tip>\n\n## Configuring the Environment\n\nBefore any training can be performed, a \ud83e\udd17 Accelerate config file must exist in the system. Usually this can be done by running the following in a terminal and answering the prompts:\n\n```bash\naccelerate config\n```\n\nHowever, if general defaults are fine and you are *not* running on a TPU, \ud83e\udd17Accelerate has a utility to quickly write your GPU configuration into a config file via [`utils.write_basic_config`].\n\nThe following code will restart Jupyter after writing the configuration, as CUDA code was called to perform this. \n\n<Tip warning={true}>\n\n    CUDA can't be initialized more than once on a multi-GPU system. It's fine to debug in the notebook and have calls to CUDA, but in order to finally train a full cleanup and restart will need to be performed.\n    \n</Tip>\n\n```python\nimport os\nfrom accelerate.utils import write_basic_config\n\nwrite_basic_config()  # Write a config file\nos._exit(00)  # Restart the notebook\n```\n\n## Preparing the Dataset and Model\n\nNext you should prepare your dataset. As mentioned at earlier, great care should be taken when preparing the `DataLoaders` and model to make sure that **nothing** is put on *any* GPU. \n\nIf you do, it is recommended to put that specific code into a function and call that from within the notebook launcher interface, which will be shown later. \n\nMake sure the dataset is downloaded based on the directions [here](https://github.com/huggingface/accelerate/tree/main/examples#simple-vision-example)\n\n```python\nimport os, re, torch, PIL\nimport numpy as np\n\nfrom torch.optim.lr_scheduler import OneCycleLR\nfrom torch.utils.data import DataLoader, Dataset\nfrom torchvision.transforms import Compose, RandomResizedCrop, Resize, ToTensor\n\nfrom accelerate import Accelerator\nfrom accelerate.utils import set_seed\nfrom timm import create_model\n```\n\nFirst you need to create a function to extract the class name based on a filename:\n\n```python\nimport os\n\ndata_dir = \"../../images\"\nfnames = os.listdir(data_dir)\nfname = fnames[0]\nprint(fname)\n```\n\n```python out\nbeagle_32.jpg\n```\n\nIn the case here, the label is `beagle`. Using regex you can extract the label from the filename:\n\n```python\nimport re\n\n\ndef extract_label(fname):\n    stem = fname.split(os.path.sep)[-1]\n    return re.search(r\"^(.*)_\\d+\\.jpg$\", stem).groups()[0]\n```\n\n```python\nextract_label(fname)\n```\n\nAnd you can see it properly returned the right name for our file:\n\n```python out\n\"beagle\"\n```\n\nNext a `Dataset` class should be made to handle grabbing the image and the label:\n\n```python\nclass PetsDataset(Dataset):\n    def __init__(self, file_names, image_transform=None, label_to_id=None):\n        self.file_names = file_names\n        self.image_transform = image_transform\n        self.label_to_id = label_to_id\n\n    def __len__(self):\n        return len(self.file_names)\n\n    def __getitem__(self, idx):\n        fname = self.file_names[idx]\n        raw_image = PIL.Image.open(fname)\n        image = raw_image.convert(\"RGB\")\n        if self.image_transform is not None:\n            image = self.image_transform(image)\n        label = extract_label(fname)\n        if self.label_to_id is not None:\n            label = self.label_to_id[label]\n        return {\"image\": image, \"label\": label}\n```\n\nNow to build the dataset. Outside the training function you can find and declare all the filenames and labels and use them as references inside the \nlaunched function:\n\n```python\nfnames = [os.path.join(\"../../images\", fname) for fname in fnames if fname.endswith(\".jpg\")]\n```\n\nNext gather all the labels:\n\n```python\nall_labels = [extract_label(fname) for fname in fnames]\nid_to_label = list(set(all_labels))\nid_to_label.sort()\nlabel_to_id = {lbl: i for i, lbl in enumerate(id_to_label)}\n```\n\nNext, you should make a `get_dataloaders` function that will return your built dataloaders for you. As mentioned earlier, if data is automatically \nsent to the GPU or a TPU device when building your `DataLoaders`, they must be built using this method. \n\n```python\ndef get_dataloaders(batch_size: int = 64):\n    \"Builds a set of dataloaders with a batch_size\"\n    random_perm = np.random.permutation(len(fnames))\n    cut = int(0.8 * len(fnames))\n    train_split = random_perm[:cut]\n    eval_split = random_perm[cut:]\n\n    # For training a simple RandomResizedCrop will be used\n    train_tfm = Compose([RandomResizedCrop((224, 224), scale=(0.5, 1.0)), ToTensor()])\n    train_dataset = PetsDataset([fnames[i] for i in train_split], image_transform=train_tfm, label_to_id=label_to_id)\n\n    # For evaluation a deterministic Resize will be used\n    eval_tfm = Compose([Resize((224, 224)), ToTensor()])\n    eval_dataset = PetsDataset([fnames[i] for i in eval_split], image_transform=eval_tfm, label_to_id=label_to_id)\n\n    # Instantiate dataloaders\n    train_dataloader = DataLoader(train_dataset, shuffle=True, batch_size=batch_size, num_workers=4)\n    eval_dataloader = DataLoader(eval_dataset, shuffle=False, batch_size=batch_size * 2, num_workers=4)\n    return train_dataloader, eval_dataloader\n```\n\nFinally, you should import the scheduler to be used later:\n\n```python\nfrom torch.optim.lr_scheduler import CosineAnnealingLR\n```\n\n## Writing the Training Function\n\nNow you can build the training loop. [`notebook_launcher`] works by passing in a function to call that will be ran across the distributed system.\n\nHere is a basic training loop for the animal classification problem:\n\n<Tip>\n\n    The code has been split up to allow for explainations on each section. A full version that can be copy and pasted will be available at the end\n\n</Tip>\n\n\n```python\ndef training_loop(mixed_precision=\"fp16\", seed: int = 42, batch_size: int = 64):\n    set_seed(seed)\n    accelerator = Accelerator(mixed_precision=mixed_precision)\n```\n\nFirst you should set the seed and create an [`Accelerator`] object as early in the training loop as possible.\n\n<Tip warning={true}>\n\n    If training on the TPU, your training loop should take in the model as a parameter and it should be instantiated \n    outside of the training loop function. See the [TPU best practices](../concept_guides/training_tpu) \n    to learn why\n\n</Tip>\n\nNext you should build your dataloaders and create your model:\n\n```python\n    train_dataloader, eval_dataloader = get_dataloaders(batch_size)\n    model = create_model(\"resnet50d\", pretrained=True, num_classes=len(label_to_id))\n```\n\n<Tip>\n\n    You build the model here so that the seed also controls the new weight initialization\n\n</Tip>\n\nAs you are performing transfer learning in this example, the encoder of the model starts out frozen so the head of the model can be \ntrained only initially:\n\n```python\n    for param in model.parameters():\n        param.requires_grad = False\n    for param in model.get_classifier().parameters():\n        param.requires_grad = True\n```\n\nNormalizing the batches of images will make training a little faster:\n\n```python\n    mean = torch.tensor(model.default_cfg[\"mean\"])[None, :, None, None]\n    std = torch.tensor(model.default_cfg[\"std\"])[None, :, None, None]\n```\n\nTo make these constants available on the active device, you should set it to the Accelerator's device:\n\n```python\n    mean = mean.to(accelerator.device)\n    std = std.to(accelerator.device)\n```\n\nNext instantiate the rest of the PyTorch classes used for training:\n\n```python\n    optimizer = torch.optim.Adam(params=model.parameters(), lr=3e-2 / 25)\n    lr_scheduler = OneCycleLR(optimizer=optimizer, max_lr=3e-2, epochs=5, steps_per_epoch=len(train_dataloader))\n```\n\nBefore passing everything to [`~Accelerator.prepare`].\n\n<Tip>\n\n    There is no specific order to remember, you just need to unpack the objects in the same order you gave them to the prepare method.\n\n</Tip>\n\n```python\n    model, optimizer, train_dataloader, eval_dataloader, lr_scheduler = accelerator.prepare(\n        model, optimizer, train_dataloader, eval_dataloader, lr_scheduler\n    )\n```\n\nNow train the model:\n\n```python\n    for epoch in range(5):\n        model.train()\n        for batch in train_dataloader:\n            inputs = (batch[\"image\"] - mean) / std\n            outputs = model(inputs)\n            loss = torch.nn.functional.cross_entropy(outputs, batch[\"label\"])\n            accelerator.backward(loss)\n            optimizer.step()\n            lr_scheduler.step()\n            optimizer.zero_grad()\n```\n\nThe evaluation loop will look slightly different compared to the training loop. The number of elements passed as well as the overall \ntotal accuracy of each batch will be added to two constants:\n\n```python\n        model.eval()\n        accurate = 0\n        num_elems = 0\n```\n\nNext you have the rest of your standard PyTorch loop:\n\n```python\n        for batch in eval_dataloader:\n            inputs = (batch[\"image\"] - mean) / std\n            with torch.no_grad():\n                outputs = model(inputs)\n            predictions = outputs.argmax(dim=-1)\n```\n\nBefore finally the last major difference. \n\nWhen performing distributed evaluation, the predictions and labels need to be passed through \n[`~Accelerator.gather`] so that all of the data is available on the current device and a properly calculated metric can be achieved:\n\n```python\n            accurate_preds = accelerator.gather(predictions) == accelerator.gather(batch[\"label\"])\n            num_elems += accurate_preds.shape[0]\n            accurate += accurate_preds.long().sum()\n```\n\nNow you just need to calculate the actual metric for this problem, and you can print it on the main process using [`~Accelerator.print`]:\n\n```python\n        eval_metric = accurate.item() / num_elems\n        accelerator.print(f\"epoch {epoch}: {100 * eval_metric:.2f}\")\n```\n\nA full version of this training loop is available below:\n\n```python\ndef training_loop(mixed_precision=\"fp16\", seed: int = 42, batch_size: int = 64):\n    set_seed(seed)\n    # Initialize accelerator\n    accelerator = Accelerator(mixed_precision=mixed_precision)\n    # Build dataloaders\n    train_dataloader, eval_dataloader = get_dataloaders(batch_size)\n\n    # Instantiate the model (you build the model here so that the seed also controls new weight initaliziations)\n    model = create_model(\"resnet50d\", pretrained=True, num_classes=len(label_to_id))\n\n    # Freeze the base model\n    for param in model.parameters():\n        param.requires_grad = False\n    for param in model.get_classifier().parameters():\n        param.requires_grad = True\n\n    # You can normalize the batches of images to be a bit faster\n    mean = torch.tensor(model.default_cfg[\"mean\"])[None, :, None, None]\n    std = torch.tensor(model.default_cfg[\"std\"])[None, :, None, None]\n\n    # To make these constants available on the active device, set it to the accelerator device\n    mean = mean.to(accelerator.device)\n    std = std.to(accelerator.device)\n\n    # Intantiate the optimizer\n    optimizer = torch.optim.Adam(params=model.parameters(), lr=3e-2 / 25)\n\n    # Instantiate the learning rate scheduler\n    lr_scheduler = OneCycleLR(optimizer=optimizer, max_lr=3e-2, epochs=5, steps_per_epoch=len(train_dataloader))\n\n    # Prepare everything\n    # There is no specific order to remember, you just need to unpack the objects in the same order you gave them to the\n    # prepare method.\n    model, optimizer, train_dataloader, eval_dataloader, lr_scheduler = accelerator.prepare(\n        model, optimizer, train_dataloader, eval_dataloader, lr_scheduler\n    )\n\n    # Now you train the model\n    for epoch in range(5):\n        model.train()\n        for batch in train_dataloader:\n            inputs = (batch[\"image\"] - mean) / std\n            outputs = model(inputs)\n            loss = torch.nn.functional.cross_entropy(outputs, batch[\"label\"])\n            accelerator.backward(loss)\n            optimizer.step()\n            lr_scheduler.step()\n            optimizer.zero_grad()\n\n        model.eval()\n        accurate = 0\n        num_elems = 0\n        for batch in eval_dataloader:\n            inputs = (batch[\"image\"] - mean) / std\n            with torch.no_grad():\n                outputs = model(inputs)\n            predictions = outputs.argmax(dim=-1)\n            accurate_preds = accelerator.gather(predictions) == accelerator.gather(batch[\"label\"])\n            num_elems += accurate_preds.shape[0]\n            accurate += accurate_preds.long().sum()\n\n        eval_metric = accurate.item() / num_elems\n        # Use accelerator.print to print only on the main process.\n        accelerator.print(f\"epoch {epoch}: {100 * eval_metric:.2f}\")\n```\n\n## Using the notebook_launcher\n\nAll that's left is to use the [`notebook_launcher`].\n\nYou pass in the function, the arguments (as a tuple), and the number of processes to train on. (See the [documentation](../package_reference/launchers) for more information)\n\n```python\nfrom accelerate import notebook_launcher\n```\n\n```python\nargs = (\"fp16\", 42, 64)\nnotebook_launcher(training_loop, args, num_processes=2)\n```\n\nIn the case of running on the TPU, it would look like so:\n\n```python\nmodel = create_model(\"resnet50d\", pretrained=True, num_classes=len(label_to_id))\n\nargs = (model, \"fp16\", 42, 64)\nnotebook_launcher(training_loop, args, num_processes=8)\n```\n\nAs it's running it will print the progress as well as state how many devices you ran on. This tutorial was ran with two GPUs:\n\n```python out\nLaunching training on 2 GPUs.\nepoch 0: 88.12\nepoch 1: 91.73\nepoch 2: 92.58\nepoch 3: 93.90\nepoch 4: 94.71\n```\n\nAnd that's it!\n\n## Conclusion\n\nThis notebook showed how to perform distributed training from inside of a Jupyter Notebook. Some key notes to remember:\n\n- Make sure to save any code that use CUDA (or CUDA imports) for the function passed to [`notebook_launcher`]\n- Set the `num_processes` to be the number of devices used for training (such as number of GPUs, CPUs, TPUs, etc)\n- If using the TPU, declare your model outside the training loop function\n", "<!--Copyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\nspecific language governing permissions and limitations under the License.\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n-->\n\n# Overview\n\nWelcome to the \ud83e\udd17 Accelerate tutorials! These introductory guides will help catch you up to speed on working with \ud83e\udd17 Accelerate.\nYou'll learn how to modify your code to have it work with the API seamlessly, how to launch your script properly,\nand more!\n\nThese tutorials assume some basic knowledge of Python and familiarity with the PyTorch framework.\n\nIf you have any questions about \ud83e\udd17 Accelerate, feel free to join and ask the community on our [forum](https://discuss.huggingface.co/c/accelerate/18).", "<!--Copyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\nspecific language governing permissions and limitations under the License.\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n-->\n\n# Migrating your code to \ud83e\udd17 Accelerate\n\nThis tutorial will detail how to easily convert existing PyTorch code to use \ud83e\udd17 Accelerate!\nYou'll see that by just changing a few lines of code, \ud83e\udd17 Accelerate can perform its magic and get you on \nyour way toward running your code on distributed systems with ease!\n\n## The base training loop\n\nTo begin, write out a very basic PyTorch training loop. \n\n<Tip>\n\n    We are under the presumption that `training_dataloader`, `model`, `optimizer`, `scheduler`, and `loss_function` have been defined beforehand.\n\n</Tip>\n\n```python\ndevice = \"cuda\"\nmodel.to(device)\n\nfor batch in training_dataloader:\n    optimizer.zero_grad()\n    inputs, targets = batch\n    inputs = inputs.to(device)\n    targets = targets.to(device)\n    outputs = model(inputs)\n    loss = loss_function(outputs, targets)\n    loss.backward()\n    optimizer.step()\n    scheduler.step()\n```\n\n## Add in \ud83e\udd17 Accelerate\n\nTo start using \ud83e\udd17 Accelerate, first import and create an [`Accelerator`] instance:\n```python\nfrom accelerate import Accelerator\n\naccelerator = Accelerator()\n```\n[`Accelerator`] is the main force behind utilizing all the possible options for distributed training!\n\n### Setting the right device\n\nThe [`Accelerator`] class knows the right device to move any PyTorch object to at any time, so you should\nchange the definition of `device` to come from [`Accelerator`]:\n\n```diff\n- device = 'cuda'\n+ device = accelerator.device\n  model.to(device)\n```\n\n### Preparing your objects\n\nNext, you need to pass all of the important objects related to training into [`~Accelerator.prepare`]. \ud83e\udd17 Accelerate will\nmake sure everything is setup in the current environment for you to start training:\n\n```\nmodel, optimizer, training_dataloader, scheduler = accelerator.prepare(\n    model, optimizer, training_dataloader, scheduler\n)\n```\nThese objects are returned in the same order they were sent in. By default when using `device_placement=True`, all of the objects that can be sent to the right device will be.\nIf you need to work with data that isn't passed to [~Accelerator.prepare] but should be on the active device, you should pass in the `device` you made earlier. \n\n<Tip warning={true}>\n\n    Accelerate will only prepare objects that inherit from their respective PyTorch classes (such as `torch.optim.Optimizer`).\n\n</Tip>\n\n### Modifying the training loop\n\nFinally, three lines of code need to be changed in the training loop. \ud83e\udd17 Accelerate's DataLoader classes will automatically handle the device placement by default,\nand [`~Accelerator.backward`] should be used for performing the backward pass:\n\n```diff\n-   inputs = inputs.to(device)\n-   targets = targets.to(device)\n    outputs = model(inputs)\n    loss = loss_function(outputs, targets)\n-   loss.backward()\n+   accelerator.backward(loss)\n```\n\nWith that, your training loop is now ready to use \ud83e\udd17 Accelerate!\n\n## The finished code\n\nBelow is the final version of the converted code: \n\n```python\nfrom accelerate import Accelerator\n\naccelerator = Accelerator()\n\nmodel, optimizer, training_dataloader, scheduler = accelerator.prepare(\n    model, optimizer, training_dataloader, scheduler\n)\n\nfor batch in training_dataloader:\n    optimizer.zero_grad()\n    inputs, targets = batch\n    outputs = model(inputs)\n    loss = loss_function(outputs, targets)\n    accelerator.backward(loss)\n    optimizer.step()\n    scheduler.step()\n```\n\n## More Resources\n\nTo check out more ways on how to migrate to \ud83e\udd17 Accelerate, check out our [interactive migration tutorial](https://huggingface.co/docs/accelerate/usage_guides/explore) which showcases other items that need to be watched for when using Accelerate and how to do so quickly.", "<!--Copyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\nspecific language governing permissions and limitations under the License.\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n-->\n\n# Installation and Configuration\n\nBefore you start, you will need to setup your environment, install the appropriate packages, and configure \ud83e\udd17 Accelerate. \ud83e\udd17 Accelerate is tested on **Python 3.8+**.\n\n## Installing \ud83e\udd17 Accelerate\n\n\ud83e\udd17 Accelerate is available on pypi and conda, as well as on GitHub. Details to install from each are below:\n\n### pip \n\nTo install \ud83e\udd17 Accelerate from pypi, perform:\n\n```bash\npip install accelerate\n```\n\n### conda\n\n\ud83e\udd17 Accelerate can also be installed with conda with:\n\n```bash\nconda install -c conda-forge accelerate\n```\n\n### Source\n\nNew features are added every day that haven't been released yet. To try them out yourself, install\nfrom the GitHub repository:\n\n```bash\npip install git+https://github.com/huggingface/accelerate\n```\n\nIf you're working on contributing to the library or wish to play with the source code and see live \nresults as you run the code, an editable version can be installed from a locally-cloned version of the \nrepository:\n\n```bash\ngit clone https://github.com/huggingface/accelerate\ncd accelerate\npip install -e .\n```\n\n## Configuring \ud83e\udd17 Accelerate\n\nAfter installing, you need to configure \ud83e\udd17 Accelerate for how the current system is setup for training. \nTo do so run the following and answer the questions prompted to you:\n\n```bash\naccelerate config\n```\n\nTo write a barebones configuration that doesn't include options such as DeepSpeed configuration or running on TPUs, you can quickly run:\n\n```bash\npython -c \"from accelerate.utils import write_basic_config; write_basic_config(mixed_precision='fp16')\"\n```\n\ud83e\udd17 Accelerate will automatically utilize the maximum number of GPUs available and set the mixed precision mode.\n\nTo check that your configuration looks fine, run:\n\n```bash\naccelerate env\n```\n\nAn example output is shown below, which describes two GPUs on a single machine with no mixed precision being used:\n\n```bash\n- `Accelerate` version: 0.11.0.dev0\n- Platform: Linux-5.10.0-15-cloud-amd64-x86_64-with-debian-11.3\n- Python version: 3.7.12\n- Numpy version: 1.19.5\n- PyTorch version (GPU?): 1.12.0+cu102 (True)\n- `Accelerate` default config:\n        - compute_environment: LOCAL_MACHINE\n        - distributed_type: MULTI_GPU\n        - mixed_precision: no\n        - use_cpu: False\n        - num_processes: 2\n        - machine_rank: 0\n        - num_machines: 1\n        - main_process_ip: None\n        - main_process_port: None\n        - main_training_function: main\n        - deepspeed_config: {}\n        - fsdp_config: {}\n```", "<!--Copyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\nspecific language governing permissions and limitations under the License.\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n-->\n\n# Launching your \ud83e\udd17 Accelerate scripts\n\nIn the previous tutorial, you were introduced to how to modify your current training script to use \ud83e\udd17 Accelerate.\nThe final version of that code is shown below:\n\n```python\nfrom accelerate import Accelerator\n\naccelerator = Accelerator()\n\nmodel, optimizer, training_dataloader, scheduler = accelerator.prepare(\n    model, optimizer, training_dataloader, scheduler\n)\n\nfor batch in training_dataloader:\n    optimizer.zero_grad()\n    inputs, targets = batch\n    outputs = model(inputs)\n    loss = loss_function(outputs, targets)\n    accelerator.backward(loss)\n    optimizer.step()\n    scheduler.step()\n```\n\nBut how do you run this code and have it utilize the special hardware available to it?\n\nFirst, you should rewrite the above code into a function, and make it callable as a script. For example:\n\n```diff\n  from accelerate import Accelerator\n  \n+ def main():\n      accelerator = Accelerator()\n\n      model, optimizer, training_dataloader, scheduler = accelerator.prepare(\n          model, optimizer, training_dataloader, scheduler\n      )\n\n      for batch in training_dataloader:\n          optimizer.zero_grad()\n          inputs, targets = batch\n          outputs = model(inputs)\n          loss = loss_function(outputs, targets)\n          accelerator.backward(loss)\n          optimizer.step()\n          scheduler.step()\n\n+ if __name__ == \"__main__\":\n+     main()\n```\n\nNext, you need to launch it with `accelerate launch`. \n\n<Tip warning={true}>\n\n  It's recommended you run `accelerate config` before using `accelerate launch` to configure your environment to your liking. \n  Otherwise \ud83e\udd17 Accelerate will use very basic defaults depending on your system setup.\n\n</Tip>\n\n\n## Using accelerate launch\n\n\ud83e\udd17 Accelerate has a special CLI command to help you launch your code in your system through `accelerate launch`.\nThis command wraps around all of the different commands needed to launch your script on various platforms, without you having to remember what each of them is.\n\n<Tip>\n\n  If you are familiar with launching scripts in PyTorch yourself such as with `torchrun`, you can still do this. It is not required to use `accelerate launch`.\n\n</Tip>\n\nYou can launch your script quickly by using:\n\n```bash\naccelerate launch {script_name.py} --arg1 --arg2 ...\n```\n\nJust put `accelerate launch` at the start of your command, and pass in additional arguments and parameters to your script afterward like normal!\n\nSince this runs the various torch spawn methods, all of the expected environment variables can be modified here as well.\nFor example, here is how to use `accelerate launch` with a single GPU:\n\n```bash\nCUDA_VISIBLE_DEVICES=\"0\" accelerate launch {script_name.py} --arg1 --arg2 ...\n```\n\nYou can also use `accelerate launch` without performing `accelerate config` first, but you may need to manually pass in the right configuration parameters.\nIn this case, \ud83e\udd17 Accelerate will make some hyperparameter decisions for you, e.g., if GPUs are available, it will use all of them by default without the mixed precision.\nHere is how you would use all GPUs and train with mixed precision disabled:\n\n```bash\naccelerate launch --multi_gpu {script_name.py} {--arg1} {--arg2} ...\n```\n\nOr by specifying a number of GPUs to use:\n\n```bash\naccelerate launch --num_processes=2 {script_name.py} {--arg1} {--arg2} ...\n```\n\nTo get more specific you should pass in the needed parameters yourself. For instance, here is how you \nwould also launch that same script on two GPUs using mixed precision while avoiding all of the warnings: \n\n```bash\naccelerate launch --multi_gpu --mixed_precision=fp16 --num_processes=2 {script_name.py} {--arg1} {--arg2} ...\n```\n\nFor a complete list of parameters you can pass in, run:\n\n```bash\naccelerate launch -h\n```\n\n<Tip>\n\n  Even if you are not using \ud83e\udd17 Accelerate in your code, you can still use the launcher for starting your scripts!\n\n</Tip>\n\nFor a visualization of this difference, that earlier `accelerate launch` on multi-gpu would look something like so with `torchrun`:\n\n```bash\nMIXED_PRECISION=\"fp16\" torchrun --nproc_per_node=2 --num_machines=1 {script_name.py} {--arg1} {--arg2} ...\n```\n\nYou can also launch your script utilizing the launch CLI as a python module itself, enabling the ability to pass in other python-specific\nlaunching behaviors. To do so, use `accelerate.commands.launch` instead of `accelerate launch`:\n\n```bash\npython -m accelerate.commands.launch --num_processes=2 {script_name.py} {--arg1} {--arg2}\n```\n\nIf you want to execute the script with any other python flags, you can pass them in as well similar to `-m`, such as \nthe below example enabling unbuffered stdout and stderr:\n\n```bash\npython -u -m accelerate.commands.launch --num_processes=2 {script_name.py} {--arg1} {--arg2}\n```\n\n\n## Why you should always use `accelerate config`\n\nWhy is it useful to the point you should **always** run `accelerate config`? \n\nRemember that earlier call to `accelerate launch` as well as `torchrun`?\nPost configuration, to run that script with the needed parts you just need to use `accelerate launch` outright, without passing anything else in:\n\n```bash\naccelerate launch {script_name.py} {--arg1} {--arg2} ...\n```\n\n\n## Custom Configurations\n\nAs briefly mentioned earlier, `accelerate launch` should be mostly used through combining set configurations \nmade with the `accelerate config` command. These configs are saved to a `default_config.yaml` file in your cache folder for \ud83e\udd17 Accelerate. \nThis cache folder is located at (with decreasing order of priority):\n\n- The content of your environment variable `HF_HOME` suffixed with `accelerate`.\n- If it does not exist, the content of your environment variable `XDG_CACHE_HOME` suffixed with\n  `huggingface/accelerate`.\n- If this does not exist either, the folder `~/.cache/huggingface/accelerate`.\n\nTo have multiple configurations, the flag `--config_file` can be passed to the `accelerate launch` command paired \nwith the location of the custom yaml. \n\nAn example yaml may look something like the following for two GPUs on a single machine using `fp16` for mixed precision:\n```yaml\ncompute_environment: LOCAL_MACHINE\ndeepspeed_config: {}\ndistributed_type: MULTI_GPU\nfsdp_config: {}\nmachine_rank: 0\nmain_process_ip: null\nmain_process_port: null\nmain_training_function: main\nmixed_precision: fp16\nnum_machines: 1\nnum_processes: 2\nuse_cpu: false\n```\n\nLaunching a script from the location of that custom yaml file looks like the following:\n```bash\naccelerate launch --config_file {path/to/config/my_config_file.yaml} {script_name.py} {--arg1} {--arg2} ...\n```\n", "<!--Copyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\nspecific language governing permissions and limitations under the License.\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n-->\n\n# Deferring Executions\n\nWhen you run your usual script, instructions are executed in order. Using \ud83e\udd17 Accelerate to deploy your script on several\nGPUs at the same time introduces a complication: while each process executes all instructions in order, some may be\nfaster than others.\n\nYou might need to wait for all processes to have reached a certain point before executing a given instruction. For\ninstance, you shouldn't save a model before being sure every process is done with training, and you wouldn't want to \ncontinue training before all the model weights have been loaded in. To do this, just write the following line in your code:\n\n```\naccelerator.wait_for_everyone()\n```\n\nThis instruction will block all the processes that arrive first until all the other processes have reached that\npoint (if you run your script on just one GPU or CPU, this won't do anything).\n\nA few example cases of when to use this utility are listed below:\n\n<Tip>\n\n    Some of these are utilized with the [`~Accelerator.main_process_first`] context manager, which utilizes [`~Accelerator.wait_for_everyone`] to \n    run a particular set of code on the main process beforehand before triggering and launching the other processes\n\n</Tip>\n\n## Downloading a Dataset \n\nWhen downloading a dataset, you should download it first on the main process and then load the cached dataset afterward\n\n<Tip>\n\n    `load_dataset` will perform a lock under the hood to stop multiple downloads from happening at once, but if you are downloading something \n    not using this library you should use this method.\n    \n</Tip>\n\n```python\nwith accelerator.main_process_first():\n    datasets = load_dataset(\"glue\", \"mrpc\")\n```\n\nUnder the hood this is the same as calling: \n\n```python\n# First do something on the main process\nif accelerator.is_main_process:\n    datasets = load_dataset(\"glue\", \"mrpc\")\nelse:\n    accelerator.wait_for_everyone()\n\n# And then send it to the rest of them\nif not accelerator.is_main_process:\n    datasets = load_dataset(\"glue\", \"mrpc\")\nelse:\n    accelerator.wait_for_everyone()\n```\n\n## Saving the `state_dict`\n\nWhen saving the `state_dict` of the model, since you would normally save one file on just the main process\nyou should specify that:\n\n```python\nif accelerator.is_main_process:\n    model = accelerator.unwrap_model(model)\n    torch.save(model.state_dict(), \"weights.pth\")\n```\n\n## Loading in the `state_dict`\n\nWhen loading in the `state_dict` to a model, optimizer, or scheduler, you should wait \nfor all workers to have the weights loaded in before moving on to training\n\n```python\nwith accelerator.main_process_first():\n    state = torch.load(\"weights.pth\")\n    model.load_state_dict(state)\n```\n\n## Applying a multi-worker CPU operation \n\nApplying a `map()` operation on multiple workers, such as tokenizing should be done on the \nmain process first, and then propagated to each one. \n\n```python\ndatasets = load_dataset(\"glue\", \"mrpc\")\n\nwith accelerator.main_process_first():\n    tokenized_datasets = datasets.map(\n        tokenize_function,\n        batched=True,\n        remove_columns=[\"idx\", \"sentence1\", \"sentence2\"],\n    )\n```\n", "<!--Copyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\nspecific language governing permissions and limitations under the License.\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n-->\n\n# Gradient Synchronization\n\nPyTorch's distributed module operates by communicating back and forth between all of the GPUs in your system.\nThis communication takes time, and ensuring all processes know the states of each other happens at particular triggerpoints\nwhen using the `ddp` module. \n\nThese triggerpoints are added to the PyTorch model, specifically their `forward()` and `backward()` methods. \nThis happens when the model is wrapped with `DistributedDataParallel`:\n```python\nimport torch.nn as nn\nfrom torch.nn.parallel import DistributedDataParallel\n\nmodel = nn.Linear(10, 10)\nddp_model = DistributedDataParallel(model)\n```\nIn \ud83e\udd17 Accelerate this conversion happens automatically when calling [`~Accelerator.prepare`] and passing in your model.\n\n```diff\n+ from accelerate import Accelerator\n+ accelerator = Accelerator()\n  import torch.nn as nn\n- from torch.nn.parallel import DistributedDataParallel\n\n  model = nn.Linear(10,10)\n+ model = accelerator.prepare(model)\n```\n\n## The slowdown in gradient accumulation\n\nYou now understand that PyTorch adds hooks to the `forward` and `backward` method of your PyTorch model when \ntraining in a distributed setup. But how does this risk slowing down your code?\n\nIn DDP (distributed data parallel), the specific order in which processes are performed and ran are expected\nat specific points and these must also occur at roughly the same time before moving on.\n\nThe most direct example is when you update model parameters through\n`optimizer.step()`.\nWithout gradient accumulation, all instances of the model need to have updated\ntheir gradients computed, collated, and updated before moving on to the next\nbatch of data.\nWhen performing gradient accumulation, you accumulate `n` loss gradients and\nskip `optimizer.step()` until `n` batches have been reached. As all training\nprocesses only need to sychronize by the time `optimizer.step()` is called,\nwithout any modification to your training step, this neededless inter-process\ncommunication can cause a significant slowdown.\n\n How can you avoid this overhead?\n\n## Solving the slowdown problem\n\nSince you are skipping model parameter updates when training on these batches, their gradients do not need to be synchronized until the point where `optimizer.step()` is actually called. \nPyTorch cannot automagically tell when you need to do this, but they do provide a tool to help through the [`no_sync`](https://pytorch.org/docs/stable/generated/torch.nn.parallel.DistributedDataParallel.html#torch.nn.parallel.DistributedDataParallel.no_sync) context manager\nthat is added to your model after converting it to DDP.\n\nUnder this context manager, PyTorch will skip synchronizing the gradients when\n`.backward()` is called, and the first call to `.backward()` outside this \ncontext manager will trigger the synchronization. See an example below:\n```python\nddp_model, dataloader, optimizer = accelerator.prepare(model, dataloader, optimizer)\n\nfor index, batch in enumerate(dataloader):\n    inputs, targets = batch\n    # Trigger gradient synchronization on the last batch\n    if index != (len(dataloader) - 1):\n        with ddp_model.no_sync():\n            # Gradients only accumulate\n            outputs = ddp_model(inputs)\n            loss = loss_func(outputs)\n            accelerator.backward(loss)\n    else:\n        # Gradients finally sync\n        outputs = ddp_model(inputs)\n        loss = loss_func(outputs)\n        accelerator.backward(loss)\n        optimizer.step()\n```\n\nIn \ud83e\udd17 Accelerate to make this an API that can be called no matter the training device (though it may not do anything if you are not in a distributed system!),\n`ddp_model.no_sync` gets replaced with [`~Accelerator.no_sync`] and operates the same way:\n\n```diff\n  ddp_model, dataloader, optimizer = accelerator.prepare(model, dataloader, optimizer)\n\n  for index, batch in enumerate(dataloader):\n      inputs, targets = batch\n      # Trigger gradient synchronization on the last batch\n      if index != (len(dataloader)-1):\n-         with ddp_model.no_sync():\n+         with accelerator.no_sync(model):\n              # Gradients only accumulate\n              outputs = ddp_model(inputs)\n              loss = loss_func(outputs, targets)\n              accelerator.backward(loss)\n      else:\n          # Gradients finally sync\n          outputs = ddp_model(inputs)\n          loss = loss_func(outputs)\n          accelerator.backward(loss)\n          optimizer.step()\n          optimizer.zero_grad()\n```\n\nAs you may expect, the [`~Accelerator.accumulate`] function wraps around this conditional check by keeping track of the current batch number, leaving you with the final\ngradient accumulation API:\n\n```python\nddp_model, dataloader, optimizer = accelerator.prepare(model, dataloader, optimizer)\n\nfor batch in dataloader:\n    with accelerator.accumulate(model):\n        optimizer.zero_grad()\n        inputs, targets = batch\n        outputs = model(inputs)\n        loss = loss_function(outputs, targets)\n        accelerator.backward(loss)\n        optimizer.step()\n        optimizer.zero_grad()\n```\n\nAs a result, you should either use *`accelerator.accumulate` or `accelerator.no_sync`* when it comes to API choice. \n\n## Just how much of a slowdown is there, and easy mistakes you can make\n\nTo set up a realistic example, consider the following setup:\n\n* Two single-GPU T4 nodes and one node with two GPUs\n* Each GPU is a T4, and are hosted on GCP\n* The script used is a modification of the [NLP Example](https://github.com/muellerzr/timing_experiments/blob/main/baseline.py) script\n* Batch size per GPU is 16, and gradients are accumulated every 4 steps\n\nAll scripts are available in [this repository](https://github.com/muellerzr/timing_experiments).\n\nIf not careful about gradient synchronization and GPU communication, a *large* amount of time can be wasted \nfrom when these GPUs communicate to each other during unnecessary periods.\n\nBy how much?\n\nReference:\n- Baseline: uses no synchronization practices discussed here\n- `no_sync` improperly: `no_sync` only around the `backward` call, not the `forward`\n- `no_sync`: using the `no_sync` pattern properly\n- `accumulate`: using [`~Accelerator.accumulate`] properly\n\nBelow are the average seconds per batch iterating over 29 batches of data for each setup on both a single node and on the dual-node setup:\n\n|             | Baseline  | `no_sync` improperly | `no_sync` | `accumulate`| \n| :---------: | :-------: | :------------------: | :-------: | :---------: |\n| Multi-Node  | 2\u00b10.01s    | 2.13\u00b10.08s | **0.91\u00b10.11s** | **0.91\u00b10.11s** |\n| Single Node | 0.50\u00b10.01s | 0.50\u00b10.01s | **0.41\u00b10.015s** | **0.41\u00b10.015s** |\n\nAs you can see, if you are not careful about how you set up your gradient synchronization, you can get upwards of more than a 2x slowdown during training!\n\nIf you are worried about making sure everything is done properly, we highly recommend utilizing the [`~Accelerator.accumulate`] function and passing in\n`gradient_accumulation_steps` or `gradient_accumulation_plugin` to the [`Accelerator`] object so Accelerate can handle this for you.\n", "<!--Copyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\nspecific language governing permissions and limitations under the License.\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n-->\n\n# Comparing performance between different device setups\n\nEvaluating and comparing the performance from different setups can be quite tricky if you don't know what to look for.\nFor example, you cannot run the same script with the same batch size across TPU, multi-GPU, and single-GPU with Accelerate \nand expect your results to line up. \n\nBut why?\n\nThere are three reasons for this that this tutorial will cover: \n\n1. **Setting the right seeds**\n2. **Observed Batch Sizes**\n3. **Learning Rates**\n\n## Setting the Seed \n\nWhile this issue has not come up as much, make sure to use [`utils.set_seed`] to fully set the seed in all distributed cases so training will be reproducible:\n\n```python\nfrom accelerate.utils import set_seed\n\nset_seed(42)\n```\n\nWhy is this important? Under the hood this will set **5** different seed settings:\n\n```python\n    random.seed(seed)\n    np.random.seed(seed)\n    torch.manual_seed(seed)\n    torch.cuda.manual_seed_all(seed)\n    # ^^ safe to call this function even if cuda is not available\n    if is_tpu_available():\n        xm.set_rng_state(seed)\n```\n\nThe random state, numpy's state, torch, torch's cuda state, and if TPUs are available torch_xla's cuda state.\n\n## Observed Batch Sizes \n\nWhen training with Accelerate, the batch size passed to the dataloader is the **batch size per GPU**. What this entails is \na batch size of 64 on two GPUs is truly a batch size of 128. As a result, when testing on a single GPU this needs to be accounted for,\nas well as similarly for TPUs. \n\nThe below table can be used as a quick reference to try out different batch sizes:\n\n<Tip>\n\nIn this example, there are two GPUs for \"Multi-GPU\" and a TPU pod with 8 workers\n\n</Tip>\n\n| Single GPU Batch Size | Multi-GPU Equivalent Batch Size | TPU Equivalent Batch Size |\n|-----------------------|---------------------------------|---------------------------|\n| 256                   | 128                             | 32                        |\n| 128                   | 64                              | 16                        |\n| 64                    | 32                              | 8                         |\n| 32                    | 16                              | 4                         |\n\n## Learning Rates \n\nAs noted in multiple sources[[1](https://aws.amazon.com/blogs/machine-learning/scalable-multi-node-deep-learning-training-using-gpus-in-the-aws-cloud/)][[2](https://docs.nvidia.com/clara/tlt-mi_archive/clara-train-sdk-v2.0/nvmidl/appendix/training_with_multiple_gpus.html)], the learning rate should be scaled *linearly* based on the number of devices present. The below \nsnippet shows doing so with Accelerate:\n\n<Tip>\n\nSince users can have their own learning rate schedulers defined, we leave this up to the user to decide if they wish to scale their \nlearning rate or not.\n \n</Tip>\n\n```python\nlearning_rate = 1e-3\naccelerator = Accelerator()\nlearning_rate *= accelerator.num_processes\n\noptimizer = AdamW(params=model.parameters(), lr=learning_rate)\n```\n\nYou will also find that `accelerate` will step the learning rate based on the number of processes being trained on. This is because \nof the observed batch size noted earlier. So in the case of 2 GPUs, the learning rate will be stepped twice as often as a single GPU\nto account for the batch size being twice as large (if no changes to the batch size on the single GPU instance are made).\n\n## Gradient Accumulation and Mixed Precision\n\nWhen using gradient accumulation and mixed precision, due to how gradient averaging works (accumulation) and the precision loss (mixed precision), \nsome degradation in performance is expected. This will be explicitly seen when comparing the batch-wise loss between different compute \nsetups. However, the overall loss, metric, and general performance at the end of training should be _roughly_ the same.\n", "<!--Copyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\nspecific language governing permissions and limitations under the License.\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n-->\n\n# Training on TPUs with \ud83e\udd17 Accelerate\n\nTraining on TPUs can be slightly different from training on multi-gpu, even with \ud83e\udd17 Accelerate. This guide aims to show you \nwhere you should be careful and why, as well as the best practices in general.\n\n## Training in a Notebook\n\nThe main carepoint when training on TPUs comes from the [`notebook_launcher`]. As mentioned in the [notebook tutorial](../usage_guides/notebook), you need to \nrestructure your training code into a function that can get passed to the [`notebook_launcher`] function and be careful about not declaring any tensors on the GPU.\n\nWhile on a TPU that last part is not as important, a critical part to understand is that when you launch code from a notebook you do so through a process called **forking**. \nWhen launching from the command-line, you perform **spawning**, where a python process is not currently running and you *spawn* a new process in. Since your Jupyter notebook is already \nutilizing a python process, you need to *fork* a new process from it to launch your code. \n\nWhere this becomes important is in regard to declaring your model. On forked TPU processes, it is recommended that you instantiate your model *once* and pass this into your \ntraining function. This is different than training on GPUs where you create `n` models that have their gradients synced and back-propagated at certain moments. Instead, one \nmodel instance is shared between all the nodes and it is passed back and forth. This is important especially when training on low-resource TPUs such as those provided in Kaggle kernels or\non Google Colaboratory. \n\nBelow is an example of a training function passed to the [`notebook_launcher`] if training on CPUs or GPUs:\n\n<Tip>\n\n    This code snippet is based off the one from the `simple_nlp_example` notebook found [here](https://github.com/huggingface/notebooks/blob/main/examples/accelerate/simple_nlp_example.ipynb) with slight \n    modifications for the sake of simplicity\n\n</Tip>\n\n```python\ndef training_function():\n    # Initialize accelerator\n    accelerator = Accelerator()\n    model = AutoModelForSequenceClassification.from_pretrained(\"bert-base-cased\", num_labels=2)\n    train_dataloader, eval_dataloader = create_dataloaders(\n        train_batch_size=hyperparameters[\"train_batch_size\"], eval_batch_size=hyperparameters[\"eval_batch_size\"]\n    )\n\n    # Instantiate optimizer\n    optimizer = AdamW(params=model.parameters(), lr=hyperparameters[\"learning_rate\"])\n\n    # Prepare everything\n    # There is no specific order to remember, we just need to unpack the objects in the same order we gave them to the\n    # prepare method.\n    model, optimizer, train_dataloader, eval_dataloader = accelerator.prepare(\n        model, optimizer, train_dataloader, eval_dataloader\n    )\n\n    num_epochs = hyperparameters[\"num_epochs\"]\n    # Now we train the model\n    for epoch in range(num_epochs):\n        model.train()\n        for step, batch in enumerate(train_dataloader):\n            outputs = model(**batch)\n            loss = outputs.loss\n            accelerator.backward(loss)\n\n            optimizer.step()\n            optimizer.zero_grad()\n```\n\n```python\nfrom accelerate import notebook_launcher\n\nnotebook_launcher(training_function)\n```\n\n<Tip>\n\n    The `notebook_launcher` will default to 8 processes if \ud83e\udd17 Accelerate has been configured for a TPU\n\n</Tip>\n\nIf you use this example and declare the model *inside* the training loop, then on a low-resource system you will potentially see an error \nlike:\n\n```\nProcessExitedException: process 0 terminated with signal SIGSEGV\n```\n\nThis error is *extremely* cryptic but the basic explanation is you ran out of system RAM. You can avoid this entirely by reconfiguring the training function to \naccept a single `model` argument, and declare it in an outside cell:\n\n```python\n# In another Jupyter cell\nmodel = AutoModelForSequenceClassification.from_pretrained(\"bert-base-cased\", num_labels=2)\n```\n\n```diff\n+ def training_function(model):\n      # Initialize accelerator\n      accelerator = Accelerator()\n-     model = AutoModelForSequenceClassification.from_pretrained(\"bert-base-cased\", num_labels=2)\n      train_dataloader, eval_dataloader = create_dataloaders(\n          train_batch_size=hyperparameters[\"train_batch_size\"], eval_batch_size=hyperparameters[\"eval_batch_size\"]\n      )\n  ...\n```\n\nAnd finally calling the training function with:\n\n```diff\n  from accelerate import notebook_launcher\n- notebook_launcher(training_function)\n+ notebook_launcher(training_function, (model,))\n```\n\n<Tip>\n\n    The above workaround is only needed when launching a TPU instance from a Jupyter Notebook on a low-resource server such as Google Colaboratory or Kaggle. If \n    using a script or launching on a much beefier server declaring the model beforehand is not needed.\n\n</Tip>\n\n## Mixed Precision and Global Variables \n\nAs mentioned in the [mixed precision tutorial](../usage_guides/mixed_precision), \ud83e\udd17 Accelerate supports fp16 and bf16, both of which can be used on TPUs.\nThat being said, ideally `bf16` should be utilized as it is extremely efficient to use.\n\nThere are two \"layers\" when using `bf16` and \ud83e\udd17 Accelerate on TPUs, at the base level and at the operation level. \n\nAt the base level, this is enabled when passing `mixed_precision=\"bf16\"` to `Accelerator`, such as:\n```python\naccelerator = Accelerator(mixed_precision=\"bf16\")\n```\nBy default, this will cast `torch.float` and `torch.double` to `bfloat16` on TPUs. \nThe specific configuration being set is an environmental variable of `XLA_USE_BF16` is set to `1`.\n\nThere is a further configuration you can perform which is setting the `XLA_DOWNCAST_BF16` environmental variable. If set to `1`, then \n`torch.float` is `bfloat16` and `torch.double` is `float32`.\n\nThis is performed in the `Accelerator` object when passing `downcast_bf16=True`:\n```python\naccelerator = Accelerator(mixed_precision=\"bf16\", downcast_bf16=True)\n```\n\nUsing downcasting instead of bf16 everywhere is good for when you are trying to calculate metrics, log values, and more where raw bf16 tensors would be unusable. \n\n## Training Times on TPUs\n\nAs you launch your script, you may notice that training seems exceptionally slow at first. This is because TPUs\nfirst run through a few batches of data to see how much memory to allocate before finally utilizing this configured \nmemory allocation extremely efficiently. \n\nIf you notice that your evaluation code to calculate the metrics of your model takes longer due to a larger batch size being used, \nit is recommended to keep the batch size the same as the training data if it is too slow. Otherwise the memory will reallocate to this \nnew batch size after the first few iterations. \n\n<Tip>\n\n    Just because the memory is allocated does not mean it will be used or that the batch size will increase when going back to your training dataloader.\n\n</Tip>\n", "<!--Copyright 2021 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\nspecific language governing permissions and limitations under the License.\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n-->\n\n# The Command Line \n\nBelow is a list of all the available commands \ud83e\udd17 Accelerate with their parameters\n\n## accelerate config\n\n**Command**:\n\n`accelerate config` or `accelerate-config`\n\nLaunches a series of prompts to create and save a `default_config.yml` configuration file for your training system. Should \nalways be ran first on your machine.\n\n**Usage**: \n\n```bash\naccelerate config [arguments]\n```\n\n**Optional Arguments**:\n* `--config_file CONFIG_FILE` (`str`) -- The path to use to store the config file. Will default to a file named default_config.yaml in the cache location, which is the content\n                        of the environment `HF_HOME` suffixed with 'accelerate', or if you don't have such an environment variable, your cache directory\n                        (`~/.cache` or the content of `XDG_CACHE_HOME`) suffixed with `huggingface`.\n* `-h`, `--help` (`bool`) -- Show a help message and exit\n\n## accelerate config default\n\n**Command**:\n\n`accelerate config default` or `accelerate-config default`\n\nCreate a default config file for Accelerate with only a few flags set.\n\n**Usage**: \n\n```bash\naccelerate config default [arguments]\n```\n\n**Optional Arguments**:\n* `--config_file CONFIG_FILE` (`str`) -- The path to use to store the config file. Will default to a file named default_config.yaml in the cache location, which is the content\n                        of the environment `HF_HOME` suffixed with 'accelerate', or if you don't have such an environment variable, your cache directory\n                        (`~/.cache` or the content of `XDG_CACHE_HOME`) suffixed with `huggingface`.\n\n* `-h`, `--help` (`bool`) -- Show a help message and exit\n* `--mixed_precision {no,fp16,bf16}` (`str`) -- Whether or not to use mixed precision training. Choose between FP16 and BF16 (bfloat16) training. BF16 training is only supported on Nvidia Ampere GPUs and PyTorch 1.10 or later.\n\n## accelerate config update\n\n**Command**:\n\n`accelerate config update` or `accelerate-config update`\n\nUpdate an existing config file with the latest defaults while maintaining the old configuration.\n\n**Usage**: \n\n```bash\naccelerate config update [arguments]\n```\n\n**Optional Arguments**:\n* `--config_file CONFIG_FILE` (`str`) -- The path to the config file to update. Will default to a file named default_config.yaml in the cache location, which is the content\n                        of the environment `HF_HOME` suffixed with 'accelerate', or if you don't have such an environment variable, your cache directory\n                        (`~/.cache` or the content of `XDG_CACHE_HOME`) suffixed with `huggingface`.\n\n* `-h`, `--help` (`bool`) -- Show a help message and exit\n\n\n## accelerate env\n\n**Command**:\n\n`accelerate env` or `accelerate-env` or `python -m accelerate.commands.env`\n\nLists the contents of the passed \ud83e\udd17 Accelerate configuration file. Should always be used when opening an issue on the [GitHub repository](https://github.com/huggingface/accelerate).\n\n**Usage**:\n\n```bash\naccelerate env [arguments]\n```\n\n**Optional Arguments**:\n* `--config_file CONFIG_FILE` (`str`) -- The path to use to store the config file. Will default to a file named default_config.yaml in the cache location, which is the content\n                        of the environment `HF_HOME` suffixed with 'accelerate', or if you don't have such an environment variable, your cache directory\n                        (`~/.cache` or the content of `XDG_CACHE_HOME`) suffixed with `huggingface`.\n* `-h`, `--help` (`bool`) -- Show a help message and exit\n\n## accelerate launch\n\n**Command**:\n\n`accelerate launch` or `accelerate-launch` or `python -m accelerate.commands.launch`\n\nLaunches a specified script on a distributed system with the right parameters.\n\n**Usage**: \n\n```bash\naccelerate launch [arguments] {training_script} --{training_script-argument-1} --{training_script-argument-2} ...\n```\n\n**Positional Arguments**:\n\n- `{training_script}` -- The full path to the script to be launched in parallel\n- `--{training_script-argument-1}` -- Arguments of the training script\n\n**Optional Arguments**:\n\n* `-h`, `--help` (`bool`) -- Show a help message and exit\n* `--config_file CONFIG_FILE` (`str`)-- The config file to use for the default values in the launching script.\n* `-m`, `--module` (`bool`) -- Change each process to interpret the launch script as a Python module, executing with the same behavior as 'python -m'.\n* `--no_python` (`bool`) -- Skip prepending the training script with 'python' - just execute it directly. Useful when the script is not a Python script.\n* `--debug` (`bool`) -- Whether to print out the torch.distributed stack trace when something fails.\n* `-q`, `--quiet` (`bool`) -- Silence subprocess errors from the launch stack trace to only show the relevant tracebacks. (Only applicable to DeepSpeed and single-process configurations).\n\n\nThe rest of these arguments are configured through `accelerate config` and are read in from the specified `--config_file` (or default configuration) for their \nvalues. They can also be passed in manually.\n\n**Hardware Selection Arguments**:\n\n* `--cpu` (`bool`) -- Whether or not to force the training on the CPU.\n* `--multi_gpu` (`bool`) -- Whether or not this should launch a distributed GPU training.\n* `--tpu` (`bool`) -- Whether or not this should launch a TPU training.\n* `--ipex` (`bool`) -- Whether or not this should launch an Intel Pytorch Extension (IPEX) training.\n\n**Resource Selection Arguments**:\n\nThe following arguments are useful for fine-tuning how available hardware should be used\n\n* `--mixed_precision {no,fp16,bf16}` (`str`) -- Whether or not to use mixed precision training. Choose between FP16 and BF16 (bfloat16) training. BF16 training is only supported on Nvidia Ampere GPUs and PyTorch 1.10 or later.\n* `--num_processes NUM_PROCESSES` (`int`) -- The total number of processes to be launched in parallel.\n* `--num_machines NUM_MACHINES` (`int`) -- The total number of machines used in this training.\n* `--num_cpu_threads_per_process NUM_CPU_THREADS_PER_PROCESS` (`int`) -- The number of CPU threads per process. Can be tuned for optimal performance.\n\n**Training Paradigm Arguments**:\n\nThe following arguments are useful for selecting which training paradigm to use.\n\n* `--use_deepspeed` (`bool`) -- Whether or not to use DeepSpeed for training.\n* `--use_fsdp` (`bool`) -- Whether or not to use FullyShardedDataParallel for training.\n* `--use_megatron_lm` (`bool`) -- Whether or not to use Megatron-LM for training.\n* `--use_xpu` (`bool`) -- Whether to use IPEX plugin to speed up training on XPU specifically.\n\n**Distributed GPU Arguments**:\n\nThe following arguments are only useful when `multi_gpu` is passed or multi-gpu training is configured through `accelerate config`: \n\n* `--gpu_ids` (`str`) -- What GPUs (by id) should be used for training on this machine as a comma-seperated list\n* `--same_network` (`bool`) -- Whether all machines used for multinode training exist on the same local network.\n* `--machine_rank MACHINE_RANK` (`int`) -- The rank of the machine on which this script is launched.\n* `--main_process_ip MAIN_PROCESS_IP` (`str`) -- The IP address of the machine of rank 0.\n* `--main_process_port MAIN_PROCESS_PORT` (`int`) -- The port to use to communicate with the machine of rank 0.\n* `--rdzv_backend` (`str`) -- The rendezvous method to use, such as \"static\" or \"c10d\"\n* `--rdzv_conf` (`str`) -- Additional rendezvous configuration (<key1>=<value1>,<key2>=<value2>,...).\n* `--max_restarts` (`int`) -- Maximum number of worker group restarts before failing.\n* `--monitor_interval` (`float`) -- Interval, in seconds, to monitor the state of workers.\n\n**TPU Arguments**:\n\nThe following arguments are only useful when `tpu` is passed or TPU training is configured through `accelerate config`: \n\n* `--main_training_function MAIN_TRAINING_FUNCTION` (`str`) -- The name of the main function to be executed in your script.\n* `--downcast_bf16` (`bool`) -- Whether when using bf16 precision on TPUs if both float and double tensors are cast to bfloat16 or if double tensors remain as float32.\n\n**DeepSpeed Arguments**:\n\nThe following arguments are only useful when `use_deepspeed` is passed or `deepspeed` is configured through `accelerate config`: \n\n* `--deepspeed_config_file` (`str`) -- DeepSpeed config file.\n* `--zero_stage` (`int`) -- DeepSpeed's ZeRO optimization stage.\n* `--offload_optimizer_device` (`str`) -- Decides where (none|cpu|nvme) to offload optimizer states.\n* `--offload_param_device` (`str`) -- Decides where (none|cpu|nvme) to offload parameters.\n* `--gradient_accumulation_steps` (`int`) -- No of gradient_accumulation_steps used in your training script.\n* `--gradient_clipping` (`float`) -- Gradient clipping value used in your training script.\n* `--zero3_init_flag` (`str`) -- Decides Whether (true|false) to enable `deepspeed.zero.Init` for constructing massive models. Only applicable with DeepSpeed ZeRO Stage-3.\n* `--zero3_save_16bit_model` (`str`) -- Decides Whether (true|false) to save 16-bit model weights when using ZeRO Stage-3. Only applicable with DeepSpeed ZeRO Stage-3.\n* `--deepspeed_hostfile` (`str`) -- DeepSpeed hostfile for configuring multi-node compute resources.\n* `--deepspeed_exclusion_filter` (`str`) -- DeepSpeed exclusion filter string when using mutli-node setup.\n* `--deepspeed_inclusion_filter` (`str`) -- DeepSpeed inclusion filter string when using mutli-node setup.\n* `--deepspeed_multinode_launcher` (`str`) -- DeepSpeed multi-node launcher to use.\n\n**Fully Sharded Data Parallelism Arguments**:\n\nThe following arguments are only useful when `use_fdsp` is passed or Fully Sharded Data Parallelism is configured through `accelerate config`:\n\n* `--fsdp_offload_params` (`str`) -- Decides Whether (true|false) to offload parameters and gradients to CPU.\n* `--fsdp_min_num_params` (`int`) -- FSDP's minimum number of parameters for Default Auto Wrapping.\n* `--fsdp_sharding_strategy` (`int`) -- FSDP's Sharding Strategy.\n* `--fsdp_auto_wrap_policy` (`str`) -- FSDP's auto wrap policy.\n* `--fsdp_transformer_layer_cls_to_wrap` (`str`) -- Transformer layer class name (case-sensitive) to wrap, e.g, `BertLayer`, `GPTJBlock`, `T5Block` ...\n* `--fsdp_backward_prefetch_policy` (`str`) -- FSDP's backward prefetch policy.\n* `--fsdp_state_dict_type` (`str`) -- FSDP's state dict type.\n\n**Megatron-LM Arguments**:\n\nThe following arguments are only useful when `use_megatron_lm` is passed or Megatron-LM is configured through `accelerate config`:\n\n* `--megatron_lm_tp_degree` (``) -- Megatron-LM's Tensor Parallelism (TP) degree.\n* `--megatron_lm_pp_degree` (``) -- Megatron-LM's Pipeline Parallelism (PP) degree.\n* `--megatron_lm_num_micro_batches` (``) -- Megatron-LM's number of micro batches when PP degree > 1.\n* `--megatron_lm_sequence_parallelism` (``) -- Decides Whether (true|false) to enable Sequence Parallelism when TP degree > 1.\n* `--megatron_lm_recompute_activations` (``) -- Decides Whether (true|false) to enable Selective Activation Recomputation.\n* `--megatron_lm_use_distributed_optimizer` (``) -- Decides Whether (true|false) to use distributed optimizer which shards optimizer state and gradients across Data Pralellel (DP) ranks.\n* `--megatron_lm_gradient_clipping` (``) -- Megatron-LM's gradient clipping value based on global L2 Norm (0 to disable).\n\n**AWS SageMaker Arguments**:\n\nThe following arguments are only useful when training in SageMaker\n\n* `--aws_access_key_id AWS_ACCESS_KEY_ID` (`str`) -- The AWS_ACCESS_KEY_ID used to launch the Amazon SageMaker training job\n* `--aws_secret_access_key AWS_SECRET_ACCESS_KEY` (`str`) -- The AWS_SECRET_ACCESS_KEY used to launch the Amazon SageMaker training job\n\n## accelerate tpu-config\n\n`accelerate tpu-config`\n\n**Usage**:\n\n```bash\naccelerate tpu-config [arguments]\n```\n\n**Optional Arguments**:\n* `-h`, `--help` (`bool`) -- Show a help message and exit\n\n**Config Arguments**:\n\nArguments that can be configured through `accelerate config`.\n\n* `--config_file` (`str`) -- Path to the config file to use for accelerate.\n* `--tpu_name` (`str`) -- The name of the TPU to use. If not specified, will use the TPU specified in the config file.\n* `--tpu_zone` (`str`) -- The zone of the TPU to use. If not specified, will use the zone specified in the config file.\n\n**TPU Arguments**:\n\nArguments for options ran inside the TPU.\n\n* `--command_file` (`str`) -- The path to the file containing the commands to run on the pod on startup.\n* `--command` (`str`) -- A command to run on the pod. Can be passed multiple times.\n* `--install_accelerate` (`bool`) -- Whether to install accelerate on the pod. Defaults to False.\n* `--accelerate_version` (`str`) -- The version of accelerate to install on the pod. If not specified, will use the latest pypi version. Specify 'dev' to install from GitHub.\n* `--debug` (`bool`) -- If set, will print the command that would be run instead of running it.\n\n## accelerate test\n\n`accelerate test` or `accelerate-test`\n\nRuns `accelerate/test_utils/test_script.py` to verify that \ud83e\udd17 Accelerate has been properly configured on your system and runs. \n\n**Usage**: \n\n```bash\naccelerate test [arguments]\n```\n\n**Optional Arguments**:\n* `--config_file CONFIG_FILE` (`str`) -- The path to use to store the config file. Will default to a file named default_config.yaml in the cache location, which is the content\n                        of the environment `HF_HOME` suffixed with 'accelerate', or if you don't have such an environment variable, your cache directory\n                        (`~/.cache` or the content of `XDG_CACHE_HOME`) suffixed with `huggingface`.\n* `-h`, `--help` (`bool`) -- Show a help message and exit\n", "<!--Copyright 2022 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\nspecific language governing permissions and limitations under the License.\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n-->\n\n# Launchers\n\nFunctions for launching training on distributed processes.\n\n\n[[autodoc]] accelerate.notebook_launcher\n[[autodoc]] accelerate.debug_launcher", "<!--Copyright 2021 The HuggingFace Team. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\nthe License. You may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on\nan \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\nspecific language governing permissions and limitations under the License.\n\n\u26a0\ufe0f Note that this file is in Markdown but contain specific syntax for our doc-builder (similar to MDX) that may not be\nrendered properly in your Markdown viewer.\n-->\n\n# Helpful Utilities\n\nBelow are a variety of utility functions that \ud83e\udd17 Accelerate provides, broken down by use-case. \n\n## Constants\n\nConstants used throughout \ud83e\udd17 Accelerate for reference\n\nThe following are constants used when utilizing [`Accelerator.save_state`]\n\n`utils.MODEL_NAME`: `\"pytorch_model\"`\n`utils.OPTIMIZER_NAME`: `\"optimizer\"`\n`utils.RNG_STATE_NAME`: `\"random_states\"`\n`utils.SCALER_NAME`: `\"scaler.pt`\n`utils.SCHEDULER_NAME`: `\"scheduler`\n\nThe following are constants used when utilizing [`Accelerator.save_model`]\n\n`utils.WEIGHTS_NAME`: `\"pytorch_model.bin\"`\n`utils.SAFE_WEIGHTS_NAME`: `\"model.safetensors\"`\n`utils.WEIGHTS_INDEX_NAME`: `\"pytorch_model.bin.index.json\"`\n`utils.SAFE_WEIGHTS_INDEX_NAME`: `\"model.safetensors.index.json\"`\n\n## Data Classes\n\nThese are basic dataclasses used throughout \ud83e\udd17 Accelerate and they can be passed in as parameters.\n\n[[autodoc]] utils.DistributedType\n\n[[autodoc]] utils.DynamoBackend\n\n[[autodoc]] utils.LoggerType\n\n[[autodoc]] utils.PrecisionType\n\n[[autodoc]] utils.ProjectConfiguration\n\n## Plugins\n\nThese are plugins that can be passed to the [`Accelerator`] object. While they are defined elsewhere in the documentation, \nfor convience all of them are available to see here:\n\n[[autodoc]] utils.DeepSpeedPlugin\n\n[[autodoc]] utils.FullyShardedDataParallelPlugin\n\n[[autodoc]] utils.GradientAccumulationPlugin\n\n[[autodoc]] utils.MegatronLMPlugin\n\n[[autodoc]] utils.TorchDynamoPlugin\n\n\n## Data Manipulation and Operations\n\nThese include data operations that mimic the same `torch` ops but can be used on distributed processes.\n\n[[autodoc]] utils.broadcast\n\n[[autodoc]] utils.concatenate\n\n[[autodoc]] utils.gather\n\n[[autodoc]] utils.pad_across_processes\n\n[[autodoc]] utils.reduce\n\n[[autodoc]] utils.send_to_device\n\n## Environment Checks\n\nThese functionalities check the state of the current working environment including information about the operating system itself, what it can support, and if particular dependencies are installed. \n\n[[autodoc]] utils.is_bf16_available\n\n[[autodoc]] utils.is_ipex_available\n\n[[autodoc]] utils.is_mps_available\n\n[[autodoc]] utils.is_npu_available\n\n[[autodoc]] utils.is_torch_version\n\n[[autodoc]] utils.is_tpu_available\n\n[[autodoc]] utils.is_xpu_available\n\n## Environment Manipulation\n\n[[autodoc]] utils.patch_environment\n\n[[autodoc]] utils.clear_environment\n\n[[autodoc]] utils.write_basic_config\n\nWhen setting up \ud83e\udd17 Accelerate for the first time, rather than running `accelerate config` [~utils.write_basic_config] can be used as an alternative for quick configuration.\n\n## Memory\n\n[[autodoc]] utils.get_max_memory\n\n[[autodoc]] utils.find_executable_batch_size\n\n## Modeling\n\nThese utilities relate to interacting with PyTorch models\n\n[[autodoc]] utils.extract_model_from_parallel\n\n[[autodoc]] utils.get_max_layer_size\n\n[[autodoc]] utils.offload_state_dict\n\n\n## Parallel\n\nThese include general utilities that should be used when working in parallel.\n\n[[autodoc]] utils.extract_model_from_parallel\n\n[[autodoc]] utils.save\n\n[[autodoc]] utils.wait_for_everyone\n\n\n## Random\n\nThese utilities relate to setting and synchronizing of all the random states.\n\n[[autodoc]] utils.set_seed\n\n[[autodoc]] utils.synchronize_rng_state\n\n[[autodoc]] utils.synchronize_rng_states\n\n\n## PyTorch XLA\n\nThese include utilities that are useful while using PyTorch with XLA.\n\n[[autodoc]] utils.install_xla\n\n## Loading model weights\n\nThese include utilities that are useful to load checkpoints.\n\n[[autodoc]] utils.load_checkpoint_in_model\n\n## Quantization\n\nThese include utilities that are useful to quantize model.\n\n[[autodoc]] utils.load_and_quantize_model\n\n[[autodoc]] utils.BnbQuantizationConfig"]